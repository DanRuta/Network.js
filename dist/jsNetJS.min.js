"use strict";class ConvLayer{constructor(size,{filterSize:filterSize,zeroPadding:zeroPadding,stride:stride,activation:activation}={}){filterSize&&(this.filterSize=filterSize),stride&&(this.stride=stride),size&&(this.size=size),this.zeroPadding=zeroPadding,this.activationName=activation,void 0!=activation&&(this.activation=!("boolean"==typeof activation&&!activation)&&("function"==typeof activation?activation:NetMath[NetUtil.format(activation)].bind(this))),this.state="not-initialised"}assignNext(layer){this.nextLayer=layer}assignPrev(layer,layerIndex){switch(this.prevLayer=layer,this.layerIndex=layerIndex,this.size=this.size||4,this.filterSize=this.filterSize||this.net.conv.filterSize||3,this.stride=this.stride||this.net.conv.stride||1,!0){case layer instanceof FCLayer:this.channels=this.net.channels||1;break;case layer instanceof ConvLayer:this.channels=layer.size;break;case layer instanceof PoolLayer:this.channels=layer.activations.length}void 0==this.zeroPadding&&(this.zeroPadding=void 0==this.net.conv.zeroPadding?Math.floor(this.filterSize/2):this.net.conv.zeroPadding);const prevLayerOutWidth=layer instanceof FCLayer?Math.max(Math.floor(Math.sqrt(layer.size/this.channels)),1):layer.outMapSize;if(this.inMapValuesCount=Math.pow(prevLayerOutWidth,2),this.inZPMapValuesCount=Math.pow(prevLayerOutWidth+2*this.zeroPadding,2),this.outMapSize=(prevLayerOutWidth-this.filterSize+2*this.zeroPadding)/this.stride+1,this.outMapSize%1!=0)throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${this.outMapSize} in conv layer at index ${layerIndex}`);this.filters=[...new Array(this.size)].map(f=>new Filter)}init(){this.filters.forEach(filter=>{filter.weights=[...new Array(this.channels)].map(channelWeights=>[...new Array(this.filterSize)].map(weightsRow=>this.net.weightsInitFn(this.filterSize,this.weightsConfig))),filter.activationMap=[...new Array(this.outMapSize)].map(row=>[...new Array(this.outMapSize)].map(v=>0)),filter.errorMap=[...new Array(this.outMapSize)].map(row=>[...new Array(this.outMapSize)].map(v=>0)),filter.bias=1,1!=this.net.dropout&&(filter.dropoutMap=filter.activationMap.map(row=>row.map(v=>!1))),filter.init({updateFn:this.net.updateFn,activation:this.activationName||this.net.activationConfig,eluAlpha:this.net.eluAlpha})})}forward(){const activations=NetUtil.getActivations(this.prevLayer);for(let filterI=0;filterI<this.size;filterI++){const filter=this.filters[filterI];filter.sumMap=NetUtil.convolve({input:activations,zeroPadding:this.zeroPadding,weights:filter.weights,channels:this.channels,stride:this.stride,bias:filter.bias});for(let sumY=0;sumY<filter.sumMap.length;sumY++)for(let sumX=0;sumX<filter.sumMap.length;sumX++)"training"==this.state&&filter.dropoutMap&&(filter.dropoutMap[sumY][sumX]=Math.random()>this.net.dropout)?filter.activationMap[sumY][sumX]=0:this.activation?filter.activationMap[sumY][sumX]=this.activation(filter.sumMap[sumY][sumX],!1,filter)/(this.net.dropout||1):filter.activationMap[sumY][sumX]=filter.sumMap[sumY][sumX]}}backward(){if(this.nextLayer instanceof FCLayer)for(let filterI=0;filterI<this.filters.length;filterI++){const filter=this.filters[filterI];for(let emY=0;emY<filter.errorMap.length;emY++)for(let emX=0;emX<filter.errorMap.length;emX++){const weightIndex=filterI*this.outMapSize**2+emY*filter.errorMap.length+emX;for(let neuronI=0;neuronI<this.nextLayer.neurons.length;neuronI++){const neuron=this.nextLayer.neurons[neuronI];filter.errorMap[emY][emX]+=neuron.error*neuron.weights[weightIndex]}}}else if(this.nextLayer instanceof ConvLayer)for(let filterI=0;filterI<this.filters.length;filterI++)NetUtil.buildConvErrorMap(this.nextLayer,this.filters[filterI].errorMap,filterI);else for(let filterI=0;filterI<this.filters.length;filterI++){const filter=this.filters[filterI];for(let row=0;row<filter.errorMap.length;row++)for(let col=0;col<filter.errorMap.length;col++)filter.errorMap[row][col]=this.nextLayer.errors[filterI][row][col]}for(let filterI=0;filterI<this.filters.length;filterI++){const filter=this.filters[filterI];for(let row=0;row<filter.errorMap.length;row++)for(let col=0;col<filter.errorMap[0].length;col++)filter.dropoutMap&&filter.dropoutMap[row][col]?filter.errorMap[row][col]=0:this.activation&&(filter.errorMap[row][col]*=this.activation(filter.sumMap[row][col],!0,filter))}NetUtil.buildConvDWeights(this)}resetDeltaWeights(){for(let filterI=0;filterI<this.filters.length;filterI++){const filter=this.filters[filterI];filter.deltaBias=0;for(let channel=0;channel<filter.deltaWeights.length;channel++)for(let row=0;row<filter.deltaWeights[0].length;row++)for(let col=0;col<filter.deltaWeights[0][0].length;col++)filter.deltaWeights[channel][row][col]=0;for(let row=0;row<filter.errorMap.length;row++)for(let col=0;col<filter.errorMap.length;col++)filter.errorMap[row][col]=0;if(filter.dropoutMap)for(let row=0;row<filter.dropoutMap.length;row++)for(let col=0;col<filter.dropoutMap[0].length;col++)filter.dropoutMap[row][col]=!1}}applyDeltaWeights(){for(let filterI=0;filterI<this.filters.length;filterI++){const filter=this.filters[filterI];for(let channel=0;channel<filter.deltaWeights.length;channel++)for(let row=0;row<filter.deltaWeights[0].length;row++)for(let col=0;col<filter.deltaWeights[0][0].length;col++){void 0!=this.net.l2Error&&(this.net.l2Error+=.5*this.net.l2*filter.weights[channel][row][col]**2),void 0!=this.net.l1Error&&(this.net.l1Error+=this.net.l1*Math.abs(filter.weights[channel][row][col]));const regularized=(filter.deltaWeights[channel][row][col]+this.net.l2*filter.weights[channel][row][col]+this.net.l1*(filter.weights[channel][row][col]>0?1:-1))/this.net.miniBatchSize;filter.weights[channel][row][col]=this.net.weightUpdateFn.bind(this.net,filter.weights[channel][row][col],regularized,filter,[channel,row,col])(),void 0!=this.net.maxNorm&&(this.net.maxNormTotal+=filter.weights[channel][row][col]**2)}filter.bias=this.net.weightUpdateFn.bind(this.net,filter.bias,filter.deltaBias,filter)()}}backUpValidation(){for(let f=0;f<this.filters.length;f++){const filter=this.filters[f];filter.validationBias=filter.bias,filter.validationWeights=[];for(let wd=0;wd<filter.weights.length;wd++){const channel=[];for(let wy=0;wy<filter.weights[wd].length;wy++)channel[wy]=filter.weights[wd][wy].slice(0);filter.validationWeights[wd]=channel}}}restoreValidation(){for(let f=0;f<this.filters.length;f++){const filter=this.filters[f];filter.bias=filter.validationBias;for(let wd=0;wd<filter.weights.length;wd++)for(let wy=0;wy<filter.weights[wd].length;wy++)filter.weights[wd][wy]=filter.validationWeights[wd][wy].slice(0)}}toJSON(){return{weights:this.filters.map(filter=>({bias:filter.bias,weights:filter.weights}))}}fromJSON(data,layerIndex){this.filters.forEach((filter,fi)=>{if(data.weights[fi].weights.length!=filter.weights.length)throw new Error(`Mismatched weights depth. Given: ${data.weights[fi].weights.length} Existing: ${filter.weights.length}. At: layers[${layerIndex}], filters[${fi}]`);if(data.weights[fi].weights[0].length!=filter.weights[0].length)throw new Error(`Mismatched weights size. Given: ${data.weights[fi].weights[0].length} Existing: ${filter.weights[0].length}. At: layers[${layerIndex}], filters[${fi}]`);filter.bias=data.weights[fi].bias,filter.weights=data.weights[fi].weights})}getDataSize(){let size=0;for(let f=0;f<this.filters.length;f++){const filter=this.filters[f];for(let c=0;c<filter.weights.length;c++)for(let r=0;r<filter.weights[c].length;r++)size+=filter.weights[c][r].length;size+=1}return size}toIMG(){const data=[];for(let f=0;f<this.filters.length;f++){const filter=this.filters[f];data.push(filter.bias);for(let c=0;c<filter.weights.length;c++)for(let r=0;r<filter.weights[c].length;r++)for(let v=0;v<filter.weights[c][r].length;v++)data.push(filter.weights[c][r][v])}return data}fromIMG(data){let valI=0;for(let f=0;f<this.filters.length;f++){const filter=this.filters[f];filter.bias=data[valI],valI++;for(let c=0;c<filter.weights.length;c++)for(let r=0;r<filter.weights[c].length;r++)for(let v=0;v<filter.weights[c][r].length;v++)filter.weights[c][r][v]=data[valI],valI++}}}"undefined"!=typeof window&&(window.exports=window.exports||{}),"undefined"!=typeof window&&(window.ConvLayer=ConvLayer),exports.ConvLayer=ConvLayer;class FCLayer{constructor(size,{activation:activation}={}){this.size=size,this.neurons=[...new Array(size)].map(n=>new Neuron),this.state="not-initialised",void 0!=activation&&(this.activation=!("boolean"==typeof activation&&!activation)&&("function"==typeof activation?activation:NetMath[NetUtil.format(activation)].bind(this)))}assignNext(layer){this.nextLayer=layer}assignPrev(layer,layerIndex){this.prevLayer=layer,this.layerIndex=layerIndex}init(){this.neurons.forEach(neuron=>{let weightsCount;switch(!0){case this.prevLayer instanceof FCLayer:weightsCount=this.prevLayer.size;break;case this.prevLayer instanceof ConvLayer:weightsCount=this.prevLayer.filters.length*this.prevLayer.outMapSize**2;break;case this.prevLayer instanceof PoolLayer:weightsCount=this.prevLayer.activations.length*this.prevLayer.outMapSize**2}neuron.weights=this.net.weightsInitFn(weightsCount,this.weightsConfig),neuron.bias=1,neuron.init({updateFn:this.net.updateFn,activationConfig:this.net.activationConfig,eluAlpha:this.net.eluAlpha})})}forward(){this.neurons.forEach((neuron,ni)=>{if("training"==this.state&&(neuron.dropped=Math.random()>this.net.dropout))neuron.activation=0;else{neuron.sum=neuron.bias;const activations=NetUtil.getActivations(this.prevLayer);for(let ai=0;ai<activations.length;ai++)neuron.sum+=activations[ai]*neuron.weights[ai];neuron.activation=(this.activation?this.activation(neuron.sum,!1,neuron):neuron.sum)/(this.net.dropout||1)}})}backward(errors){this.neurons.forEach((neuron,ni)=>{if(neuron.dropped)neuron.error=0,neuron.deltaBias+=0;else{void 0!==errors?neuron.error=errors[ni]:(neuron.derivative=this.activation?this.activation(neuron.sum,!0,neuron):1,neuron.error=neuron.derivative*this.nextLayer.neurons.map(n=>n.error*(n.weights[ni]||0)).reduce((p,c)=>p+c,0));const activations=NetUtil.getActivations(this.prevLayer);for(let wi=0;wi<neuron.weights.length;wi++)neuron.deltaWeights[wi]+=neuron.error*activations[wi];neuron.deltaBias+=neuron.error}})}resetDeltaWeights(){for(let n=0;n<this.neurons.length;n++){this.neurons[n].deltaBias=0;for(let dwi=0;dwi<this.neurons[n].deltaWeights.length;dwi++)this.neurons[n].deltaWeights[dwi]=0}}applyDeltaWeights(){for(let n=0;n<this.neurons.length;n++){const neuron=this.neurons[n];for(let dwi=0;dwi<this.neurons[n].deltaWeights.length;dwi++){void 0!=this.net.l2Error&&(this.net.l2Error+=.5*this.net.l2*neuron.weights[dwi]**2),void 0!=this.net.l1Error&&(this.net.l1Error+=this.net.l1*Math.abs(neuron.weights[dwi]));const regularized=(neuron.deltaWeights[dwi]+this.net.l2*neuron.weights[dwi]+this.net.l1*(neuron.weights[dwi]>0?1:-1))/this.net.miniBatchSize;neuron.weights[dwi]=this.net.weightUpdateFn.bind(this.net,neuron.weights[dwi],regularized,neuron,dwi)(),void 0!=this.net.maxNorm&&(this.net.maxNormTotal+=neuron.weights[dwi]**2)}neuron.bias=this.net.weightUpdateFn.bind(this.net,neuron.bias,neuron.deltaBias,neuron)()}}backUpValidation(){for(let n=0;n<this.neurons.length;n++){const neuron=this.neurons[n];neuron.validationBias=neuron.bias,neuron.validationWeights=neuron.weights.slice(0)}}restoreValidation(){for(let n=0;n<this.neurons.length;n++){const neuron=this.neurons[n];neuron.bias=neuron.validationBias,neuron.weights=neuron.validationWeights.slice(0)}}toJSON(){return{weights:this.neurons.map(neuron=>({bias:neuron.bias,weights:neuron.weights}))}}fromJSON(data,layerIndex){this.neurons.forEach((neuron,ni)=>{if(data.weights[ni].weights.length!=neuron.weights.length)throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`);neuron.bias=data.weights[ni].bias,neuron.weights=data.weights[ni].weights})}getDataSize(){let size=0;for(let n=0;n<this.neurons.length;n++)size+=this.neurons[n].weights.length+1;return size}toIMG(){const data=[];for(let n=0;n<this.neurons.length;n++){data.push(this.neurons[n].bias);for(let w=0;w<this.neurons[n].weights.length;w++)data.push(this.neurons[n].weights[w])}return data}fromIMG(data){let valI=0;for(let n=0;n<this.neurons.length;n++){const neuron=this.neurons[n];neuron.bias=data[valI],valI++;for(let w=0;w<neuron.weights.length;w++)neuron.weights[w]=data[valI],valI++}}}const Layer=FCLayer;"undefined"!=typeof window&&(window.FCLayer=window.Layer=FCLayer),exports.FCLayer=exports.Layer=FCLayer;class Filter{constructor(){}init({updateFn:updateFn,activation:activation,eluAlpha:eluAlpha}={}){switch(this.deltaWeights=this.weights.map(channel=>channel.map(wRow=>wRow.map(w=>0))),this.deltaBias=0,updateFn){case"gain":this.biasGain=1,this.weightGains=this.weights.map(channel=>channel.map(wRow=>wRow.map(w=>1))),this.getWeightGain=(([channel,row,column])=>this.weightGains[channel][row][column]),this.setWeightGain=(([channel,row,column],v)=>this.weightGains[channel][row][column]=v);break;case"adagrad":case"rmsprop":case"adadelta":case"momentum":this.biasCache=0,this.weightsCache=this.weights.map(channel=>channel.map(wRow=>wRow.map(w=>0))),this.getWeightsCache=(([channel,row,column])=>this.weightsCache[channel][row][column]),this.setWeightsCache=(([channel,row,column],v)=>this.weightsCache[channel][row][column]=v),"adadelta"==updateFn&&(this.adadeltaBiasCache=0,this.adadeltaCache=this.weights.map(channel=>channel.map(wRow=>wRow.map(w=>0))),this.getAdadeltaCache=(([channel,row,column])=>this.adadeltaCache[channel][row][column]),this.setAdadeltaCache=(([channel,row,column],v)=>this.adadeltaCache[channel][row][column]=v));break;case"adam":this.m=0,this.v=0}"rrelu"==activation?this.rreluSlope=.001*Math.random():"elu"==activation&&(this.eluAlpha=eluAlpha)}getWeight([channel,row,column]){return this.weights[channel][row][column]}setWeight([channel,row,column],v){this.weights[channel][row][column]=v}getDeltaWeight([channel,row,column]){return this.deltaWeights[channel][row][column]}setDeltaWeight([channel,row,column],v){this.deltaWeights[channel][row][column]=v}}"undefined"!=typeof window&&(window.Filter=Filter),exports.Filter=Filter;class InputLayer extends FCLayer{constructor(size,{span:span=1}={}){super(size*span*span)}}"undefined"!=typeof window&&(window.InputLayer=InputLayer),exports.InputLayer=InputLayer;class NetMath{static sigmoid(value,prime){const val=1/(1+Math.exp(-value));return prime?val*(1-val):val}static tanh(value,prime){const exp=Math.exp(2*value);return prime?4/Math.pow(Math.exp(value)+Math.exp(-value),2)||1e-18:(exp-1)/(exp+1)||1e-18}static relu(value,prime){return prime?value>0?1:0:Math.max(value,0)}static lrelu(value,prime){return prime?value>0?1:this.lreluSlope||-5e-4:Math.max((this.lreluSlope||-5e-4)*Math.abs(value),value)}static rrelu(value,prime,neuron){return prime?value>0?1:neuron.rreluSlope:Math.max(neuron.rreluSlope,value)}static lecuntanh(value,prime){return prime?1.15333*Math.pow(NetMath.sech(2/3*value),2):1.7159*NetMath.tanh(2/3*value)}static elu(value,prime,neuron){return prime?value>=0?1:NetMath.elu(value,!1,neuron)+neuron.eluAlpha:value>=0?value:neuron.eluAlpha*(Math.exp(value)-1)}static crossentropy(target,output){return output.map((value,vi)=>target[vi]*Math.log(value+1e-15)+(1-target[vi])*Math.log(1+1e-15-value)).reduce((p,c)=>p-c,0)}static meansquarederror(calculated,desired){return calculated.map((output,index)=>Math.pow(output-desired[index],2)).reduce((prev,curr)=>prev+curr,0)/calculated.length}static rootmeansquarederror(calculated,desired){return Math.sqrt(NetMath.meansquarederror(calculated,desired))}static vanillasgd(value,deltaValue){return value+this.learningRate*deltaValue}static gain(value,deltaValue,neuron,weightI){const newVal=value+this.learningRate*deltaValue*(null==weightI?neuron.biasGain:neuron.getWeightGain(weightI));return newVal<=0&&value>0||newVal>=0&&value<0?null!=weightI?neuron.setWeightGain(weightI,Math.max(.95*neuron.getWeightGain(weightI),.5)):neuron.biasGain=Math.max(.95*neuron.biasGain,.5):null!=weightI?neuron.setWeightGain(weightI,Math.min(neuron.getWeightGain(weightI)+.05,5)):neuron.biasGain=Math.min(neuron.biasGain+.05,5),newVal}static adagrad(value,deltaValue,neuron,weightI){return null!=weightI?neuron.setWeightsCache(weightI,neuron.getWeightsCache(weightI)+Math.pow(deltaValue,2)):neuron.biasCache+=Math.pow(deltaValue,2),value+this.learningRate*deltaValue/(1e-6+Math.sqrt(null!=weightI?neuron.getWeightsCache(weightI):neuron.biasCache))}static rmsprop(value,deltaValue,neuron,weightI){return null!=weightI?neuron.setWeightsCache(weightI,this.rmsDecay*neuron.getWeightsCache(weightI)+(1-this.rmsDecay)*Math.pow(deltaValue,2)):neuron.biasCache=this.rmsDecay*neuron.biasCache+(1-this.rmsDecay)*Math.pow(deltaValue,2),value+this.learningRate*deltaValue/(1e-6+Math.sqrt(null!=weightI?neuron.getWeightsCache(weightI):neuron.biasCache))}static adam(value,deltaValue,neuron){neuron.m=.9*neuron.m+(1-.9)*deltaValue;const mt=neuron.m/(1-Math.pow(.9,this.iterations+1));neuron.v=.999*neuron.v+(1-.999)*Math.pow(deltaValue,2);const vt=neuron.v/(1-Math.pow(.999,this.iterations+1));return value+this.learningRate*mt/(Math.sqrt(vt)+1e-8)}static adadelta(value,deltaValue,neuron,weightI){if(null!=weightI){neuron.setWeightsCache(weightI,this.rho*neuron.getWeightsCache(weightI)+(1-this.rho)*Math.pow(deltaValue,2));const newVal=value+Math.sqrt((neuron.getAdadeltaCache(weightI)+1e-6)/(neuron.getWeightsCache(weightI)+1e-6))*deltaValue;return neuron.setAdadeltaCache(weightI,this.rho*neuron.getAdadeltaCache(weightI)+(1-this.rho)*Math.pow(deltaValue,2)),newVal}{neuron.biasCache=this.rho*neuron.biasCache+(1-this.rho)*Math.pow(deltaValue,2);const newVal=value+Math.sqrt((neuron.adadeltaBiasCache+1e-6)/(neuron.biasCache+1e-6))*deltaValue;return neuron.adadeltaBiasCache=this.rho*neuron.adadeltaBiasCache+(1-this.rho)*Math.pow(deltaValue,2),newVal}}static momentum(value,deltaValue,neuron,weightI){let v;return null!=weightI?(v=this.momentum*neuron.getWeightsCache(weightI)-this.learningRate*deltaValue,neuron.setWeightsCache(weightI,v)):(v=this.momentum*neuron.biasCache-this.learningRate*deltaValue,neuron.biasCache=v),value-v}static uniform(size,{limit:limit}){const values=[];for(let i=0;i<size;i++)values.push(2*Math.random()*limit-limit);return values}static gaussian(size,{mean:mean,stdDeviation:stdDeviation}){const values=[];for(let i=0;i<size;i++){let x1,x2,r;do{r=(x1=2*Math.random()-1)**2+(x2=2*Math.random()-1)**2}while(r>=1||!r);values.push(mean+x1*Math.sqrt(-2*Math.log(r)/r)*stdDeviation)}return values}static xaviernormal(size,{fanIn:fanIn,fanOut:fanOut}){return fanOut||0==fanOut?NetMath.gaussian(size,{mean:0,stdDeviation:Math.sqrt(2/(fanIn+fanOut))}):NetMath.lecunnormal(size,{fanIn:fanIn})}static xavieruniform(size,{fanIn:fanIn,fanOut:fanOut}){return fanOut||0==fanOut?NetMath.uniform(size,{limit:Math.sqrt(6/(fanIn+fanOut))}):NetMath.lecununiform(size,{fanIn:fanIn})}static lecunnormal(size,{fanIn:fanIn}){return NetMath.gaussian(size,{mean:0,stdDeviation:Math.sqrt(1/fanIn)})}static lecununiform(size,{fanIn:fanIn}){return NetMath.uniform(size,{limit:Math.sqrt(3/fanIn)})}static maxPool(layer,channel){const activations=NetUtil.getActivations(layer.prevLayer,channel,layer.inMapValuesCount);for(let row=0;row<layer.outMapSize;row++)for(let col=0;col<layer.outMapSize;col++){const rowStart=row*layer.stride,colStart=col*layer.stride;let activation=activations[rowStart*layer.prevLayerOutWidth+colStart];for(let filterRow=0;filterRow<layer.size;filterRow++)for(let filterCol=0;filterCol<layer.size;filterCol++){const value=activations[(rowStart+filterRow)*layer.prevLayerOutWidth+(colStart+filterCol)];value>activation&&(activation=value,layer.indeces[channel][row][col]=[filterRow,filterCol])}layer.activations[channel][row][col]=activation}}static softmax(v){const values=v.slice(0);let maxValue=values[0];for(let i=1;i<values.length;i++)values[i]>maxValue&&(maxValue=values[i]);const exponentials=new Array(values.length);let exponentialsSum=0;for(let i=0;i<values.length;i++){let e=Math.exp(values[i]-maxValue);exponentialsSum+=e,exponentials[i]=e}for(let i=0;i<values.length;i++)exponentials[i]/=exponentialsSum,values[i]=exponentials[i];return values}static sech(value){return 2*Math.exp(-value)/(1+Math.exp(-2*value))}static standardDeviation(arr){const avg=arr.reduce((p,c)=>p+c)/arr.length,diffs=arr.map(v=>v-avg).map(v=>v**2);return Math.sqrt(diffs.reduce((p,c)=>p+c)/diffs.length)}static maxNorm(){if(this.maxNormTotal>this.maxNorm){const multiplier=this.maxNorm/(1e-18+this.maxNormTotal);this.layers.forEach((layer,li)=>{li&&layer.neurons.forEach(neuron=>{neuron.weights.forEach((w,wi)=>neuron.setWeight(wi,neuron.getWeight(wi)*multiplier))})})}this.maxNormTotal=0}}"undefined"!=typeof window&&(window.NetMath=NetMath),exports.NetMath=NetMath;class NetUtil{static format(value,type="string"){switch(!0){case"string"==type&&"string"==typeof value:value=value.replace(/(_|\s)/g,"").toLowerCase();break;case"time"==type&&"number"==typeof value:const date=new Date(value),formatted=[];value<1e3?formatted.push(`${date.getMilliseconds()}ms`):value<6e4?formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`):(value>=36e5&&formatted.push(`${date.getHours()}h`),formatted.push(`${date.getMinutes()}m`),formatted.push(`${date.getSeconds()}s`)),value=formatted.join(" ")}return value}static shuffle(arr){for(let i=arr.length;i;i--){const j=Math.floor(Math.random()*i),x=arr[i-1];arr[i-1]=arr[j],arr[j]=x}}static addZeroPadding(map,zP){const data=[];for(let row=0;row<map.length;row++)data.push(map[row].slice(0));const extraRows=[];for(let i=0;i<data.length+2*zP;i++)extraRows.push(0);for(let col=0;col<data.length;col++)for(let i=0;i<zP;i++)data[col].splice(0,0,0),data[col].splice(data[col].length+1,data[col].length,0);for(let i=0;i<zP;i++)data.splice(0,0,extraRows.slice(0)),data.splice(data.length,data.length-1,extraRows.slice(0));return data}static arrayToMap(arr,size){const map=[];for(let i=0;i<size;i++){map[i]=[];for(let j=0;j<size;j++)map[i][j]=arr[i*size+j]}return map}static arrayToVolume(arr,channels){const vol=[],size=Math.sqrt(arr.length/channels),mapValues=size**2;for(let d=0;d<Math.floor(arr.length/mapValues);d++){const map=[];for(let i=0;i<size;i++){map[i]=[];for(let j=0;j<size;j++)map[i][j]=arr[d*mapValues+i*size+j]}vol[d]=map}return vol}static convolve({input:input,zeroPadding:zeroPadding,weights:weights,channels:channels,stride:stride,bias:bias}){const inputVol=NetUtil.arrayToVolume(input,channels),outputMap=[],paddedLength=inputVol[0].length+2*zeroPadding,fSSpread=Math.floor(weights[0].length/2);for(let di=0;di<channels;di++){inputVol[di]=NetUtil.addZeroPadding(inputVol[di],zeroPadding);for(let inputY=fSSpread;inputY<paddedLength-fSSpread;inputY+=stride){outputMap[(inputY-fSSpread)/stride]=outputMap[(inputY-fSSpread)/stride]||[];for(let inputX=fSSpread;inputX<paddedLength-fSSpread;inputX+=stride){let sum=0;for(let weightsY=0;weightsY<weights[0].length;weightsY++)for(let weightsX=0;weightsX<weights[0].length;weightsX++)sum+=inputVol[di][inputY+(weightsY-fSSpread)][inputX+(weightsX-fSSpread)]*weights[di][weightsY][weightsX];outputMap[(inputY-fSSpread)/stride][(inputX-fSSpread)/stride]=(outputMap[(inputY-fSSpread)/stride][(inputX-fSSpread)/stride]||0)+sum}}}for(let outY=0;outY<outputMap.length;outY++)for(let outX=0;outX<outputMap.length;outX++)outputMap[outY][outX]+=bias;return outputMap}static buildConvErrorMap(nextLayer,errorMap,filterI){const zeroPadding=nextLayer.zeroPadding,paddedLength=errorMap.length+2*zeroPadding,fSSpread=Math.floor(nextLayer.filterSize/2),paddedRow=[];for(let val=0;val<paddedLength;val++)paddedRow.push(0);for(let row=0;row<paddedLength;row++)errorMap[row]=paddedRow.slice(0);for(let nlFilterI=0;nlFilterI<nextLayer.size;nlFilterI++){const weights=nextLayer.filters[nlFilterI].weights[filterI],errMap=nextLayer.filters[nlFilterI].errorMap;for(let inputY=fSSpread;inputY<paddedLength-fSSpread;inputY+=nextLayer.stride)for(let inputX=fSSpread;inputX<paddedLength-fSSpread;inputX+=nextLayer.stride)for(let weightsY=0;weightsY<nextLayer.filterSize;weightsY++)for(let weightsX=0;weightsX<nextLayer.filterSize;weightsX++)errorMap[inputY+(weightsY-fSSpread)][inputX+(weightsX-fSSpread)]+=weights[weightsY][weightsX]*errMap[(inputY-fSSpread)/nextLayer.stride][(inputX-fSSpread)/nextLayer.stride]}errorMap.splice(0,zeroPadding),errorMap.splice(errorMap.length-zeroPadding,errorMap.length);for(let emYI=0;emYI<errorMap.length;emYI++)errorMap[emYI]=errorMap[emYI].splice(zeroPadding,errorMap[emYI].length-2*zeroPadding)}static buildConvDWeights(layer){const weightsCount=layer.filters[0].weights[0].length,fSSpread=Math.floor(weightsCount/2),channelsCount=layer.filters[0].weights.length;for(let filterI=0;filterI<layer.filters.length;filterI++){const filter=layer.filters[filterI];for(let channelI=0;channelI<channelsCount;channelI++){const inputValues=NetUtil.getActivations(layer.prevLayer,channelI,layer.inMapValuesCount),inputMap=NetUtil.addZeroPadding(NetUtil.arrayToMap(inputValues,Math.sqrt(layer.inMapValuesCount)),layer.zeroPadding);for(let inputY=fSSpread;inputY<inputMap.length-fSSpread;inputY+=layer.stride)for(let inputX=fSSpread;inputX<inputMap.length-fSSpread;inputX+=layer.stride){const error=filter.errorMap[(inputY-fSSpread)/layer.stride][(inputX-fSSpread)/layer.stride];for(let weightsY=0;weightsY<weightsCount;weightsY++)for(let weightsX=0;weightsX<weightsCount;weightsX++){const activation=inputMap[inputY-fSSpread+weightsY][inputX-fSSpread+weightsX];filter.deltaWeights[channelI][weightsY][weightsX]+=activation*error}}}for(let eY=0;eY<filter.errorMap.length;eY++)for(let eX=0;eX<filter.errorMap.length;eX++)filter.deltaBias+=filter.errorMap[eY][eX]}}static getActivations(layer,mapStartI,mapSize){const returnArr=[];if(1==arguments.length)if(layer instanceof FCLayer)for(let ni=0;ni<layer.neurons.length;ni++)returnArr.push(layer.neurons[ni].activation);else if(layer instanceof ConvLayer)for(let fi=0;fi<layer.filters.length;fi++)for(let rowI=0;rowI<layer.filters[fi].activationMap.length;rowI++)for(let colI=0;colI<layer.filters[fi].activationMap[rowI].length;colI++)returnArr.push(layer.filters[fi].activationMap[rowI][colI]);else for(let channel=0;channel<layer.activations.length;channel++)for(let row=0;row<layer.activations[0].length;row++)for(let col=0;col<layer.activations[0].length;col++)returnArr.push(layer.activations[channel][row][col]);else if(layer instanceof FCLayer)for(let i=mapStartI*mapSize;i<(mapStartI+1)*mapSize;i++)returnArr.push(layer.neurons[i].activation);else if(layer instanceof ConvLayer)for(let row=0;row<layer.filters[mapStartI].activationMap.length;row++)for(let col=0;col<layer.filters[mapStartI].activationMap[row].length;col++)returnArr.push(layer.filters[mapStartI].activationMap[row][col]);else for(let row=0;row<layer.activations[mapStartI].length;row++)for(let col=0;col<layer.activations[mapStartI].length;col++)returnArr.push(layer.activations[mapStartI][row][col]);return returnArr}static splitData(data,{training:training=.7,validation:validation=.15,test:test=.15}={}){const split={training:[],validation:[],test:[]};for(let i=0;i<data.length;i++){let x=Math.random();x>1-training?split.training.push(data[i]):x<validation?split.validation.push(data[i]):split.test.push(data[i])}return split}static normalize(data){let minVal=1/0,maxVal=-1/0;for(let i=0;i<data.length;i++)data[i]<minVal&&(minVal=data[i]),data[i]>maxVal&&(maxVal=data[i]);if(-1*minVal+maxVal!=0)for(let i=0;i<data.length;i++)data[i]=(data[i]+-1*minVal)/(-1*minVal+maxVal);else for(let i=0;i<data.length;i++)data[i]=.5;return{minVal:minVal,maxVal:maxVal}}static makeConfusionMatrix(originalData){let total=0,totalCorrect=0;const data=[];for(let r=0;r<originalData.length;r++){const row=[];for(let c=0;c<originalData[r].length;c++)row.push(originalData[r][c]);data.push(row)}for(let r=0;r<data.length;r++)for(let c=0;c<data[r].length;c++)total+=data[r][c];for(let r=0;r<data.length;r++){let rowTotal=0;totalCorrect+=data[r][r];for(let c=0;c<data[r].length;c++)rowTotal+=data[r][c],data[r][c]={count:data[r][c],percent:data[r][c]/total*100||0};const correctPercent=data[r][r].count/rowTotal*100;data[r].total={correct:correctPercent||0,wrong:100-correctPercent||0}}const bottomRow=[];for(let c=0;c<data[0].length;c++){let columnTotal=0;for(let r=0;r<data.length;r++)columnTotal+=data[r][c].count;const correctPercent=data[c][c].count/columnTotal*100;bottomRow.push({correct:correctPercent||0,wrong:100-correctPercent||0})}return data.total=bottomRow,data.total.total={correct:totalCorrect/total*100||0,wrong:100-totalCorrect/total*100||0},data}static printConfusionMatrix(data){if("undefined"!=typeof window){for(let r=0;r<data.length;r++){for(let c=0;c<data[r].length;c++)data[r][c]=`${data[r][c].count} (${data[r][c].percent.toFixed(1)}%)`;data[r].total=`${data[r].total.correct.toFixed(1)}% / ${data[r].total.wrong.toFixed(1)}%`,data.total[r]=`${data.total[r].correct.toFixed(1)}% / ${data.total[r].wrong.toFixed(1)}%`}return data.total.total=`${data.total.total.correct.toFixed(1)}% / ${data.total.total.wrong.toFixed(1)}%`,void console.table(data)}const padNum=(num,percent)=>{num=percent?num.toFixed(1)+"%":num.toString();const leftPad=Math.max(Math.floor((7-num.length)/2),0),rightPad=Math.max(7-(num.length+leftPad),0);return" ".repeat(leftPad)+num+" ".repeat(rightPad)};let colourText,colourBackground;process.stdout.write("\n[1m");for(let r=0;r<data.length;r++){colourText="[2m[37m";for(let c=0;c<data[r].length;c++)colourBackground=r==c?"[42m":"[41m",process.stdout.write(`${colourText}${colourBackground}[1m${padNum(data[r][c].count)}[22m`);colourText="[2m[32m",colourBackground="[47m",process.stdout.write(`${colourText}${colourBackground}${padNum(data[r].total.correct,!0)}`),colourText="[2m[37m",process.stdout.write(`${colourText}\n`);for(let c=0;c<data[r].length;c++)colourBackground=r==c?"[42m":"[41m",process.stdout.write(`${colourText}${colourBackground}${padNum(data[r][c].percent,!0)}`);colourText="[2m[31m",colourBackground="[47m",process.stdout.write(`${colourText}${colourBackground}${padNum(data[r].total.wrong,!0)}`),process.stdout.write("[1m[30m\n")}colourText="[22m[32m";for(const col of data.total)process.stdout.write(`${colourText}${colourBackground}${padNum(col.correct,!0)}`);colourBackground="[1m[44m",process.stdout.write(`${colourText}${colourBackground}${padNum(data.total.total.correct,!0)}\n`),colourText="[22m[31m",colourBackground="[47m";for(const col of data.total)process.stdout.write(`${colourText}${colourBackground}${padNum(col.wrong,!0)}`);colourText="[1m[31m",colourBackground="[44m",process.stdout.write(`${colourText}${colourBackground}${padNum(data.total.total.wrong,!0)}\n`),process.stdout.write("[0m\n")}}"undefined"!=typeof window&&(window.NetUtil=NetUtil),exports.NetUtil=NetUtil;class Network{constructor({learningRate:learningRate,layers:layers=[],updateFn:updateFn="vanillasgd",activation:activation="sigmoid",cost:cost="meansquarederror",momentum:momentum=.9,rmsDecay:rmsDecay,rho:rho,lreluSlope:lreluSlope,eluAlpha:eluAlpha,dropout:dropout=1,l2:l2,l1:l1,maxNorm:maxNorm,weightsConfig:weightsConfig,channels:channels,conv:conv,pool:pool}={}){switch(this.state="not-defined",this.layers=[],this.conv={},this.pool={},this.epochs=0,this.iterations=0,this.validations=0,this.dropout=0==dropout?1:dropout,this.error=0,activation=NetUtil.format(activation),updateFn=NetUtil.format(updateFn),cost=NetUtil.format(cost),this.l1=0,this.l2=0,l1&&(this.l1="boolean"==typeof l1?.005:l1,this.l1Error=0),l2&&(this.l2="boolean"==typeof l2?.001:l2,this.l2Error=0),maxNorm&&(this.maxNorm="boolean"==typeof maxNorm&&maxNorm?1e3:maxNorm,this.maxNormTotal=0),learningRate&&(this.learningRate=learningRate),channels&&(this.channels=channels),conv&&(void 0!=conv.filterSize&&(this.conv.filterSize=conv.filterSize),void 0!=conv.zeroPadding&&(this.conv.zeroPadding=conv.zeroPadding),void 0!=conv.stride&&(this.conv.stride=conv.stride)),pool&&(pool.size&&(this.pool.size=pool.size),pool.stride&&(this.pool.stride=pool.stride)),updateFn){case"rmsprop":this.learningRate=void 0==this.learningRate?.001:this.learningRate;break;case"adam":this.learningRate=void 0==this.learningRate?.01:this.learningRate;break;case"momentum":this.learningRate=void 0==this.learningRate?.2:this.learningRate,this.momentum=momentum;break;case"adadelta":this.rho=null==rho?.95:rho;break;default:if(void 0==this.learningRate)switch(activation){case"relu":case"lrelu":case"rrelu":case"elu":this.learningRate=.01;break;case"tanh":case"lecuntanh":this.learningRate=.001;break;default:this.learningRate=.2}}if(this.updateFn=[!1,null,void 0].includes(updateFn)?"vanillasgd":updateFn,this.weightUpdateFn=NetMath[this.updateFn],this.activation="function"==typeof activation?activation:NetMath[activation].bind(this),this.activationConfig=activation,this.cost="function"==typeof cost?cost:NetMath[cost],"rmsprop"==this.updateFn&&(this.rmsDecay=void 0==rmsDecay?.99:rmsDecay),this.lreluSlope=void 0==lreluSlope?-5e-4:lreluSlope,this.rreluSlope=.001*Math.random(),this.eluAlpha=void 0==eluAlpha?1:eluAlpha,this.weightsConfig={distribution:"xavieruniform"},void 0!=weightsConfig&&weightsConfig.distribution&&(this.weightsConfig.distribution=NetUtil.format(weightsConfig.distribution)),"uniform"==this.weightsConfig.distribution?this.weightsConfig.limit=weightsConfig&&void 0!=weightsConfig.limit?weightsConfig.limit:.1:"gaussian"==this.weightsConfig.distribution&&(this.weightsConfig.mean=weightsConfig.mean||0,this.weightsConfig.stdDeviation=weightsConfig.stdDeviation||.05),"function"==typeof this.weightsConfig.distribution?this.weightsInitFn=this.weightsConfig.distribution:this.weightsInitFn=NetMath[this.weightsConfig.distribution],layers.length)switch(!0){case layers.every(item=>Number.isInteger(item)):this.layers=layers.map(size=>new FCLayer(size)),this.state="constructed",this.initLayers();break;case layers.every(layer=>layer instanceof FCLayer||layer instanceof ConvLayer||layer instanceof PoolLayer):this.state="constructed",this.layers=layers,this.initLayers();break;default:throw new Error("There was an error constructing from the layers given.")}this.collectedErrors={training:[],validation:[],test:[]}}initLayers(input,expected){switch(this.state){case"initialised":return;case"not-defined":this.layers[0]=new FCLayer(input),this.layers[1]=new FCLayer(Math.ceil(input/expected>5?expected+Math.abs(input-expected)/4:input+expected)),this.layers[2]=new FCLayer(Math.ceil(expected))}this.layers.forEach(this.joinLayer.bind(this));const outSize=this.layers[this.layers.length-1].size;this.trainingConfusionMatrix=[...new Array(outSize)].map(r=>[...new Array(outSize)].map(v=>0)),this.testConfusionMatrix=[...new Array(outSize)].map(r=>[...new Array(outSize)].map(v=>0)),this.validationConfusionMatrix=[...new Array(outSize)].map(r=>[...new Array(outSize)].map(v=>0)),this.state="initialised"}joinLayer(layer,layerIndex){layer.net=this,layer.activation=void 0==layer.activation?this.activation:layer.activation,layer.weightsConfig={},Object.assign(layer.weightsConfig,this.weightsConfig),layerIndex?(this.layers[layerIndex-1].assignNext(layer),layer.assignPrev(this.layers[layerIndex-1],layerIndex),layer.weightsConfig.fanIn=layer.prevLayer.size,layerIndex<this.layers.length-1&&(layer.weightsConfig.fanOut=this.layers[layerIndex+1].size),layer.init()):this.layers.length>1&&(layer.weightsConfig.fanOut=this.layers[1].size),layer.state="initialised"}forward(data){if("initialised"!=this.state)throw new Error("The network layers have not been initialised.");if(void 0===data||null===data)throw new Error("No data passed to Network.forward()");if(Array.isArray(data[0])){const flat=[];for(let c=0;c<data.length;c++)for(let r=0;r<data[0].length;r++)for(let v=0;v<data[0].length;v++)flat.push(data[c][r][v]);data=flat}return data.length!=this.layers[0].neurons.length&&console.warn("Input data length did not match input layer neurons count."),this.layers[0].neurons.forEach((neuron,ni)=>neuron.activation=data[ni]),this.layers.forEach((layer,li)=>li&&layer.forward()),this.layers[this.layers.length-1].neurons.map(n=>n.activation)}backward(errors){if(void 0===errors)throw new Error("No data passed to Network.backward()");errors.length!=this.layers[this.layers.length-1].neurons.length&&console.warn("Expected data length did not match output layer neurons count.",errors),this.layers[this.layers.length-1].backward(errors);for(let layerIndex=this.layers.length-2;layerIndex>0;layerIndex--)this.layers[layerIndex].backward()}train(dataSet,{epochs:epochs=1,callback:callback,callbackInterval:callbackInterval=1,collectErrors:collectErrors,log:log=!0,miniBatchSize:miniBatchSize=1,shuffle:shuffle=!1,validation:validation}={}){return this.miniBatchSize="boolean"==typeof miniBatchSize&&miniBatchSize?dataSet[0].expected.length:miniBatchSize,this.validation=validation,new Promise((resolve,reject)=>{if(shuffle&&NetUtil.shuffle(dataSet),log&&console.log(`Training started. Epochs: ${epochs} Batch Size: ${this.miniBatchSize}`),void 0===dataSet||null===dataSet)return void reject("No data provided");if("initialised"!=this.state&&this.initLayers.bind(this,dataSet[0].input.length,(dataSet[0].expected||dataSet[0].output).length)(),this.layers.forEach(layer=>layer.state="training"),this.validation&&(this.validation.interval=this.validation.interval||dataSet.length,this.validation.earlyStopping))switch(this.validation.earlyStopping.type){case"threshold":this.validation.earlyStopping.threshold=this.validation.earlyStopping.threshold||.01;break;case"patience":this.validation.earlyStopping.patienceCounter=0,this.validation.earlyStopping.bestError=1/0,this.validation.earlyStopping.patience=this.validation.earlyStopping.patience||20;break;case"divergence":this.validation.earlyStopping.percent=this.validation.earlyStopping.percent||30,this.validation.earlyStopping.bestError=1/0}let elapsed,iterationIndex=0,epochsCounter=0;const startTime=Date.now(),logAndResolve=()=>{if(this.layers.forEach(layer=>layer.state="initialised"),this.validation&&this.validation.earlyStopping&&("patience"==this.validation.earlyStopping.type||"divergence"==this.validation.earlyStopping.type))for(let l=1;l<this.layers.length;l++)this.layers[l].restoreValidation();log&&console.log(`Training finished. Total time: ${NetUtil.format(elapsed,"time")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex,"time")}`),resolve()},doEpoch=()=>{this.epochs++,this.error=0,this.validationError=0,iterationIndex=0,void 0!=this.l2Error&&(this.l2Error=0),void 0!=this.l1Error&&(this.l1Error=0),doIteration()},doIteration=async()=>{if(!dataSet[iterationIndex].hasOwnProperty("input")||!dataSet[iterationIndex].hasOwnProperty("expected")&&!dataSet[iterationIndex].hasOwnProperty("output"))return void reject("Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')");let trainingError,validationError;const input=dataSet[iterationIndex].input,output=this.forward(input),target=dataSet[iterationIndex].expected||dataSet[iterationIndex].output;let classification=-1/0;const errors=[];for(let n=0;n<output.length;n++)errors[n]=(1==target[n]?1:0)-output[n],classification=Math.max(classification,output[n]);if(this.trainingConfusionMatrix[target.indexOf(1)]&&this.trainingConfusionMatrix[target.indexOf(1)][output.indexOf(classification)]++,this.validation&&iterationIndex&&iterationIndex%this.validation.interval==0&&(validationError=await this.validate(this.validation.data),this.validation.earlyStopping&&this.checkEarlyStopping(errors)))return log&&console.log("Stopping early"),logAndResolve();if(this.backward(errors),++iterationIndex%this.miniBatchSize==0?(this.applyDeltaWeights(),this.resetDeltaWeights()):iterationIndex>=dataSet.length&&this.applyDeltaWeights(),trainingError=this.cost(target,output),this.error+=trainingError,this.iterations++,elapsed=Date.now()-startTime,collectErrors&&(this.collectedErrors.training.push(trainingError),validationError&&this.collectedErrors.validation.push(validationError)),iterationIndex%callbackInterval!=0&&!validationError||"function"!=typeof callback||callback({iterations:this.iterations,validations:this.validations,validationError:validationError,trainingError:trainingError,elapsed:elapsed,input:input}),iterationIndex<dataSet.length)iterationIndex%callbackInterval==0?setTimeout(doIteration.bind(this),0):doIteration();else{if(epochsCounter++,log){let text=`Epoch: ${this.epochs}\nTraining Error: ${this.error/iterationIndex}`;validation&&(text+=`\nValidation Error: ${this.validationError}`),void 0!=this.l2Error&&(text+=`\nL2 Error: ${this.l2Error/iterationIndex}`),text+=`\nElapsed: ${NetUtil.format(elapsed,"time")} Average Duration: ${NetUtil.format(elapsed/epochsCounter,"time")}`,console.log(text)}epochsCounter<epochs?doEpoch():logAndResolve()}};this.resetDeltaWeights(),doEpoch()})}validate(data){return new Promise((resolve,reject)=>{let validationIndex=0,totalValidationErrors=0;const validateItem=item=>{const output=this.forward(data[validationIndex].input),target=data[validationIndex].expected||data[validationIndex].output;let classification=-1/0;for(let i=0;i<output.length;i++)classification=Math.max(classification,output[i]);this.validationConfusionMatrix[target.indexOf(1)]&&this.validationConfusionMatrix[target.indexOf(1)][output.indexOf(classification)]++,this.validations++,totalValidationErrors+=this.cost(target,output),this.validationError=totalValidationErrors/(validationIndex+1),++validationIndex<data.length?setTimeout(()=>validateItem(validationIndex),0):(this.lastValidationError=totalValidationErrors/data.length,resolve(totalValidationErrors/data.length))};validateItem(validationIndex)})}checkEarlyStopping(errors){let stop=!1;switch(this.validation.earlyStopping.type){case"threshold":return(stop=this.lastValidationError<=this.validation.earlyStopping.threshold)&&(this.backward(errors),this.applyDeltaWeights()),stop;case"patience":if(this.lastValidationError<this.validation.earlyStopping.bestError){this.validation.earlyStopping.patienceCounter=0,this.validation.earlyStopping.bestError=this.lastValidationError;for(let l=1;l<this.layers.length;l++)this.layers[l].backUpValidation()}else this.validation.earlyStopping.patienceCounter++,stop=this.validation.earlyStopping.patienceCounter>=this.validation.earlyStopping.patience;return stop;case"divergence":if(this.lastValidationError<this.validation.earlyStopping.bestError){this.validation.earlyStopping.bestError=this.lastValidationError;for(let l=1;l<this.layers.length;l++)this.layers[l].backUpValidation()}else stop=this.lastValidationError/this.validation.earlyStopping.bestError>=1+this.validation.earlyStopping.percent/100;return stop}}test(testSet,{log:log=!0,callback:callback,collectErrors:collectErrors}={}){return new Promise((resolve,reject)=>{void 0!==testSet&&null!==testSet||reject("No data provided"),log&&console.log("Testing started");let totalError=0,iterationIndex=0;const startTime=Date.now(),testInput=()=>{const input=testSet[iterationIndex].input,output=this.forward(input),target=testSet[iterationIndex].expected||testSet[iterationIndex].output,elapsed=Date.now()-startTime;let classification=-1/0;for(let i=0;i<output.length;i++)classification=Math.max(classification,output[i]);this.testConfusionMatrix[target.indexOf(1)]&&this.testConfusionMatrix[target.indexOf(1)][output.indexOf(classification)]++;const iterationError=this.cost(target,output);totalError+=iterationError,iterationIndex++,collectErrors&&this.collectedErrors.test.push(iterationError),"function"==typeof callback&&callback({iterations:iterationIndex,error:iterationError,elapsed:elapsed,input:input}),iterationIndex<testSet.length?setTimeout(testInput.bind(this),0):(log&&console.log(`Testing finished. Total time: ${NetUtil.format(elapsed,"time")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex,"time")}`),resolve(totalError/testSet.length))};testInput()})}resetDeltaWeights(){this.layers.forEach((layer,li)=>li&&layer.resetDeltaWeights())}applyDeltaWeights(){this.layers.forEach((layer,li)=>li&&layer.applyDeltaWeights()),void 0!=this.maxNorm&&(this.maxNormTotal=Math.sqrt(this.maxNormTotal),NetMath.maxNorm.bind(this)())}toJSON(){return{layers:this.layers.map(layer=>layer.toJSON())}}fromJSON(data){if(void 0===data||null===data)throw new Error("No JSON data given to import.");if(data.layers.length!=this.layers.length)throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`);this.resetDeltaWeights(),this.layers.forEach((layer,li)=>li&&layer.fromJSON(data.layers[li],li))}toIMG(IMGArrays,opts={}){if(!IMGArrays)throw new Error("The IMGArrays library must be provided. See the documentation for instructions.");const data=[];for(let l=1;l<this.layers.length;l++){const layerData=this.layers[l].toIMG();for(let v=0;v<layerData.length;v++)data.push(layerData[v])}return IMGArrays.toIMG(data,opts)}fromIMG(rawData,IMGArrays,opts={}){if(!IMGArrays)throw new Error("The IMGArrays library must be provided. See the documentation for instructions.");const data=IMGArrays.fromIMG(rawData,opts);for(let l=1;l<this.layers.length;l++){const dataCount=this.layers[l].getDataSize();this.layers[l].fromIMG(data.splice(0,dataCount))}}printConfusionMatrix(type){if(type)NetUtil.printConfusionMatrix(NetUtil.makeConfusionMatrix(this[`${type}ConfusionMatrix`]));else{const data=[];for(let r=0;r<this.trainingConfusionMatrix.length;r++){const row=[];for(let c=0;c<this.trainingConfusionMatrix.length;c++)row.push(this.trainingConfusionMatrix[r][c]+this.testConfusionMatrix[r][c]+this.validationConfusionMatrix[r][c]);data.push(row)}NetUtil.printConfusionMatrix(NetUtil.makeConfusionMatrix(data))}}static get version(){return"3.4.1"}}"undefined"!=typeof window&&(window.Network=Network),exports.Network=Network;class Neuron{constructor(){}init({updateFn:updateFn,activation:activation,eluAlpha:eluAlpha}={}){const size=this.weights.length;switch(this.deltaWeights=this.weights.map(v=>0),updateFn){case"gain":this.biasGain=1,this.weightGains=[...new Array(size)].map(v=>1),this.getWeightGain=(i=>this.weightGains[i]),this.setWeightGain=((i,v)=>this.weightGains[i]=v);break;case"adagrad":case"rmsprop":case"adadelta":case"momentum":this.biasCache=0,this.weightsCache=[...new Array(size)].map(v=>0),this.getWeightsCache=(i=>this.weightsCache[i]),this.setWeightsCache=((i,v)=>this.weightsCache[i]=v),"adadelta"==updateFn&&(this.adadeltaBiasCache=0,this.adadeltaCache=[...new Array(size)].map(v=>0),this.getAdadeltaCache=(i=>this.adadeltaCache[i]),this.setAdadeltaCache=((i,v)=>this.adadeltaCache[i]=v));break;case"adam":this.m=0,this.v=0}"rrelu"==activation?this.rreluSlope=.001*Math.random():"elu"==activation&&(this.eluAlpha=eluAlpha)}getWeight(i){return this.weights[i]}setWeight(i,v){this.weights[i]=v}getDeltaWeight(i){return this.deltaWeights[i]}setDeltaWeight(i,v){this.deltaWeights[i]=v}}"undefined"!=typeof window&&(window.Neuron=Neuron),exports.Neuron=Neuron;class OutputLayer extends FCLayer{constructor(size,{activation:activation,softmax:softmax}={}){super(size,{activation:activation}),softmax&&(this.softmax=!0)}forward(){if(super.forward(),this.softmax){const softmax=NetMath.softmax(this.neurons.map(n=>n.activation));for(let s=0;s<softmax.length;s++)this.neurons[s].activation=softmax[s]}}}"undefined"!=typeof window&&(window.OutputLayer=OutputLayer),exports.OutputLayer=OutputLayer;class PoolLayer{constructor(size,{stride:stride,activation:activation}={}){size&&(this.size=size),stride&&(this.stride=stride),this.activation=void 0!=activation&&0!=activation&&("function"==typeof activation?activation:NetMath[NetUtil.format(activation)].bind(this))}init(){}assignNext(layer){this.nextLayer=layer}assignPrev(layer,layerIndex){this.prevLayer=layer,this.size=this.size||this.net.pool.size||2,this.stride=this.stride||this.net.pool.stride||this.size,this.layerIndex=layerIndex;let prevLayerOutWidth=layer.outMapSize;switch(layer.constructor.name){case"FCLayer":this.channels=this.net.channels,prevLayerOutWidth=Math.max(Math.floor(Math.sqrt(layer.size/this.channels)),1);break;case"ConvLayer":this.channels=layer.size;break;case"PoolLayer":this.channels=layer.channels}if(this.prevLayerOutWidth=prevLayerOutWidth,this.outMapSize=(prevLayerOutWidth-this.size)/this.stride+1,this.inMapValuesCount=prevLayerOutWidth**2,this.outMapSize%1!=0)throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${this.outMapSize} in pool layer at index ${layerIndex}`);this.activations=[...new Array(this.channels)].map(channel=>[...new Array(this.outMapSize)].map(row=>[...new Array(this.outMapSize)].map(v=>0))),this.errors=[...new Array(this.channels)].map(channel=>[...new Array(prevLayerOutWidth)].map(row=>[...new Array(prevLayerOutWidth)].map(v=>0))),this.indeces=this.activations.map(channel=>channel.map(row=>row.map(v=>[0,0])))}forward(){for(let channel=0;channel<this.channels;channel++)if(NetMath.maxPool(this,channel),this.activation)for(let row=0;row<this.outMapSize;row++)for(let col=0;col<this.outMapSize;col++)this.activations[channel][row][col]=this.activation(this.activations[channel][row][col],!1,this.net)}backward(){for(let channel=0;channel<this.channels;channel++)for(let row=0;row<this.errors[0].length;row++)for(let col=0;col<this.errors[0].length;col++)this.errors[channel][row][col]=0;if(this.nextLayer instanceof FCLayer)for(let channel=0;channel<this.channels;channel++)for(let row=0;row<this.outMapSize;row++)for(let col=0;col<this.outMapSize;col++){const rowI=this.indeces[channel][row][col][0]+row*this.stride,colI=this.indeces[channel][row][col][1]+col*this.stride,weightIndex=channel*this.outMapSize**2+row*this.outMapSize+col;for(let neuron=0;neuron<this.nextLayer.neurons.length;neuron++)this.errors[channel][rowI][colI]+=this.nextLayer.neurons[neuron].error*this.nextLayer.neurons[neuron].weights[weightIndex]}else if(this.nextLayer instanceof ConvLayer)for(let channel=0;channel<this.channels;channel++){const errs=[];for(let col=0;col<this.outMapSize;col++)errs[col]=0;NetUtil.buildConvErrorMap(this.nextLayer,errs,channel);for(let row=0;row<this.outMapSize;row++)for(let col=0;col<this.outMapSize;col++){const rowI=this.indeces[channel][row][col][0]+row*this.stride,colI=this.indeces[channel][row][col][1]+col*this.stride;this.errors[channel][rowI][colI]+=errs[row][col]}}else for(let channel=0;channel<this.channels;channel++)for(let row=0;row<this.outMapSize;row++)for(let col=0;col<this.outMapSize;col++){const rowI=this.indeces[channel][row][col][0]+row*this.stride,colI=this.indeces[channel][row][col][1]+col*this.stride;this.errors[channel][rowI][colI]+=this.nextLayer.errors[channel][row][col]}if(this.activation)for(let channel=0;channel<this.channels;channel++)for(let row=0;row<this.indeces[channel].length;row++)for(let col=0;col<this.indeces[channel].length;col++){const rowI=this.indeces[channel][row][col][0]+row*this.stride,colI=this.indeces[channel][row][col][1]+col*this.stride;this.errors[channel][rowI][colI]*=this.activation(this.errors[channel][rowI][colI],!0,this.net)}}resetDeltaWeights(){}applyDeltaWeights(){}backUpValidation(){}restoreValidation(){}toJSON(){return{}}fromJSON(){}getDataSize(){return 0}toIMG(){return[]}fromIMG(){}}"undefined"!=typeof window&&(window.PoolLayer=PoolLayer),exports.PoolLayer=PoolLayer;
//# sourceMappingURL=jsNetJS.min.js.map