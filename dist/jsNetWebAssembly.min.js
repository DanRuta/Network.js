"use strict";class ConvLayer{}"undefined"==typeof window&&(exports.ConvLayer=ConvLayer);class FCLayer{constructor(size){this.size=size,this.neurons=[...new Array(size)].map(n=>new Neuron),this.layerIndex=0}assignNext(layer){this.nextLayer=layer}assignPrev(netInstance,layer,layerIndex){this.netInstance=netInstance,this.prevLayer=layer,this.layerIndex=layerIndex}init(){this.neurons.forEach((neuron,ni)=>{switch(!0){case this.prevLayer instanceof FCLayer:neuron.size=this.prevLayer.size}neuron.init(this.netInstance,this.layerIndex,ni)})}toJSON(){return{weights:this.neurons.map(neuron=>({bias:neuron.bias,weights:neuron.weights}))}}fromJSON(data,layerIndex){this.neurons.forEach((neuron,ni)=>{if(data.weights[ni].weights.length!=neuron.weights.length)throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`);neuron.bias=data.weights[ni].bias,neuron.weights=data.weights[ni].weights})}}const Layer=FCLayer;"undefined"==typeof window&&(exports.FCLayer=exports.Layer=FCLayer);class NetMath{static softmax(values){let total=0;for(let i=0;i<values.length;i++)total+=values[i];for(let i=0;i<values.length;i++)total&&(values[i]/=total);return values}}"undefined"==typeof window&&(exports.NetMath=NetMath);class NetUtil{static ccallArrays(func,returnType,paramTypes,params,{heapIn:heapIn="HEAPF32",heapOut:heapOut="HEAPF32",returnArraySize:returnArraySize=1}={}){const heapMap={};heapMap.HEAP8=Int8Array,heapMap.HEAPU8=Uint8Array,heapMap.HEAP16=Int16Array,heapMap.HEAPU16=Uint16Array,heapMap.HEAP32=Int32Array,heapMap.HEAPU32=Uint32Array,heapMap.HEAPF32=Float32Array,heapMap.HEAPF64=Float64Array;let res,error;paramTypes=paramTypes||[];const returnTypeParam="array"==returnType?"number":returnType,parameters=[],parameterTypes=[],bufs=[];try{if(params)for(let p=0;p<params.length;p++)if("array"==paramTypes[p]||Array.isArray(params[p])){const typedArray=new heapMap[heapIn](params[p].length);for(let i=0;i<params[p].length;i++)typedArray[i]=params[p][i];const buf=NetUtil.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);switch(heapIn){case"HEAP8":case"HEAPU8":NetUtil.Module[heapIn].set(typedArray,buf);break;case"HEAP16":case"HEAPU16":NetUtil.Module[heapIn].set(typedArray,buf>>1);break;case"HEAP32":case"HEAPU32":case"HEAPF32":NetUtil.Module[heapIn].set(typedArray,buf>>2);break;case"HEAPF64":NetUtil.Module[heapIn].set(typedArray,buf>>3)}bufs.push(buf),parameters.push(buf),parameters.push(params[p].length),parameterTypes.push("number"),parameterTypes.push("number")}else parameters.push(params[p]),parameterTypes.push(void 0==paramTypes[p]?"number":paramTypes[p]);res=NetUtil.Module.ccall(func,returnTypeParam,parameterTypes,parameters)}catch(e){error=e}finally{for(let b=0;b<bufs.length;b++)NetUtil.Module._free(bufs[b])}if(error)throw error;if("array"==returnType){const returnData=[];for(let v=0;v<returnArraySize;v++)returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v]);return returnData}return res}static format(value,type="string"){switch(!0){case"string"==type&&"string"==typeof value:value=value.replace(/(_|\s)/g,"").toLowerCase();break;case"time"==type&&"number"==typeof value:const date=new Date(value),formatted=[];value<1e3?formatted.push(`${date.getMilliseconds()}ms`):value<6e4?formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`):(value>=36e5&&formatted.push(`${date.getHours()}h`),formatted.push(`${date.getMinutes()}m`),formatted.push(`${date.getSeconds()}s`)),value=formatted.join(" ")}return value}}"undefined"==typeof window&&(exports.NetUtil=NetUtil);class Network{constructor({Module:Module,learningRate:learningRate=.2,activation:activation="sigmoid",cost:cost="meansquarederror",layers:layers=[]}){if(!Module)throw new Error("WASM module not provided");if("function"==typeof activation||"function"==typeof cost)throw new Error("Custom functions are not (yet) supported with WASM.");this.Module=Module,NetUtil.Module=Module,this.netInstance=this.Module.ccall("newNetwork",null,null,null),this.state="not-defined",Object.defineProperty(this,"learningRate",{get:this.Module.cwrap("getLearningRate",null,null).bind(this,this.netInstance),set:this.Module.cwrap("setLearningRate","number",null).bind(this,this.netInstance)}),this.learningRate=learningRate;const activationsIndeces={sigmoid:0,relu:1};let activationName=NetUtil.format(activation);Object.defineProperty(this,"activation",{get:()=>`WASM ${activationName}`,set:activation=>{if(void 0==activationsIndeces[activation])throw new Error(`The ${activation} function does not exist`);activationName=activation,this.Module.ccall("setActivation",null,["number","number"],[this.netInstance,activationsIndeces[activation]])}}),this.activation=activationName;const costFunctionsIndeces={meansquarederror:0,crossentropy:1};let costFunctionName=NetUtil.format(cost);if(Object.defineProperty(this,"cost",{get:()=>`WASM ${costFunctionName}`,set:cost=>{if(void 0==costFunctionsIndeces[cost])throw new Error(`The ${cost} function does not exist`);costFunctionName=cost,this.Module.ccall("setCostFunction",null,["number","number"],[this.netInstance,costFunctionsIndeces[cost]])}}),this.cost=costFunctionName,this.layers=[],this.epochs=0,this.iterations=0,layers.length)switch(this.state="constructed",!0){case layers.every(item=>Number.isInteger(item)):this.layers=layers.map(size=>new FCLayer(size)),this.initLayers();break;case layers.every(layer=>layer instanceof FCLayer||layer instanceof ConvLayer||layer instanceof PoolLayer):this.layers=layers,this.initLayers();break;default:throw new Error("There was an error constructing from the layers given.")}}initLayers(input,expected){if("initialised"!=this.state){"not-defined"==this.state&&(this.layers[0]=new FCLayer(input),this.layers[1]=new FCLayer(Math.ceil(input/expected>5?expected+Math.abs(input-expected)/4:input+expected)),this.layers[2]=new FCLayer(Math.ceil(expected))),this.state="initialised";for(let l=0;l<this.layers.length;l++){const layer=this.layers[l];layer instanceof FCLayer&&(this.Module.ccall("addFCLayer",null,["number","number"],[this.netInstance,layer.size]),this.joinLayer(layer,l))}this.Module.ccall("initLayers",null,["number"],[this.netInstance])}}joinLayer(layer,layerIndex){layer.layerIndex=layerIndex,layerIndex&&(this.layers[layerIndex-1].assignNext(layer),layer.assignPrev(this.netInstance,this.layers[layerIndex-1],layerIndex),layer.init())}forward(data){if("initialised"!=this.state)throw new Error("The network layers have not been initialised.");if(void 0===data||null===data)throw new Error("No data passed to Network.forward()");return data.length!=this.layers[0].neurons.length&&console.warn("Input data length did not match input layer neurons count."),NetUtil.ccallArrays("forward","array",["number","array"],[this.netInstance,data],{heapOut:"HEAPF64",returnArraySize:this.layers[this.layers.length-1].neurons.length})}train(data,{epochs:epochs=1}={}){return new Promise((resolve,reject)=>{if(void 0===data||null===data)return void reject("No data provided");"initialised"!=this.state&&this.initLayers(data[0].input.length,(data[0].expected||data[0].output).length);const startTime=Date.now(),dimension=data[0].input.length,itemSize=dimension+(data[0].expected||data[0].output).length,itemsCount=itemSize*data.length,typedArray=new Float32Array(itemsCount);for(let di=0;di<data.length;di++){if(!data[di].hasOwnProperty("input")||!data[di].hasOwnProperty("expected")&&!data[di].hasOwnProperty("output"))return void reject("Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')");let index=itemSize*di;for(let ii=0;ii<data[di].input.length;ii++)typedArray[index]=data[di].input[ii],index++;for(let ei=0;ei<(data[di].expected||data[di].output).length;ei++)typedArray[index]=(data[di].expected||data[di].output)[ei],index++}const buf=this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);this.Module.HEAPF32.set(typedArray,buf>>2);for(let e=0;e<epochs;e++)this.Module.ccall("train","number",["number","number","number","number","number"],[this.netInstance,buf,itemsCount,itemSize,dimension]);this.Module._free(buf);const elapsed=Date.now()-startTime;console.log(`Training finished. Total time: ${NetUtil.format(elapsed,"time")}`),resolve()})}test(data,{log:log=!0}={}){return new Promise((resolve,reject)=>{void 0!==data&&null!==data||reject("No data provided"),log&&console.log("Testing started");const startTime=Date.now(),dimension=data[0].input.length,itemSize=dimension+(data[0].expected||data[0].output).length,itemsCount=itemSize*data.length,typedArray=new Float32Array(itemsCount);for(let di=0;di<data.length;di++){let index=itemSize*di;for(let ii=0;ii<data[di].input.length;ii++)typedArray[index]=data[di].input[ii],index++;for(let ei=0;ei<(data[di].expected||data[di].output).length;ei++)typedArray[index]=(data[di].expected||data[di].output)[ei],index++}const buf=this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);this.Module.HEAPF32.set(typedArray,buf>>2);const avgError=this.Module.ccall("test","number",["number","number","number","number","number"],[this.netInstance,buf,itemsCount,itemSize,dimension]);this.Module._free(buf);const elapsed=Date.now()-startTime;log&&console.log(`Testing finished. Total time: ${NetUtil.format(elapsed,"time")}  Average iteration time: ${NetUtil.format(elapsed/data.length,"time")}`),resolve(avgError)})}toJSON(){return{layers:this.layers.map(layer=>layer.toJSON())}}fromJSON(data){if(void 0===data||null===data)throw new Error("No JSON data given to import.");if(data.layers.length!=this.layers.length)throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`);this.Module.ccall("resetDeltaWeights",null,["number"],[this.netInstance]),this.layers.forEach((layer,li)=>li&&layer.fromJSON(data.layers[li],li))}static get version(){return"2.1.1"}}"undefined"==typeof window&&(exports.Network=Network);class Neuron{constructor(){}init(netInstance,layerIndex,neuronIndex){Object.defineProperty(this,"weights",{get:()=>NetUtil.ccallArrays("getNeuronWeights","array",["number","number","number"],[netInstance,layerIndex,neuronIndex],{returnArraySize:this.size,heapOut:"HEAPF64"}),set:weights=>NetUtil.ccallArrays("setNeuronWeights",null,["number","number","number","array"],[netInstance,layerIndex,neuronIndex,weights],{heapIn:"HEAPF64"})}),Object.defineProperty(this,"bias",{get:()=>NetUtil.ccallArrays("getNeuronBias","number",["number","number","number"],[netInstance,layerIndex,neuronIndex]),set:value=>NetUtil.ccallArrays("setNeuronBias",null,["number","number","number","number"],[netInstance,layerIndex,neuronIndex,value])}),Object.defineProperty(this,"deltaWeights",{get:()=>NetUtil.ccallArrays("getNeuronDeltaWeights","array",["number","number","number"],[netInstance,layerIndex,neuronIndex],{returnArraySize:this.size,heapOut:"HEAPF64"}),set:deltaWeights=>NetUtil.ccallArrays("setNeuronDeltaWeights",null,["number","number","number","array"],[netInstance,layerIndex,neuronIndex,deltaWeights],{heapIn:"HEAPF64"})})}}"undefined"==typeof window&&(exports.Neuron=Neuron);class PoolLayer{}"undefined"==typeof window&&(exports.PoolLayer=PoolLayer);
//# sourceMappingURL=jsNetWebAssembly.min.js.map