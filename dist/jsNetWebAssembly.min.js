"use strict";class ConvLayer{constructor(size,{filterSize:filterSize,zeroPadding:zeroPadding,stride:stride,activation:activation}={}){filterSize&&(this.filterSize=filterSize),stride&&(this.stride=stride),size&&(this.size=size),this.zeroPadding=zeroPadding}assignNext(layer){this.nextLayer=layer}assignPrev(netInstance,layer,layerIndex){this.netInstance=netInstance,this.prevLayer=layer,this.layerIndex=layerIndex}init(){}toJSON(){return{weights:this.filters.map(filter=>({bias:filter.bias,weights:filter.weights}))}}fromJSON(data,layerIndex){}}"undefined"==typeof window&&(exports.ConvLayer=ConvLayer);class FCLayer{constructor(size){this.size=size,this.neurons=[...new Array(size)].map(n=>new Neuron),this.layerIndex=0}assignNext(layer){this.nextLayer=layer}assignPrev(netInstance,layer,layerIndex){this.netInstance=netInstance,this.prevLayer=layer,this.layerIndex=layerIndex}init(){this.neurons.forEach((neuron,ni)=>{switch(!0){case this.prevLayer instanceof FCLayer:neuron.size=this.prevLayer.size}neuron.init(this.netInstance,this.layerIndex,ni,{updateFn:this.net.updateFn})})}toJSON(){return{weights:this.neurons.map(neuron=>({bias:neuron.bias,weights:neuron.weights}))}}fromJSON(data,layerIndex){this.neurons.forEach((neuron,ni)=>{if(data.weights[ni].weights.length!=neuron.weights.length)throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`);neuron.bias=data.weights[ni].bias,neuron.weights=data.weights[ni].weights})}}const Layer=FCLayer;"undefined"==typeof window&&(exports.FCLayer=exports.Layer=FCLayer);class NetMath{static softmax(values){let total=0;for(let i=0;i<values.length;i++)total+=values[i];for(let i=0;i<values.length;i++)total&&(values[i]/=total);return values}}"undefined"==typeof window&&(exports.NetMath=NetMath);class NetUtil{static ccallArrays(func,returnType,paramTypes,params,{heapIn:heapIn="HEAPF32",heapOut:heapOut="HEAPF32",returnArraySize:returnArraySize=1}={}){const heapMap={};heapMap.HEAP8=Int8Array,heapMap.HEAPU8=Uint8Array,heapMap.HEAP16=Int16Array,heapMap.HEAPU16=Uint16Array,heapMap.HEAP32=Int32Array,heapMap.HEAPU32=Uint32Array,heapMap.HEAPF32=Float32Array,heapMap.HEAPF64=Float64Array;let res,error;paramTypes=paramTypes||[];const returnTypeParam="array"==returnType?"number":returnType,parameters=[],parameterTypes=[],bufs=[];try{if(params)for(let p=0;p<params.length;p++)if("array"==paramTypes[p]||Array.isArray(params[p])){const typedArray=new heapMap[heapIn](params[p].length);for(let i=0;i<params[p].length;i++)typedArray[i]=params[p][i];const buf=NetUtil.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);switch(heapIn){case"HEAP8":case"HEAPU8":NetUtil.Module[heapIn].set(typedArray,buf);break;case"HEAP16":case"HEAPU16":NetUtil.Module[heapIn].set(typedArray,buf>>1);break;case"HEAP32":case"HEAPU32":case"HEAPF32":NetUtil.Module[heapIn].set(typedArray,buf>>2);break;case"HEAPF64":NetUtil.Module[heapIn].set(typedArray,buf>>3)}bufs.push(buf),parameters.push(buf),parameters.push(params[p].length),parameterTypes.push("number"),parameterTypes.push("number")}else parameters.push(params[p]),parameterTypes.push(void 0==paramTypes[p]?"number":paramTypes[p]);res=NetUtil.Module.ccall(func,returnTypeParam,parameterTypes,parameters)}catch(e){error=e}finally{for(let b=0;b<bufs.length;b++)NetUtil.Module._free(bufs[b])}if(error)throw error;if("array"==returnType){const returnData=[];for(let v=0;v<returnArraySize;v++)returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v]);return returnData}return res}static format(value,type="string"){switch(!0){case"string"==type&&"string"==typeof value:value=value.replace(/(_|\s)/g,"").toLowerCase();break;case"time"==type&&"number"==typeof value:const date=new Date(value),formatted=[];value<1e3?formatted.push(`${date.getMilliseconds()}ms`):value<6e4?formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`):(value>=36e5&&formatted.push(`${date.getHours()}h`),formatted.push(`${date.getMinutes()}m`),formatted.push(`${date.getSeconds()}s`)),value=formatted.join(" ")}return value}static defineProperty(self,prop,valTypes=[],values=[],{getCallback:getCallback=(x=>x),setCallback:setCallback=(x=>x)}={}){Object.defineProperty(self,prop,{get:()=>getCallback(this.Module.ccall(`get_${prop}`,"number",valTypes,values)),set:val=>this.Module.ccall(`set_${prop}`,null,valTypes.concat("number"),values.concat(setCallback(val)))})}static defineArrayProperty(self,prop,valTypes,values,returnSize){Object.defineProperty(self,prop,{get:()=>NetUtil.ccallArrays(`get_${prop}`,"array",valTypes,values,{returnArraySize:returnSize,heapOut:"HEAPF64"}),set:value=>NetUtil.ccallArrays(`set_${prop}`,null,valTypes.concat("array"),values.concat([value]),{heapIn:"HEAPF64"})})}}"undefined"==typeof window&&(exports.NetUtil=NetUtil);class Network{constructor({Module:Module,learningRate:learningRate,activation:activation="sigmoid",updateFn:updateFn="vanillaupdatefn",cost:cost="meansquarederror",layers:layers=[],rmsDecay:rmsDecay,rho:rho,lreluSlope:lreluSlope,eluAlpha:eluAlpha,dropout:dropout=1,l2:l2=!0,l1:l1=!0,maxNorm:maxNorm,weightsConfig:weightsConfig}){if(!Module)throw new Error("WASM module not provided");if("function"==typeof activation||"function"==typeof cost)throw new Error("Custom functions are not (yet) supported with WASM.");NetUtil.Module=Module,this.Module=Module,this.netInstance=this.Module.ccall("newNetwork",null,null,null),this.state="not-defined",Object.defineProperty(this,"learningRate",{get:this.Module.cwrap("getLearningRate",null,null).bind(this,this.netInstance),set:this.Module.cwrap("setLearningRate","number",null).bind(this,this.netInstance)}),learningRate&&(this.learningRate=learningRate),NetUtil.defineProperty(this,"dropout",["number"],[this.netInstance]),this.dropout=0==dropout?1:dropout,l2&&(NetUtil.defineProperty(this,"l2",["number"],[this.netInstance]),NetUtil.defineProperty(this,"l2Error",["number"],[this.netInstance]),this.l2="boolean"==typeof l2?.001:l2),l1&&(NetUtil.defineProperty(this,"l1",["number"],[this.netInstance]),NetUtil.defineProperty(this,"l1Error",["number"],[this.netInstance]),this.l1="boolean"==typeof l1?.005:l1),maxNorm&&(NetUtil.defineProperty(this,"maxNorm",["number"],[this.netInstance]),NetUtil.defineProperty(this,"maxNormTotal",["number"],[this.netInstance]),this.maxNorm="boolean"==typeof maxNorm&&maxNorm?1e3:maxNorm),Object.defineProperty(this,"error",{get:()=>Module.ccall("getError","number",["number"],[this.netInstance])});const activationsIndeces={sigmoid:0,tanh:1,lecuntanh:2,relu:3,lrelu:4,rrelu:5,elu:6};let activationName=NetUtil.format(activation);Object.defineProperty(this,"activation",{get:()=>`WASM ${activationName}`,set:activation=>{if(void 0==activationsIndeces[activation])throw new Error(`The ${activation} activation function does not exist`);activationName=activation,this.Module.ccall("setActivation",null,["number","number"],[this.netInstance,activationsIndeces[activation]])}}),this.activation=activationName;const costIndeces={meansquarederror:0,crossentropy:1};let costFunctionName=NetUtil.format(cost);Object.defineProperty(this,"cost",{get:()=>`WASM ${costFunctionName}`,set:cost=>{if(void 0==costIndeces[cost])throw new Error(`The ${cost} function does not exist`);costFunctionName=cost,this.Module.ccall("setCostFunction",null,["number","number"],[this.netInstance,costIndeces[cost]])}}),this.cost=costFunctionName;const updateFnIndeces={vanillaupdatefn:0,gain:1,adagrad:2,rmsprop:3,adam:4,adadelta:5};NetUtil.defineProperty(this,"updateFn",["number"],[this.netInstance],{getCallback:index=>Object.keys(updateFnIndeces).find(key=>updateFnIndeces[key]==index),setCallback:name=>updateFnIndeces[name]}),this.updateFn=NetUtil.format(updateFn);const weightsConfigFns={uniform:0,gaussian:1,xavieruniform:2,xaviernormal:3,lecununiform:4,lecunnormal:5};if(this.weightsConfig={},NetUtil.defineProperty(this.weightsConfig,"distribution",["number"],[this.netInstance],{getCallback:index=>Object.keys(weightsConfigFns).find(key=>weightsConfigFns[key]==Math.round(index)),setCallback:name=>weightsConfigFns[name]}),NetUtil.defineProperty(this.weightsConfig,"limit",["number"],[this.netInstance]),NetUtil.defineProperty(this.weightsConfig,"mean",["number"],[this.netInstance]),NetUtil.defineProperty(this.weightsConfig,"stdDeviation",["number"],[this.netInstance]),this.weightsConfig.distribution="xavieruniform",void 0!=weightsConfig&&weightsConfig.distribution){if("function"==typeof weightsConfig.distribution)throw new Error("Custom weights init functions are not (yet) supported with WASM.");this.weightsConfig.distribution=NetUtil.format(weightsConfig.distribution)}switch(this.weightsConfig.limit=weightsConfig&&void 0!=weightsConfig.limit?weightsConfig.limit:.1,this.weightsConfig.mean=weightsConfig&&void 0!=weightsConfig.mean?weightsConfig.mean:0,this.weightsConfig.stdDeviation=weightsConfig&&void 0!=weightsConfig.stdDeviation?weightsConfig.stdDeviation:.05,NetUtil.format(updateFn)){case"rmsprop":this.learningRate=void 0==this.learningRate?.001:this.learningRate;break;case"adam":this.learningRate=void 0==this.learningRate?.01:this.learningRate;break;case"adadelta":NetUtil.defineProperty(this,"rho",["number"],[this.netInstance]),this.rho=null==rho?.95:rho;break;default:if(void 0==learningRate)switch(activationName){case"relu":case"lrelu":case"rrelu":case"elu":this.learningRate=.01;break;case"tanh":case"lecuntanh":this.learningRate=.001;break;default:this.learningRate=.2}}if("rmsprop"==this.updateFn&&(NetUtil.defineProperty(this,"rmsDecay",["number"],[this.netInstance]),this.rmsDecay=void 0===rmsDecay?.99:rmsDecay),"lrelu"==activationName?(NetUtil.defineProperty(this,"lreluSlope",["number"],[this.netInstance]),this.lreluSlope=void 0==lreluSlope?-5e-4:lreluSlope):"elu"==activationName&&(NetUtil.defineProperty(this,"eluAlpha",["number"],[this.netInstance]),this.eluAlpha=void 0==eluAlpha?1:eluAlpha),this.layers=[],this.epochs=0,this.iterations=0,layers.length)switch(this.state="constructed",!0){case layers.every(item=>Number.isInteger(item)):this.layers=layers.map(size=>new FCLayer(size)),this.initLayers();break;case layers.every(layer=>layer instanceof FCLayer||layer instanceof ConvLayer||layer instanceof PoolLayer):this.layers=layers,this.initLayers();break;default:throw new Error("There was an error constructing from the layers given.")}}initLayers(input,expected){if("initialised"!=this.state){"not-defined"==this.state&&(this.layers[0]=new FCLayer(input),this.layers[1]=new FCLayer(Math.ceil(input/expected>5?expected+Math.abs(input-expected)/4:input+expected)),this.layers[2]=new FCLayer(Math.ceil(expected))),this.state="initialised";for(let l=0;l<this.layers.length;l++){const layer=this.layers[l];layer instanceof FCLayer&&(this.Module.ccall("addFCLayer",null,["number","number"],[this.netInstance,layer.size]),this.joinLayer(layer,l))}this.Module.ccall("initLayers",null,["number"],[this.netInstance])}}joinLayer(layer,layerIndex){layer.net=this,layer.layerIndex=layerIndex,layerIndex&&(this.layers[layerIndex-1].assignNext(layer),layer.assignPrev(this.netInstance,this.layers[layerIndex-1],layerIndex),layer.init())}forward(data){if("initialised"!=this.state)throw new Error("The network layers have not been initialised.");if(void 0===data||null===data)throw new Error("No data passed to Network.forward()");return data.length!=this.layers[0].neurons.length&&console.warn("Input data length did not match input layer neurons count."),NetUtil.ccallArrays("forward","array",["number","array"],[this.netInstance,data],{heapOut:"HEAPF64",returnArraySize:this.layers[this.layers.length-1].neurons.length})}train(data,{epochs:epochs=1,callback:callback,miniBatchSize:miniBatchSize=1,log:log=!0}={}){return miniBatchSize="boolean"==typeof miniBatchSize&&miniBatchSize?data[0].expected.length:miniBatchSize,this.Module.ccall("set_miniBatchSize",null,["number","number"],[this.netInstance,miniBatchSize]),new Promise((resolve,reject)=>{if(void 0===data||null===data)return void reject("No data provided");"initialised"!=this.state&&this.initLayers(data[0].input.length,(data[0].expected||data[0].output).length);const startTime=Date.now(),dimension=data[0].input.length,itemSize=dimension+(data[0].expected||data[0].output).length,itemsCount=itemSize*data.length,typedArray=new Float32Array(itemsCount);log&&console.log(`Training started. Epochs: ${epochs} Batch size: ${miniBatchSize}`);for(let di=0;di<data.length;di++){if(!data[di].hasOwnProperty("input")||!data[di].hasOwnProperty("expected")&&!data[di].hasOwnProperty("output"))return void reject("Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')");let index=itemSize*di;for(let ii=0;ii<data[di].input.length;ii++)typedArray[index]=data[di].input[ii],index++;for(let ei=0;ei<(data[di].expected||data[di].output).length;ei++)typedArray[index]=(data[di].expected||data[di].output)[ei],index++}const buf=this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);this.Module.HEAPF32.set(typedArray,buf>>2);let elapsed;if(this.Module.ccall("loadTrainingData","number",["number","number","number","number","number"],[this.netInstance,buf,itemsCount,itemSize,dimension]),callback){let epochIndex=0,iterationIndex=0;const doEpoch=()=>{this.l2&&(this.l2Error=0),this.l1&&(this.l1Error=0),iterationIndex=0,doIteration()},doIteration=()=>{this.Module.ccall("train","number",["number","number"],[this.netInstance,miniBatchSize,iterationIndex]),callback({iterations:iterationIndex+1,error:this.error,elapsed:Date.now()-startTime,input:data[this.iterations].input}),(iterationIndex+=miniBatchSize)<data.length?setTimeout(doIteration.bind(this),0):(epochIndex++,elapsed=Date.now()-startTime,log&&console.log(`Epoch ${epochIndex} Error: ${this.error}${void 0==this.l2?"":` L2 Error: ${this.l2Error/iterationIndex}`}`,`\nElapsed: ${NetUtil.format(elapsed,"time")} Average Duration: ${NetUtil.format(elapsed/epochIndex,"time")}`),epochIndex<epochs?doEpoch():resolve())};doEpoch()}else{for(let e=0;e<epochs;e++)this.l2&&(this.l2Error=0),this.l1&&(this.l1Error=0),this.Module.ccall("train","number",["number","number"],[this.netInstance,-1,0]),elapsed=Date.now()-startTime,log&&console.log(`Epoch ${e+1} Error: ${this.error}${void 0==this.l2?"":` L2 Error: ${this.l2Error/data.length}`}`,`\nElapsed: ${NetUtil.format(elapsed,"time")} Average Duration: ${NetUtil.format(elapsed/(e+1),"time")}`);this.Module._free(buf),log&&console.log(`Training finished. Total time: ${NetUtil.format(elapsed,"time")}`),resolve()}})}test(data,{log:log=!0}={}){return new Promise((resolve,reject)=>{void 0!==data&&null!==data||reject("No data provided"),log&&console.log("Testing started");const startTime=Date.now(),dimension=data[0].input.length,itemSize=dimension+(data[0].expected||data[0].output).length,itemsCount=itemSize*data.length,typedArray=new Float32Array(itemsCount);for(let di=0;di<data.length;di++){let index=itemSize*di;for(let ii=0;ii<data[di].input.length;ii++)typedArray[index]=data[di].input[ii],index++;for(let ei=0;ei<(data[di].expected||data[di].output).length;ei++)typedArray[index]=(data[di].expected||data[di].output)[ei],index++}const buf=this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT);this.Module.HEAPF32.set(typedArray,buf>>2);const avgError=this.Module.ccall("test","number",["number","number","number","number","number"],[this.netInstance,buf,itemsCount,itemSize,dimension]);this.Module._free(buf);const elapsed=Date.now()-startTime;log&&console.log(`Testing finished. Total time: ${NetUtil.format(elapsed,"time")}  Average iteration time: ${NetUtil.format(elapsed/data.length,"time")}`),resolve(avgError)})}toJSON(){return{layers:this.layers.map(layer=>layer.toJSON())}}fromJSON(data){if(void 0===data||null===data)throw new Error("No JSON data given to import.");if(data.layers.length!=this.layers.length)throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`);this.Module.ccall("resetDeltaWeights",null,["number"],[this.netInstance]),this.layers.forEach((layer,li)=>li&&layer.fromJSON(data.layers[li],li))}static get version(){return"2.1.1"}}"undefined"==typeof window&&(exports.Network=Network);class Neuron{constructor(){}init(netInstance,layerIndex,neuronIndex,{updateFn:updateFn}){switch(NetUtil.defineArrayProperty(this,"weights",["number","number","number"],[netInstance,layerIndex,neuronIndex],this.size),NetUtil.defineProperty(this,"bias",["number","number","number"],[netInstance,layerIndex,neuronIndex]),NetUtil.defineArrayProperty(this,"deltaWeights",["number","number","number"],[netInstance,layerIndex,neuronIndex],this.size),updateFn){case"gain":NetUtil.defineProperty(this,"biasGain",["number","number","number"],[netInstance,layerIndex,neuronIndex]),NetUtil.defineArrayProperty(this,"weightGain",["number","number","number"],[netInstance,layerIndex,neuronIndex],this.size);break;case"adagrad":case"rmsprop":case"adadelta":NetUtil.defineProperty(this,"biasCache",["number","number","number"],[netInstance,layerIndex,neuronIndex]),NetUtil.defineArrayProperty(this,"weightsCache",["number","number","number"],[netInstance,layerIndex,neuronIndex],this.size),"adadelta"==updateFn&&(NetUtil.defineProperty(this,"adadeltaBiasCache",["number","number","number"],[netInstance,layerIndex,neuronIndex]),NetUtil.defineArrayProperty(this,"adadeltaCache",["number","number","number"],[netInstance,layerIndex,neuronIndex],this.size));break;case"adam":NetUtil.defineProperty(this,"m",["number","number","number"],[netInstance,layerIndex,neuronIndex]),NetUtil.defineProperty(this,"v",["number","number","number"],[netInstance,layerIndex,neuronIndex])}}}"undefined"==typeof window&&(exports.Neuron=Neuron);class PoolLayer{}"undefined"==typeof window&&(exports.PoolLayer=PoolLayer);
//# sourceMappingURL=jsNetWebAssembly.min.js.map