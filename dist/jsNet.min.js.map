{"version":3,"sources":["jsNet.min.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","ConvLayer","size","_ref","arguments","filterSize","zeroPadding","stride","activation","this","NetMath","NetUtil","format","bind","state","layer","nextLayer","layerIndex","prevLayer","net","conv","FCLayer","channels","PoolLayer","activations","Math","floor","prevLayerOutWidth","max","sqrt","outMapSize","inMapValuesCount","pow","inZPMapValuesCount","Error","filters","concat","map","f","Filter","_this","forEach","filter","weights","channelWeights","weightsRow","weightsInitFn","weightsConfig","activationMap","row","v","errorMap","dropoutMap","bias","random","init","updateFn","activationConfig","eluAlpha","getActivations","filterI","sumMap","convolve","input","sumY","sumX","dropout","emY","emX","weightIndex","neuronI","neurons","neuron","error","_filterI","buildConvErrorMap","_filterI2","_filter","col","errors","_filterI3","_filter2","_row","_col","buildConvDWeights","channel","deltaWeights","_row2","_col2","l2","l2Error","l1","l1Error","abs","weightUpdateFn","maxNorm","maxNormTotal","deltaBias","data","fi","window","exports","n","Neuron","_this2","weightsCount","constructor","name","_this3","ni","dropped","sum","ai","expected","_this4","derivative","reduce","p","c","wi","miniBatchSize","dwi","Layer","_this5","_ref2","wRow","w","biasGain","weightGains","getWeightGain","_ref3","_ref4","column","setWeightGain","_ref5","_ref6","biasCache","weightsCache","getWeightsCache","_ref7","_ref8","setWeightsCache","_ref9","_ref10","adadeltaBiasCache","adadeltaCache","getAdadeltaCache","_ref11","_ref12","setAdadeltaCache","_ref13","_ref14","m","rreluSlope","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_ref22","prime","val","exp","lreluSlope","sech","tanh","elu","output","vi","log","calculated","desired","index","prev","curr","deltaValue","learningRate","weightI","newVal","min","rmsDecay","mt","iterations","vt","rho","_newVal","_ref23","limit","values","_ref24","mean","stdDeviation","x1","x2","r","_ref25","fanIn","fanOut","gaussian","lecunnormal","_ref26","uniform","lecununiform","_ref27","_ref28","rowStart","colStart","filterRow","filterCol","indeces","total","avg","diffs","multiplier","layers","li","setWeight","getWeight","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","j","x","zP","slice","extraRows","splice","_i2","vol","mapValues","d","_ref29","inputVol","arrayToVolume","outputMap","paddedLength","fSSpread","di","addZeroPadding","inputY","inputX","weightsY","weightsX","outY","outX","paddedRow","nlFilterI","errMap","emXI","channelsCount","deltaDeltaWeights","channelI","inputValues","inputMap","arrayToMap","_weightsY","_weightsX","_weightsY2","_weightsX2","eY","eX","mapStartI","mapSize","returnArr","rowI","colI","_row3","_col3","_row4","_col4","Network","_ref30","_ref30$layers","_ref30$updateFn","_ref30$activation","_ref30$cost","cost","_ref30$dropout","_ref30$l","_ref30$l2","pool","epochs","includes","distribution","every","item","Number","isInteger","initLayers","ceil","joinLayer","assign","assignNext","assignPrev","console","warn","forward","backward","dataSet","_this6","_ref31","_ref31$epochs","callback","_ref31$log","_ref31$miniBatchSize","_ref31$shuffle","shuffle","Promise","resolve","reject","iterationIndex","epochsCounter","startTime","now","doEpoch","doIteration","hasOwnProperty","applyDeltaWeights","resetDeltaWeights","iterationError","elapsed","setTimeout","testSet","_this7","_ref32","_ref32$log","totalError","testInput","toJSON","fromJSON","get","_this8","_ref33","_ref34","_this9","maxPool","_channel","_row5","_col5","_channel2","errs","_col6","_row6","_col7","_rowI","_colI","_channel3","_row7","_col8","_rowI2","_colI2","_channel4","_row8","_col9","_rowI3","_colI3"],"mappings":"AAAA,aAMA,SAASA,mBAAmBC,KAAO,GAAIC,MAAMC,QAAQF,KAAM,CAAE,IAAK,IAAIG,EAAI,EAAGC,KAAOH,MAAMD,IAAIK,QAASF,EAAIH,IAAIK,OAAQF,IAAOC,KAAKD,GAAKH,IAAIG,GAAM,OAAOC,KAAe,OAAOH,MAAMK,KAAKN,KAE1L,SAASO,gBAAgBC,SAAUC,aAAe,KAAMD,oBAAoBC,aAAgB,MAAM,IAAIC,UAAU,qCANhH,IAAIC,eAAiB,WAAc,SAASC,cAAcZ,IAAKG,GAAK,IAAIU,QAAeC,IAAK,EAAUC,IAAK,EAAWC,QAAKC,EAAW,IAAM,IAAK,IAAiCC,GAA7BC,GAAKnB,IAAIoB,OAAOC,cAAmBP,IAAMI,GAAKC,GAAGG,QAAQC,QAAoBV,KAAKW,KAAKN,GAAGO,QAAYtB,GAAKU,KAAKR,SAAWF,GAA3DW,IAAK,IAAoE,MAAOY,KAAOX,IAAK,EAAMC,GAAKU,IAAO,QAAU,KAAWZ,IAAMK,GAAW,QAAGA,GAAW,SAAO,QAAU,GAAIJ,GAAI,MAAMC,IAAQ,OAAOH,KAAQ,OAAO,SAAUb,IAAKG,GAAK,GAAIF,MAAMC,QAAQF,KAAQ,OAAOA,IAAY,GAAIoB,OAAOC,YAAYM,OAAO3B,KAAQ,OAAOY,cAAcZ,IAAKG,GAAa,MAAM,IAAIO,UAAU,4DAEllBkB,aAAe,WAAc,SAASC,iBAAiBC,OAAQC,OAAS,IAAK,IAAI5B,EAAI,EAAGA,EAAI4B,MAAM1B,OAAQF,IAAK,CAAE,IAAI6B,WAAaD,MAAM5B,GAAI6B,WAAWC,WAAaD,WAAWC,aAAc,EAAOD,WAAWE,cAAe,EAAU,UAAWF,aAAYA,WAAWG,UAAW,GAAMR,OAAOS,eAAeN,OAAQE,WAAWK,IAAKL,aAAiB,OAAO,SAAUvB,YAAa6B,WAAYC,aAAiJ,OAA9HD,YAAYT,iBAAiBpB,YAAY+B,UAAWF,YAAiBC,aAAaV,iBAAiBpB,YAAa8B,aAAqB9B,gBAM5hBgC,UAAY,WACZ,SAASA,UAAUC,MACf,IAAIC,KAAOC,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACtEC,WAAaF,KAAKE,WAClBC,YAAcH,KAAKG,YACnBC,OAASJ,KAAKI,OACdC,WAAaL,KAAKK,WAEtBzC,gBAAgB0C,KAAMR,WAElBI,aAAYI,KAAKJ,WAAaA,YAC9BE,SAAQE,KAAKF,OAASA,QACtBL,OAAMO,KAAKP,KAAOA,MAEtBO,KAAKH,YAAcA,iBAED7B,GAAd+B,aAKIC,KAAKD,aAHgB,kBAAdA,aAA4BA,cAGI,mBAAdA,WAA2BA,WAAaE,QAAQC,QAAQC,OAAOJ,aAAaK,KAAKJ,QAIlHA,KAAKK,MAAQ,kBAqQjB,OAlQA1B,aAAaa,YACTJ,IAAK,aACLZ,MAAO,SAAoB8B,OACvBN,KAAKO,UAAYD,SAGrBlB,IAAK,aACLZ,MAAO,SAAoB8B,MAAOE,YAQ9B,OANAR,KAAKS,UAAYH,MAEjBN,KAAKP,KAAOO,KAAKP,MAAQ,EACzBO,KAAKJ,WAAaI,KAAKJ,YAAcI,KAAKU,IAAIC,KAAKf,YAAc,EACjEI,KAAKF,OAASE,KAAKF,QAAUE,KAAKU,IAAIC,KAAKb,QAAU,GAE7C,GACJ,KAAKQ,iBAAiBM,QAClBZ,KAAKa,SAAWb,KAAKU,IAAIG,UAAY,EACrC,MAEJ,KAAKP,iBAAiBd,UAClBQ,KAAKa,SAAWP,MAAMb,KACtB,MAEJ,KAAKa,iBAAiBQ,UAClBd,KAAKa,SAAWP,MAAMS,YAAY3D,YAIlBY,GAApBgC,KAAKH,cACLG,KAAKH,iBAA2C7B,GAA7BgC,KAAKU,IAAIC,KAAKd,YAA2BmB,KAAKC,MAAMjB,KAAKJ,WAAa,GAAKI,KAAKU,IAAIC,KAAKd,aAIhH,IAAIqB,kBAAoBZ,iBAAiBM,QAAUI,KAAKG,IAAIH,KAAKC,MAAMD,KAAKI,KAAKd,MAAMb,KAAOO,KAAKa,WAAY,GAAKP,MAAMe,WAM1H,GAJArB,KAAKsB,iBAAmBN,KAAKO,IAAIL,kBAAmB,GACpDlB,KAAKwB,mBAAqBR,KAAKO,IAAIL,kBAAuC,EAAnBlB,KAAKH,YAAiB,GAC7EG,KAAKqB,YAAcH,kBAAoBlB,KAAKJ,WAAa,EAAII,KAAKH,aAAeG,KAAKF,OAAS,EAE3FE,KAAKqB,WAAa,GAAK,EACvB,MAAM,IAAII,MAAM,wEAA0EzB,KAAKqB,WAAa,2BAA6Bb,YAG7IR,KAAK0B,WAAaC,OAAO7E,mBAAmB,IAAIE,MAAMgD,KAAKP,QAAQmC,IAAI,SAAUC,GAC7E,OAAO,IAAIC,YAInB1C,IAAK,OACLZ,MAAO,WACH,IAAIuD,MAAQ/B,KAEZA,KAAK0B,QAAQM,QAAQ,SAAUC,QAE3BA,OAAOC,WAAaP,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMlB,YAAYe,IAAI,SAAUO,gBACpF,SAAUR,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMnC,cAAcgC,IAAI,SAAUQ,YAC5E,OAAOL,MAAMrB,IAAI2B,cAAcN,MAAMnC,YAAcmC,MAAMtB,UAAUI,UAAY,GAAIkB,MAAMO,mBAIjGL,OAAOM,iBAAmBZ,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMV,cAAcO,IAAI,SAAUY,KAC5F,SAAUb,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMV,cAAcO,IAAI,SAAUa,GAC5E,OAAO,MAGfR,OAAOS,YAAcf,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMV,cAAcO,IAAI,SAAUY,KACvF,SAAUb,OAAO7E,mBAAmB,IAAIE,MAAM+E,MAAMV,cAAcO,IAAI,SAAUa,GAC5E,OAAO,MAGfR,OAAOU,WAAaV,OAAOM,cAAcX,IAAI,SAAUY,KACnD,OAAOA,IAAIZ,IAAI,SAAUa,GACrB,OAAO,MAGfR,OAAOW,KAAuB,GAAhB5B,KAAK6B,SAAiB,GAEpCZ,OAAOa,MACHC,SAAUhB,MAAMrB,IAAIqC,SACpBhD,WAAYgC,MAAMrB,IAAIsC,iBACtBC,SAAUlB,MAAMrB,IAAIuC,gBAKhC7D,IAAK,UACLZ,MAAO,WAIH,IAAK,IAFDuC,YAAcb,QAAQgD,eAAelD,KAAKS,WAErC0C,QAAU,EAAGA,QAAUnD,KAAKP,KAAM0D,UAAW,CAElD,IAAIlB,OAASjC,KAAK0B,QAAQyB,SAE1BlB,OAAOmB,OAASlD,QAAQmD,UACpBC,MAAOvC,YACPlB,YAAaG,KAAKH,YAClBqC,QAASD,OAAOC,QAChBrB,SAAUb,KAAKa,SACff,OAAQE,KAAKF,OACb8C,KAAMX,OAAOW,OAGjB,IAAK,IAAIW,KAAO,EAAGA,KAAOtB,OAAOmB,OAAOhG,OAAQmG,OAC5C,IAAK,IAAIC,KAAO,EAAGA,KAAOvB,OAAOmB,OAAOhG,OAAQoG,OAC1B,YAAdxD,KAAKK,QAAwB4B,OAAOU,WAAWY,MAAMC,MAAQxC,KAAK6B,SAAW7C,KAAKU,IAAI+C,SACtFxB,OAAOM,cAAcgB,MAAMC,MAAQ,EAC5BxD,KAAKD,WACZkC,OAAOM,cAAcgB,MAAMC,MAAQxD,KAAKD,WAAWkC,OAAOmB,OAAOG,MAAMC,OAAO,EAAOvB,SAAWjC,KAAKU,IAAI+C,SAAW,GAEpHxB,OAAOM,cAAcgB,MAAMC,MAAQvB,OAAOmB,OAAOG,MAAMC,UAO3EpE,IAAK,WACLZ,MAAO,WAGH,GAAIwB,KAAKO,qBAAqBK,QAG1B,IAAK,IAAIuC,QAAU,EAAGA,QAAUnD,KAAK0B,QAAQtE,OAAQ+F,UAIjD,IAAK,IAFDlB,OAASjC,KAAK0B,QAAQyB,SAEjBO,IAAM,EAAGA,IAAMzB,OAAOS,SAAStF,OAAQsG,MAC5C,IAAK,IAAIC,IAAM,EAAGA,IAAM1B,OAAOS,SAAStF,OAAQuG,MAI5C,IAAK,IAFDC,YAAcT,QAAUnC,KAAKO,IAAIvB,KAAKqB,WAAY,GAAKqC,IAAMzB,OAAOS,SAAStF,OAASuG,IAEjFE,QAAU,EAAGA,QAAU7D,KAAKO,UAAUuD,QAAQ1G,OAAQyG,UAAW,CAEtE,IAAIE,OAAS/D,KAAKO,UAAUuD,QAAQD,SACpC5B,OAAOS,SAASgB,KAAKC,MAAQI,OAAOC,MAAQD,OAAO7B,QAAQ0B,kBAKxE,GAAI5D,KAAKO,qBAAqBf,UAEjC,IAAK,IAAIyE,SAAW,EAAGA,SAAWjE,KAAK0B,QAAQtE,OAAQ6G,WACnD/D,QAAQgE,kBAAkBlE,KAAKO,UAAWP,KAAK0B,QAAQuC,UAAUvB,SAAUuB,eAI/E,IAAK,IAAIE,UAAY,EAAGA,UAAYnE,KAAK0B,QAAQtE,OAAQ+G,YAIrD,IAAK,IAFDC,QAAUpE,KAAK0B,QAAQyC,WAElB3B,IAAM,EAAGA,IAAM4B,QAAQ1B,SAAStF,OAAQoF,MAC7C,IAAK,IAAI6B,IAAM,EAAGA,IAAMD,QAAQ1B,SAAStF,OAAQiH,MAC7CD,QAAQ1B,SAASF,KAAK6B,KAAOrE,KAAKO,UAAU+D,OAAOH,WAAW3B,KAAK6B,KAOnF,IAAK,IAAIE,UAAY,EAAGA,UAAYvE,KAAK0B,QAAQtE,OAAQmH,YAIrD,IAAK,IAFDC,SAAWxE,KAAK0B,QAAQ6C,WAEnBE,KAAO,EAAGA,KAAOD,SAAS9B,SAAStF,OAAQqH,OAChD,IAAK,IAAIC,KAAO,EAAGA,KAAOF,SAAS9B,SAAS,GAAGtF,OAAQsH,OAE/CF,SAAS7B,WAAW8B,MAAMC,MAC1BF,SAAS9B,SAAS+B,MAAMC,MAAQ,EACzB1E,KAAKD,aACZyE,SAAS9B,SAAS+B,MAAMC,OAAS1E,KAAKD,WAAWyE,SAASpB,OAAOqB,MAAMC,OAAO,EAAMF,WAOpGtE,QAAQyE,kBAAkB3E,SAG9BZ,IAAK,oBACLZ,MAAO,WACH,IAAK,IAAI2E,QAAU,EAAGA,QAAUnD,KAAK0B,QAAQtE,OAAQ+F,UAAW,CAI5D,IAAK,IAFDlB,OAASjC,KAAK0B,QAAQyB,SAEjByB,QAAU,EAAGA,QAAU3C,OAAO4C,aAAazH,OAAQwH,UACxD,IAAK,IAAIpC,IAAM,EAAGA,IAAMP,OAAO4C,aAAa,GAAGzH,OAAQoF,MACnD,IAAK,IAAI6B,IAAM,EAAGA,IAAMpC,OAAO4C,aAAa,GAAG,GAAGzH,OAAQiH,MACtDpC,OAAO4C,aAAaD,SAASpC,KAAK6B,KAAO,EAKrD,IAAK,IAAIS,MAAQ,EAAGA,MAAQ7C,OAAOU,WAAWvF,OAAQ0H,QAClD,IAAK,IAAIC,MAAQ,EAAGA,MAAQ9C,OAAOU,WAAW,GAAGvF,OAAQ2H,QACrD9C,OAAOU,WAAWmC,OAAOC,QAAS,MAMlD3F,IAAK,oBACLZ,MAAO,WACH,IAAK,IAAI2E,QAAU,EAAGA,QAAUnD,KAAK0B,QAAQtE,OAAQ+F,UAAW,CAI5D,IAAK,IAFDlB,OAASjC,KAAK0B,QAAQyB,SAEjByB,QAAU,EAAGA,QAAU3C,OAAO4C,aAAazH,OAAQwH,UACxD,IAAK,IAAIpC,IAAM,EAAGA,IAAMP,OAAO4C,aAAa,GAAGzH,OAAQoF,MACnD,IAAK,IAAI6B,IAAM,EAAGA,IAAMpC,OAAO4C,aAAa,GAAG,GAAGzH,OAAQiH,WAEnCrG,GAAfgC,KAAKU,IAAIsE,KAAiBhF,KAAKU,IAAIuE,SAAW,GAAMjF,KAAKU,IAAIsE,GAAKhE,KAAKO,IAAIU,OAAOC,QAAQ0C,SAASpC,KAAK6B,KAAM,SAC/FrG,GAAfgC,KAAKU,IAAIwE,KAAiBlF,KAAKU,IAAIyE,SAAWnF,KAAKU,IAAIwE,GAAKlE,KAAKoE,IAAInD,OAAOC,QAAQ0C,SAASpC,KAAK6B,OAEtGpC,OAAOC,QAAQ0C,SAASpC,KAAK6B,KAAOrE,KAAKU,IAAI2E,eAAejF,KAAKJ,KAAKU,IAAKuB,OAAOC,QAAQ0C,SAASpC,KAAK6B,KAAMpC,OAAO4C,aAAaD,SAASpC,KAAK6B,KAAMpC,QAAS2C,QAASpC,IAAK6B,aAErJrG,GAApBgC,KAAKU,IAAI4E,UAAsBtF,KAAKU,IAAI6E,cAAgBvE,KAAKO,IAAIU,OAAOC,QAAQ0C,SAASpC,KAAK6B,KAAM,IAKpHpC,OAAOW,KAAO5C,KAAKU,IAAI2E,eAAejF,KAAKJ,KAAKU,IAAKuB,OAAOW,KAAMX,OAAOuD,UAAWvD,cAI5F7C,IAAK,SACLZ,MAAO,WACH,OACI0D,QAASlC,KAAK0B,QAAQE,IAAI,SAAUK,QAChC,OACIW,KAAMX,OAAOW,KACbV,QAASD,OAAOC,eAMhC9C,IAAK,WACLZ,MAAO,SAAkBiH,KAAMjF,YAC3BR,KAAK0B,QAAQM,QAAQ,SAAUC,OAAQyD,IAEnC,GAAID,KAAKvD,QAAQwD,IAAIxD,QAAQ9E,QAAU6E,OAAOC,QAAQ9E,OAClD,MAAM,IAAIqE,MAAM,oCAAsCgE,KAAKvD,QAAQwD,IAAIxD,QAAQ9E,OAAS,cAAgB6E,OAAOC,QAAQ9E,OAAS,gBAAkBoD,WAAa,cAAgBkF,GAAK,KAGxL,GAAID,KAAKvD,QAAQwD,IAAIxD,QAAQ,GAAG9E,QAAU6E,OAAOC,QAAQ,GAAG9E,OACxD,MAAM,IAAIqE,MAAM,mCAAqCgE,KAAKvD,QAAQwD,IAAIxD,QAAQ,GAAG9E,OAAS,cAAgB6E,OAAOC,QAAQ,GAAG9E,OAAS,gBAAkBoD,WAAa,cAAgBkF,GAAK,KAG7LzD,OAAOW,KAAO6C,KAAKvD,QAAQwD,IAAI9C,KAC/BX,OAAOC,QAAUuD,KAAKvD,QAAQwD,IAAIxD,cAKvC1C,aAGM,oBAAVmG,SAA0BC,QAAQpG,UAAYA,WAGrD,IAAIoB,QAAU,WACV,SAASA,QAAQnB,MACbnC,gBAAgB0C,KAAMY,SAEtBZ,KAAKP,KAAOA,KACZO,KAAK8D,WAAanC,OAAO7E,mBAAmB,IAAIE,MAAMyC,QAAQmC,IAAI,SAAUiE,GACxE,OAAO,IAAIC,SAEf9F,KAAKK,MAAQ,kBA2JjB,OAxJA1B,aAAaiC,UACTxB,IAAK,aACLZ,MAAO,SAAoB8B,OACvBN,KAAKO,UAAYD,SAGrBlB,IAAK,aACLZ,MAAO,SAAoB8B,OACvBN,KAAKS,UAAYH,SAGrBlB,IAAK,OACLZ,MAAO,WACH,IAAIuH,OAAS/F,KAEbA,KAAK8D,QAAQ9B,QAAQ,SAAU+B,QAE3B,IAAIiC,kBAAe,EAEnB,OAAQD,OAAOtF,UAAUwF,YAAYC,MACjC,IAAK,UACDF,aAAeD,OAAOtF,UAAUhB,KAChC,MAEJ,IAAK,YACDuG,aAAeD,OAAOtF,UAAUiB,QAAQtE,OAAS4D,KAAKO,IAAIwE,OAAOtF,UAAUY,WAAY,GACvF,MAEJ,IAAK,YACD2E,aAAeD,OAAOtF,UAAUM,YAAY3D,OAAS4D,KAAKO,IAAIwE,OAAOtF,UAAUY,WAAY,GAInG0C,OAAO7B,QAAU6D,OAAOrF,IAAI2B,cAAc2D,aAAcD,OAAOzD,eAC/DyB,OAAOnB,KAAuB,GAAhB5B,KAAK6B,SAAiB,GAEpCkB,OAAOjB,MACHC,SAAUgD,OAAOrF,IAAIqC,SACrBC,iBAAkB+C,OAAOrF,IAAIsC,iBAC7BC,SAAU8C,OAAOrF,IAAIuC,gBAKjC7D,IAAK,UACLZ,MAAO,WACH,IAAI2H,OAASnG,KAEbA,KAAK8D,QAAQ9B,QAAQ,SAAU+B,OAAQqC,IACnC,GAAoB,YAAhBD,OAAO9F,QAAwB0D,OAAOsC,QAAUrF,KAAK6B,SAAWsD,OAAOzF,IAAI+C,SAC3EM,OAAOhE,WAAa,MACjB,CACHgE,OAAOuC,IAAMvC,OAAOnB,KAIpB,IAAK,IAFD7B,YAAcb,QAAQgD,eAAeiD,OAAO1F,WAEvC8F,GAAK,EAAGA,GAAKxF,YAAY3D,OAAQmJ,KACtCxC,OAAOuC,KAAOvF,YAAYwF,IAAMxC,OAAO7B,QAAQqE,IAGnDxC,OAAOhE,WAAaoG,OAAOpG,WAAWgE,OAAOuC,KAAK,EAAOvC,SAAWoC,OAAOzF,IAAI+C,SAAW,SAKtGrE,IAAK,WACLZ,MAAO,SAAkBgI,UACrB,IAAIC,OAASzG,KAEbA,KAAK8D,QAAQ9B,QAAQ,SAAU+B,OAAQqC,IAEnC,GAAIrC,OAAOsC,QACPtC,OAAOC,MAAQ,EACfD,OAAOyB,UAAY,MAChB,MACqB,IAAbgB,SACPzC,OAAOC,MAAQwC,SAASJ,IAAMrC,OAAOhE,YAErCgE,OAAO2C,WAAaD,OAAO1G,WAAWgE,OAAOuC,KAAK,EAAMvC,QACxDA,OAAOC,MAAQD,OAAO2C,WAAaD,OAAOlG,UAAUuD,QAAQlC,IAAI,SAAUiE,GACtE,OAAOA,EAAE7B,OAAyB,EAAhB6B,EAAE3D,QAAQkE,OAC7BO,OAAO,SAAUC,EAAGC,GACnB,OAAOD,EAAIC,GACZ,IAKP,IAAK,IAFD9F,YAAcb,QAAQgD,eAAeuD,OAAOhG,WAEvCqG,GAAK,EAAGA,GAAK/C,OAAO7B,QAAQ9E,OAAQ0J,KACzC/C,OAAOc,aAAaiC,KAAO/C,OAAOC,MAAQjD,YAAY+F,KAAO,IAAML,OAAO/F,IAAIsE,IAAM,IAAMyB,OAAO/F,IAAIwE,IAAM,IAAMuB,OAAO/F,IAAIqG,cAAgBhD,OAAOc,aAAaiC,KAGpK/C,OAAOyB,UAAYzB,OAAOC,YAKtC5E,IAAK,oBACLZ,MAAO,WACH,IAAK,IAAIqH,EAAI,EAAGA,EAAI7F,KAAK8D,QAAQ1G,OAAQyI,IACrC,IAAK,IAAImB,IAAM,EAAGA,IAAMhH,KAAK8D,QAAQ+B,GAAGhB,aAAazH,OAAQ4J,MACzDhH,KAAK8D,QAAQ+B,GAAGhB,aAAamC,KAAO,KAKhD5H,IAAK,oBACLZ,MAAO,WACH,IAAK,IAAIqH,EAAI,EAAGA,EAAI7F,KAAK8D,QAAQ1G,OAAQyI,IAAK,CAI1C,IAAK,IAFD9B,OAAS/D,KAAK8D,QAAQ+B,GAEjBmB,IAAM,EAAGA,IAAMhH,KAAK8D,QAAQ+B,GAAGhB,aAAazH,OAAQ4J,WAEtChJ,GAAfgC,KAAKU,IAAIsE,KAAiBhF,KAAKU,IAAIuE,SAAW,GAAMjF,KAAKU,IAAIsE,GAAKhE,KAAKO,IAAIwC,OAAO7B,QAAQ8E,KAAM,SACjFhJ,GAAfgC,KAAKU,IAAIwE,KAAiBlF,KAAKU,IAAIyE,SAAWnF,KAAKU,IAAIwE,GAAKlE,KAAKoE,IAAIrB,OAAO7B,QAAQ8E,OAExFjD,OAAO7B,QAAQ8E,KAAOhH,KAAKU,IAAI2E,eAAejF,KAAKJ,KAAKU,IAAKqD,OAAO7B,QAAQ8E,KAAMjD,OAAOc,aAAamC,KAAMjD,OAAQiD,YAE5FhJ,GAApBgC,KAAKU,IAAI4E,UAAsBtF,KAAKU,IAAI6E,cAAgBvE,KAAKO,IAAIwC,OAAO7B,QAAQ8E,KAAM,IAG9FjD,OAAOnB,KAAO5C,KAAKU,IAAI2E,eAAejF,KAAKJ,KAAKU,IAAKqD,OAAOnB,KAAMmB,OAAOyB,UAAWzB,cAI5F3E,IAAK,SACLZ,MAAO,WACH,OACI0D,QAASlC,KAAK8D,QAAQlC,IAAI,SAAUmC,QAChC,OACInB,KAAMmB,OAAOnB,KACbV,QAAS6B,OAAO7B,eAMhC9C,IAAK,WACLZ,MAAO,SAAkBiH,KAAMjF,YAC3BR,KAAK8D,QAAQ9B,QAAQ,SAAU+B,OAAQqC,IAEnC,GAAIX,KAAKvD,QAAQkE,IAAIlE,QAAQ9E,QAAU2G,OAAO7B,QAAQ9E,OAClD,MAAM,IAAIqE,MAAM,oCAAsCgE,KAAKvD,QAAQkE,IAAIlE,QAAQ9E,OAAS,cAAgB2G,OAAO7B,QAAQ9E,OAAS,eAAiBoD,WAAa,cAAgB4F,GAAK,KAGvLrC,OAAOnB,KAAO6C,KAAKvD,QAAQkE,IAAIxD,KAC/BmB,OAAO7B,QAAUuD,KAAKvD,QAAQkE,IAAIlE,cAKvCtB,WAGPqG,MAAQrG,QAEK,oBAAV+E,SAA0BC,QAAQhF,QAAUgF,QAAQqB,MAAQrG,SAGnE,IAAIkB,OAAS,WACT,SAASA,SACLxE,gBAAgB0C,KAAM8B,QAkK1B,OA/JAnD,aAAamD,SACT1C,IAAK,OACLZ,MAAO,WACH,IAAI0I,OAASlH,KAETmH,MAAQxH,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACvEoD,SAAWoE,MAAMpE,SACjBhD,WAAaoH,MAAMpH,WACnBkD,SAAWkE,MAAMlE,SAEVjD,KAAKkC,QAAQ9E,OAWxB,OATA4C,KAAK6E,aAAe7E,KAAKkC,QAAQN,IAAI,SAAUgD,SAC3C,OAAOA,QAAQhD,IAAI,SAAUwF,MACzB,OAAOA,KAAKxF,IAAI,SAAUyF,GACtB,OAAO,QAInBrH,KAAKwF,UAAY,EAETzC,UAEJ,IAAK,OACD/C,KAAKsH,SAAW,EAChBtH,KAAKuH,YAAcvH,KAAKkC,QAAQN,IAAI,SAAUgD,SAC1C,OAAOA,QAAQhD,IAAI,SAAUwF,MACzB,OAAOA,KAAKxF,IAAI,SAAUyF,GACtB,OAAO,QAInBrH,KAAKwH,cAAgB,SAAUC,OAC3B,IAAIC,MAAQhK,eAAe+J,MAAO,GAC9B7C,QAAU8C,MAAM,GAChBlF,IAAMkF,MAAM,GACZC,OAASD,MAAM,GAEnB,OAAOR,OAAOK,YAAY3C,SAASpC,KAAKmF,SAE5C3H,KAAK4H,cAAgB,SAAUC,MAAOpF,GAClC,IAAIqF,MAAQpK,eAAemK,MAAO,GAC9BjD,QAAUkD,MAAM,GAChBtF,IAAMsF,MAAM,GACZH,OAASG,MAAM,GAEnB,OAAOZ,OAAOK,YAAY3C,SAASpC,KAAKmF,QAAUlF,GAEtD,MAEJ,IAAK,UACL,IAAK,UACL,IAAK,WACDzC,KAAK+H,UAAY,EACjB/H,KAAKgI,aAAehI,KAAKkC,QAAQN,IAAI,SAAUgD,SAC3C,OAAOA,QAAQhD,IAAI,SAAUwF,MACzB,OAAOA,KAAKxF,IAAI,SAAUyF,GACtB,OAAO,QAInBrH,KAAKiI,gBAAkB,SAAUC,OAC7B,IAAIC,MAAQzK,eAAewK,MAAO,GAC9BtD,QAAUuD,MAAM,GAChB3F,IAAM2F,MAAM,GACZR,OAASQ,MAAM,GAEnB,OAAOjB,OAAOc,aAAapD,SAASpC,KAAKmF,SAE7C3H,KAAKoI,gBAAkB,SAAUC,MAAO5F,GACpC,IAAI6F,OAAS5K,eAAe2K,MAAO,GAC/BzD,QAAU0D,OAAO,GACjB9F,IAAM8F,OAAO,GACbX,OAASW,OAAO,GAEpB,OAAOpB,OAAOc,aAAapD,SAASpC,KAAKmF,QAAUlF,GAGvC,YAAZM,WACA/C,KAAKuI,kBAAoB,EACzBvI,KAAKwI,cAAgBxI,KAAKkC,QAAQN,IAAI,SAAUgD,SAC5C,OAAOA,QAAQhD,IAAI,SAAUwF,MACzB,OAAOA,KAAKxF,IAAI,SAAUyF,GACtB,OAAO,QAInBrH,KAAKyI,iBAAmB,SAAUC,QAC9B,IAAIC,OAASjL,eAAegL,OAAQ,GAChC9D,QAAU+D,OAAO,GACjBnG,IAAMmG,OAAO,GACbhB,OAASgB,OAAO,GAEpB,OAAOzB,OAAOsB,cAAc5D,SAASpC,KAAKmF,SAE9C3H,KAAK4I,iBAAmB,SAAUC,OAAQpG,GACtC,IAAIqG,OAASpL,eAAemL,OAAQ,GAChCjE,QAAUkE,OAAO,GACjBtG,IAAMsG,OAAO,GACbnB,OAASmB,OAAO,GAEpB,OAAO5B,OAAOsB,cAAc5D,SAASpC,KAAKmF,QAAUlF,IAG5D,MAEJ,IAAK,OACDzC,KAAK+I,EAAI,EACT/I,KAAKyC,EAAI,EAGC,SAAd1C,WACAC,KAAKgJ,WAA6B,KAAhBhI,KAAK6B,SACF,OAAd9C,aACPC,KAAKiD,SAAWA,aAIxB7D,IAAK,YACLZ,MAAO,SAAmByK,QACtB,IAAIC,OAASxL,eAAeuL,OAAQ,GAChCrE,QAAUsE,OAAO,GACjB1G,IAAM0G,OAAO,GACbvB,OAASuB,OAAO,GAEpB,OAAOlJ,KAAKkC,QAAQ0C,SAASpC,KAAKmF,WAGtCvI,IAAK,YACLZ,MAAO,SAAmB2K,OAAQ1G,GAC9B,IAAI2G,OAAS1L,eAAeyL,OAAQ,GAChCvE,QAAUwE,OAAO,GACjB5G,IAAM4G,OAAO,GACbzB,OAASyB,OAAO,GAEpBpJ,KAAKkC,QAAQ0C,SAASpC,KAAKmF,QAAUlF,KAGzCrD,IAAK,iBACLZ,MAAO,SAAwB6K,QAC3B,IAAIC,OAAS5L,eAAe2L,OAAQ,GAChCzE,QAAU0E,OAAO,GACjB9G,IAAM8G,OAAO,GACb3B,OAAS2B,OAAO,GAEpB,OAAOtJ,KAAK6E,aAAaD,SAASpC,KAAKmF,WAG3CvI,IAAK,iBACLZ,MAAO,SAAwB+K,OAAQ9G,GACnC,IAAI+G,OAAS9L,eAAe6L,OAAQ,GAChC3E,QAAU4E,OAAO,GACjBhH,IAAMgH,OAAO,GACb7B,OAAS6B,OAAO,GAEpBxJ,KAAK6E,aAAaD,SAASpC,KAAKmF,QAAUlF,MAI3CX,UAGM,oBAAV6D,SAA0BC,QAAQ9D,OAASA,QAIlD,IAAI7B,QAAU,WACV,SAASA,UACL3C,gBAAgB0C,KAAMC,SAkT1B,OA/SAtB,aAAasB,QAAS,OAClBb,IAAK,UAILZ,MAAO,SAAiBA,MAAOiL,OAC3B,IAAIC,IAAM,GAAK,EAAI1I,KAAK2I,KAAKnL,QAC7B,OAAOiL,MAAQC,KAAO,EAAIA,KAAOA,OAGrCtK,IAAK,OACLZ,MAAO,SAAcA,MAAOiL,OACxB,IAAIE,IAAM3I,KAAK2I,IAAI,EAAInL,OACvB,OAAOiL,MAAQ,EAAIzI,KAAKO,IAAIP,KAAK2I,IAAInL,OAASwC,KAAK2I,KAAKnL,OAAQ,IAAM,OAASmL,IAAM,IAAMA,IAAM,IAAM,SAG3GvK,IAAK,OACLZ,MAAO,SAAcA,MAAOiL,OACxB,OAAOA,MAAQjL,MAAQ,EAAI,EAAI,EAAIwC,KAAKG,IAAI3C,MAAO,MAGvDY,IAAK,QACLZ,MAAO,SAAeA,MAAOiL,OACzB,OAAOA,MAAQjL,MAAQ,EAAI,EAAIwB,KAAK4J,aAAe,KAAS5I,KAAKG,KAAKnB,KAAK4J,aAAe,MAAU5I,KAAKoE,IAAI5G,OAAQA,UAGzHY,IAAK,QACLZ,MAAO,SAAeA,MAAOiL,MAAO1F,QAChC,OAAO0F,MAAQjL,MAAQ,EAAI,EAAIuF,OAAOiF,WAAahI,KAAKG,IAAI4C,OAAOiF,WAAYxK,UAGnFY,IAAK,YACLZ,MAAO,SAAmBA,MAAOiL,OAC7B,OAAOA,MAAQ,QAAUzI,KAAKO,IAAItB,QAAQ4J,KAAK,EAAI,EAAIrL,OAAQ,GAAK,OAASyB,QAAQ6J,KAAK,EAAI,EAAItL,UAGtGY,IAAK,MACLZ,MAAO,SAAaA,MAAOiL,MAAO1F,QAC9B,OAAO0F,MAAQjL,OAAS,EAAI,EAAIyB,QAAQ8J,IAAIvL,OAAO,EAAOuF,QAAUA,OAAOd,SAAWzE,OAAS,EAAIA,MAAQuF,OAAOd,UAAYjC,KAAK2I,IAAInL,OAAS,MAMpJY,IAAK,eACLZ,MAAO,SAAsBK,OAAQmL,QACjC,OAAOA,OAAOpI,IAAI,SAAUpD,MAAOyL,IAC/B,OAAOpL,OAAOoL,IAAMjJ,KAAKkJ,IAAI1L,MAAQ,QAAU,EAAIK,OAAOoL,KAAOjJ,KAAKkJ,IAAI,EAAI,MAAQ1L,SACvFmI,OAAO,SAAUC,EAAGC,GACnB,OAAOD,EAAIC,GACZ,MAGPzH,IAAK,mBACLZ,MAAO,SAA0B2L,WAAYC,SACzC,OAAOD,WAAWvI,IAAI,SAAUoI,OAAQK,OACpC,OAAOrJ,KAAKO,IAAIyI,OAASI,QAAQC,OAAQ,KAC1C1D,OAAO,SAAU2D,KAAMC,MACtB,OAAOD,KAAOC,MACf,GAAKJ,WAAW/M,UAMvBgC,IAAK,kBACLZ,MAAO,SAAyBA,MAAOgM,YACnC,OAAOhM,MAAQwB,KAAKyK,aAAeD,cAGvCpL,IAAK,OACLZ,MAAO,SAAcA,MAAOgM,WAAYzG,OAAQ2G,SAE5C,IAAIC,OAASnM,MAAQwB,KAAKyK,aAAeD,YAAyB,MAAXE,QAAkB3G,OAAOuD,SAAWvD,OAAOyD,cAAckD,UAgBhH,OAdIC,QAAU,GAAKnM,MAAQ,GAAKmM,QAAU,GAAKnM,MAAQ,EACpC,MAAXkM,QACA3G,OAAO6D,cAAc8C,QAAS1J,KAAKG,IAAoC,IAAhC4C,OAAOyD,cAAckD,SAAiB,KAE7E3G,OAAOuD,SAAWtG,KAAKG,IAAsB,IAAlB4C,OAAOuD,SAAiB,IAGxC,MAAXoD,QACA3G,OAAO6D,cAAc8C,QAAS1J,KAAK4J,IAAI7G,OAAOyD,cAAckD,SAAW,IAAM,IAE7E3G,OAAOuD,SAAWtG,KAAK4J,IAAI7G,OAAOuD,SAAW,IAAM,GAIpDqD,UAGXvL,IAAK,UACLZ,MAAO,SAAiBA,MAAOgM,WAAYzG,OAAQ2G,SAQ/C,OANe,MAAXA,QACA3G,OAAOqE,gBAAgBsC,QAAS3G,OAAOkE,gBAAgByC,SAAW1J,KAAKO,IAAIiJ,WAAY,IAEvFzG,OAAOgE,WAAa/G,KAAKO,IAAIiJ,WAAY,GAGtChM,MAAQwB,KAAKyK,aAAeD,YAAc,KAAOxJ,KAAKI,KAAgB,MAAXsJ,QAAkB3G,OAAOkE,gBAAgByC,SAAW3G,OAAOgE,eAGjI3I,IAAK,UACLZ,MAAO,SAAiBA,MAAOgM,WAAYzG,OAAQ2G,SAQ/C,OANe,MAAXA,QACA3G,OAAOqE,gBAAgBsC,QAAS1K,KAAK6K,SAAW9G,OAAOkE,gBAAgByC,UAAY,EAAI1K,KAAK6K,UAAY7J,KAAKO,IAAIiJ,WAAY,IAE7HzG,OAAOgE,UAAY/H,KAAK6K,SAAW9G,OAAOgE,WAAa,EAAI/H,KAAK6K,UAAY7J,KAAKO,IAAIiJ,WAAY,GAG9FhM,MAAQwB,KAAKyK,aAAeD,YAAc,KAAOxJ,KAAKI,KAAgB,MAAXsJ,QAAkB3G,OAAOkE,gBAAgByC,SAAW3G,OAAOgE,eAGjI3I,IAAK,OACLZ,MAAO,SAAcA,MAAOgM,WAAYzG,QAEpCA,OAAOgF,EAAI,GAAMhF,OAAOgF,GAAK,EAAI,IAAOyB,WACxC,IAAIM,GAAK/G,OAAOgF,GAAK,EAAI/H,KAAKO,IAAI,GAAKvB,KAAK+K,WAAa,IAEzDhH,OAAOtB,EAAI,KAAQsB,OAAOtB,GAAK,EAAI,MAASzB,KAAKO,IAAIiJ,WAAY,GACjE,IAAIQ,GAAKjH,OAAOtB,GAAK,EAAIzB,KAAKO,IAAI,KAAOvB,KAAK+K,WAAa,IAE3D,OAAOvM,MAAQwB,KAAKyK,aAAeK,IAAM9J,KAAKI,KAAK4J,IAAM,SAG7D5L,IAAK,WACLZ,MAAO,SAAkBA,MAAOgM,WAAYzG,OAAQ2G,SAEhD,GAAe,MAAXA,QAAiB,CACjB3G,OAAOqE,gBAAgBsC,QAAS1K,KAAKiL,IAAMlH,OAAOkE,gBAAgByC,UAAY,EAAI1K,KAAKiL,KAAOjK,KAAKO,IAAIiJ,WAAY,IACnH,IAAIG,OAASnM,MAAQwC,KAAKI,MAAM2C,OAAO0E,iBAAiBiC,SAAW,OAAS3G,OAAOkE,gBAAgByC,SAAW,OAASF,WAEvH,OADAzG,OAAO6E,iBAAiB8B,QAAS1K,KAAKiL,IAAMlH,OAAO0E,iBAAiBiC,UAAY,EAAI1K,KAAKiL,KAAOjK,KAAKO,IAAIiJ,WAAY,IAC9GG,OAEP5G,OAAOgE,UAAY/H,KAAKiL,IAAMlH,OAAOgE,WAAa,EAAI/H,KAAKiL,KAAOjK,KAAKO,IAAIiJ,WAAY,GACvF,IAAIU,QAAU1M,MAAQwC,KAAKI,MAAM2C,OAAOwE,kBAAoB,OAASxE,OAAOgE,UAAY,OAASyC,WAEjG,OADAzG,OAAOwE,kBAAoBvI,KAAKiL,IAAMlH,OAAOwE,mBAAqB,EAAIvI,KAAKiL,KAAOjK,KAAKO,IAAIiJ,WAAY,GAChGU,WAOf9L,IAAK,UACLZ,MAAO,SAAiBiB,KAAM0L,QAK1B,IAAK,IAJDC,MAAQD,OAAOC,MAEfC,UAEKnO,EAAI,EAAGA,EAAIuC,KAAMvC,IACtBmO,OAAO9M,KAAqB,EAAhByC,KAAK6B,SAAeuI,MAAQA,OAG5C,OAAOC,UAGXjM,IAAK,WACLZ,MAAO,SAAkBiB,KAAM6L,QAO3B,IAAK,IANDC,KAAOD,OAAOC,KACdC,aAAeF,OAAOE,aAEtBH,UAGKnO,EAAI,EAAGA,EAAIuC,KAAMvC,IAAK,CAC3B,IAAIuO,QAAK,EACLC,QAAK,EACLC,OAAI,EAGR,GACIF,GAAK,EAAIzK,KAAK6B,SAAW,EACzB6I,GAAK,EAAI1K,KAAK6B,SAAW,EACzB8I,EAAI3K,KAAKO,IAAIkK,GAAI,GAAKzK,KAAKO,IAAImK,GAAI,SAC9BC,GAAK,IAAMA,GAEpBN,OAAO9M,KAAKgN,KAAOE,GAAKzK,KAAKI,MAAM,EAAIJ,KAAKkJ,IAAIyB,GAAKA,GAAKH,cAG9D,OAAOH,UAGXjM,IAAK,eACLZ,MAAO,SAAsBiB,KAAMmM,QAC/B,IAAIC,MAAQD,OAAOC,MACfC,OAASF,OAAOE,OAEpB,OAAOA,QAAoB,GAAVA,OAAc7L,QAAQ8L,SAAStM,MAAQ8L,KAAM,EAAGC,aAAcxK,KAAKI,KAAK,GAAKyK,MAAQC,WAAc7L,QAAQ+L,YAAYvM,MAAQoM,MAAOA,WAG3JzM,IAAK,gBACLZ,MAAO,SAAuBiB,KAAMwM,QAChC,IAAIJ,MAAQI,OAAOJ,MACfC,OAASG,OAAOH,OAEpB,OAAOA,QAAoB,GAAVA,OAAc7L,QAAQiM,QAAQzM,MAAQ2L,MAAOpK,KAAKI,KAAK,GAAKyK,MAAQC,WAAc7L,QAAQkM,aAAa1M,MAAQoM,MAAOA,WAG3IzM,IAAK,cACLZ,MAAO,SAAqBiB,KAAM2M,QAC9B,IAAIP,MAAQO,OAAOP,MAEnB,OAAO5L,QAAQ8L,SAAStM,MAAQ8L,KAAM,EAAGC,aAAcxK,KAAKI,KAAK,EAAIyK,YAGzEzM,IAAK,eACLZ,MAAO,SAAsBiB,KAAM4M,QAC/B,IAAIR,MAAQQ,OAAOR,MAEnB,OAAO5L,QAAQiM,QAAQzM,MAAQ2L,MAAOpK,KAAKI,KAAK,EAAIyK,YAMxDzM,IAAK,UACLZ,MAAO,SAAiB8B,MAAOsE,SAI3B,IAAK,IAFD7D,YAAcb,QAAQgD,eAAe5C,MAAMG,UAAWmE,QAAStE,MAAMgB,kBAEhEkB,IAAM,EAAGA,IAAMlC,MAAMe,WAAYmB,MACtC,IAAK,IAAI6B,IAAM,EAAGA,IAAM/D,MAAMe,WAAYgD,MAAO,CAQ7C,IAAK,IANDiI,SAAW9J,IAAMlC,MAAMR,OACvByM,SAAWlI,IAAM/D,MAAMR,OAGvBC,WAAagB,YAAYuL,SAAWhM,MAAMY,kBAAoBqL,UAEzDC,UAAY,EAAGA,UAAYlM,MAAMb,KAAM+M,YAC5C,IAAK,IAAIC,UAAY,EAAGA,UAAYnM,MAAMb,KAAMgN,YAAa,CAEzD,IAAIjO,MAAQuC,aAAauL,SAAWE,WAAalM,MAAMY,mBAAqBqL,SAAWE,YAEnFjO,MAAQuB,aACRA,WAAavB,MACb8B,MAAMoM,QAAQ9H,SAASpC,KAAK6B,MAAQmI,UAAWC,YAK3DnM,MAAMS,YAAY6D,SAASpC,KAAK6B,KAAOtE,eAQnDX,IAAK,UACLZ,MAAO,SAAiB6M,QACpB,IAAIsB,MAAQtB,OAAO1E,OAAO,SAAU2D,KAAMC,MACtC,OAAOD,KAAOC,MACf,GACH,OAAOc,OAAOzJ,IAAI,SAAUpD,OACxB,OAAOA,MAAQmO,WAIvBvN,IAAK,OACLZ,MAAO,SAAcA,OACjB,OAAO,EAAIwC,KAAK2I,KAAKnL,QAAU,EAAIwC,KAAK2I,KAAK,EAAInL,WAGrDY,IAAK,oBACLZ,MAAO,SAA2BzB,KAC9B,IAAI6P,IAAM7P,IAAI4J,OAAO,SAAUC,EAAGC,GAC9B,OAAOD,EAAIC,IACV9J,IAAIK,OACLyP,MAAQ9P,IAAI6E,IAAI,SAAUa,GAC1B,OAAOA,EAAImK,MACZhL,IAAI,SAAUa,GACb,OAAOzB,KAAKO,IAAIkB,EAAG,KAEvB,OAAOzB,KAAKI,KAAKyL,MAAMlG,OAAO,SAAUC,EAAGC,GACvC,OAAOD,EAAIC,IACVgG,MAAMzP,WAGfgC,IAAK,UACLZ,MAAO,WAEH,GAAIwB,KAAKuF,aAAevF,KAAKsF,QAAS,CAElC,IAAIwH,WAAa9M,KAAKsF,SAAW,MAAQtF,KAAKuF,cAE9CvF,KAAK+M,OAAO/K,QAAQ,SAAU1B,MAAO0M,IACjCA,IAAM1M,MAAMwD,QAAQ9B,QAAQ,SAAU+B,QAClCA,OAAO7B,QAAQF,QAAQ,SAAUqF,EAAGP,IAChC,OAAO/C,OAAOkJ,UAAUnG,GAAI/C,OAAOmJ,UAAUpG,IAAMgG,kBAMnE9M,KAAKuF,aAAe,MAIrBtF,WAGM,oBAAV0F,SAA0BC,QAAQ3F,QAAUA,SAGnD,IAAIC,QAAU,WACV,SAASA,UACL5C,gBAAgB0C,KAAME,SAkV1B,OA/UAvB,aAAauB,QAAS,OAClBd,IAAK,SACLZ,MAAO,SAAgBA,OACnB,IAAI2O,KAAOxN,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,GAAK,SAE/E,QAAQ,GAEJ,IAAa,UAARwN,MAAoC,iBAAT3O,MAC5BA,MAAQA,MAAM4O,QAAQ,UAAW,IAAIC,cACrC,MAEJ,IAAa,QAARF,MAAkC,iBAAT3O,MAC1B,IAAI8O,KAAO,IAAIC,KAAK/O,OAChBgP,aAEAhP,MAAQ,IACRgP,UAAUjP,KAAK+O,KAAKG,kBAAoB,MACjCjP,MAAQ,IACfgP,UAAUjP,KAAK+O,KAAKI,aAAe,IAAMJ,KAAKG,kBAAoB,MAG9DjP,OAAS,MAASgP,UAAUjP,KAAK+O,KAAKK,WAAa,KACnDnP,OAAS,KAAOgP,UAAUjP,KAAK+O,KAAKM,aAAe,KAEvDJ,UAAUjP,KAAK+O,KAAKI,aAAe,MAGvClP,MAAQgP,UAAUK,KAAK,KAI/B,OAAOrP,SAGXY,IAAK,UACLZ,MAAO,SAAiBzB,KACpB,IAAK,IAAIG,EAAIH,IAAIK,OAAQF,EAAGA,IAAK,CAC7B,IAAI4Q,EAAI9M,KAAKC,MAAMD,KAAK6B,SAAW3F,GAC/B6Q,EAAIhR,IAAIG,EAAI,GAChBH,IAAIG,EAAI,GAAKH,IAAI+Q,GACjB/Q,IAAI+Q,GAAKC,MAIjB3O,IAAK,iBACLZ,MAAO,SAAwBoD,IAAKoM,IAIhC,IAAK,IAFDvI,QAEKjD,IAAM,EAAGA,IAAMZ,IAAIxE,OAAQoF,MAChCiD,KAAKlH,KAAKqD,IAAIY,KAAKyL,MAAM,IAK7B,IAAK,IAFDC,aAEKhR,EAAI,EAAGA,EAAIuI,KAAKrI,OAAS,EAAI4Q,GAAI9Q,IACtCgR,UAAU3P,KAAK,GAGnB,IAAK,IAAI8F,IAAM,EAAGA,IAAMoB,KAAKrI,OAAQiH,MACjC,IAAK,IAAInG,GAAK,EAAGA,GAAK8P,GAAI9P,KACtBuH,KAAKpB,KAAK8J,OAAO,EAAG,EAAG,GACvB1I,KAAKpB,KAAK8J,OAAO1I,KAAKrI,OAAS,EAAGqI,KAAKrI,OAAQ,GAIvD,IAAK,IAAIgR,IAAM,EAAGA,IAAMJ,GAAII,MACxB3I,KAAK0I,OAAO,EAAG,EAAGD,UAAUD,MAAM,IAClCxI,KAAK0I,OAAO1I,KAAKrI,OAAQqI,KAAKrI,OAAS,EAAG8Q,UAAUD,MAAM,IAG9D,OAAOxI,QAGXrG,IAAK,aACLZ,MAAO,SAAoBzB,IAAK0C,MAG5B,IAAK,IAFDmC,OAEK1E,EAAI,EAAGA,EAAIuC,KAAMvC,IAAK,CAC3B0E,IAAI1E,MAEJ,IAAK,IAAI4Q,EAAI,EAAGA,EAAIrO,KAAMqO,IACtBlM,IAAI1E,GAAG4Q,GAAK/Q,IAAIG,EAAIuC,KAAOqO,GAInC,OAAOlM,OAGXxC,IAAK,gBACLZ,MAAO,SAAuBzB,IAAK8D,UAM/B,IAAK,IAJDwN,OACA5O,KAAOuB,KAAKI,KAAKrE,IAAIK,OAASyD,UAC9ByN,UAAYtN,KAAKO,IAAI9B,KAAM,GAEtB8O,EAAI,EAAGA,EAAIvN,KAAKC,MAAMlE,IAAIK,OAASkR,WAAYC,IAAK,CAIzD,IAAK,IAFD3M,OAEK1E,EAAI,EAAGA,EAAIuC,KAAMvC,IAAK,CAC3B0E,IAAI1E,MAEJ,IAAK,IAAI4Q,EAAI,EAAGA,EAAIrO,KAAMqO,IACtBlM,IAAI1E,GAAG4Q,GAAK/Q,IAAIwR,EAAID,UAAYpR,EAAIuC,KAAOqO,GAInDO,IAAIE,GAAK3M,IAGb,OAAOyM,OAGXjP,IAAK,WACLZ,MAAO,SAAkBgQ,QAgBnB,IAAK,IAfHlL,MAAQkL,OAAOlL,MACfzD,YAAc2O,OAAO3O,YACrBqC,QAAUsM,OAAOtM,QACjBrB,SAAW2N,OAAO3N,SAClBf,OAAS0O,OAAO1O,OAChB8C,KAAO4L,OAAO5L,KAGd6L,SAAWvO,QAAQwO,cAAcpL,MAAOzC,UACxC8N,aAEAC,aAAeH,SAAS,GAAGrR,OAAuB,EAAdyC,YACpCgP,SAAW7N,KAAKC,MAAMiB,QAAQ,GAAG9E,OAAS,GAGnC0R,GAAK,EAAGA,GAAKjO,SAAUiO,KAAM,CACpCL,SAASK,IAAM5O,QAAQ6O,eAAeN,SAASK,IAAKjP,aAElD,IAAK,IAAImP,OAASH,SAAUG,OAASJ,aAAeC,SAAUG,QAAUlP,OAAQ,CAC9E6O,WAAWK,OAASH,UAAY/O,QAAU6O,WAAWK,OAASH,UAAY/O,YAE1E,IAAK,IAAImP,OAASJ,SAAUI,OAASL,aAAeC,SAAUI,QAAUnP,OAAQ,CAG5E,IAAK,IAFDwG,IAAM,EAED4I,SAAW,EAAGA,SAAWhN,QAAQ,GAAG9E,OAAQ8R,WAEjD,IAAK,IAAIC,SAAW,EAAGA,SAAWjN,QAAQ,GAAG9E,OAAQ+R,WACjD7I,KAAOmI,SAASK,IAAIE,QAAUE,SAAWL,WAAWI,QAAUE,SAAWN,WAAa3M,QAAQ4M,IAAII,UAAUC,UAIpHR,WAAWK,OAASH,UAAY/O,SAASmP,OAASJ,UAAY/O,SAAW6O,WAAWK,OAASH,UAAY/O,SAASmP,OAASJ,UAAY/O,SAAW,GAAKwG,MAMnK,IAAK,IAAI8I,KAAO,EAAGA,KAAOT,UAAUvR,OAAQgS,OACxC,IAAK,IAAIC,KAAO,EAAGA,KAAOV,UAAUvR,OAAQiS,OACxCV,UAAUS,MAAMC,OAASzM,KAIjC,OAAO+L,aAGXvP,IAAK,oBACLZ,MAAO,SAA2B+B,UAAWmC,SAAUS,SAUnD,IAAK,IAPDtD,YAAcU,UAAUV,YACxB+O,aAAelM,SAAStF,OAAuB,EAAdyC,YACjCgP,SAAW7N,KAAKC,MAAMV,UAAUX,WAAa,GAG3C0P,aAEG5F,IAAM,EAAGA,IAAMkF,aAAclF,MAClC4F,UAAU/Q,KAAK,GAGnB,IAAK,IAAIiE,IAAM,EAAGA,IAAMoM,aAAcpM,MAClCE,SAASF,KAAO8M,UAAUrB,MAAM,GAIpC,IAAK,IAAIsB,UAAY,EAAGA,UAAYhP,UAAUd,KAAM8P,YAMhD,IAAK,IAJDrN,QAAU3B,UAAUmB,QAAQ6N,WAAWrN,QAAQiB,SAC/CqM,OAASjP,UAAUmB,QAAQ6N,WAAW7M,SAGjCsM,OAASH,SAAUG,OAASJ,aAAeC,SAAUG,QAAUzO,UAAUT,OAC9E,IAAK,IAAImP,OAASJ,SAAUI,OAASL,aAAeC,SAAUI,QAAU1O,UAAUT,OAE9E,IAAK,IAAIoP,SAAW,EAAGA,SAAW3O,UAAUX,WAAYsP,WACpD,IAAK,IAAIC,SAAW,EAAGA,SAAW5O,UAAUX,WAAYuP,WACpDzM,SAASsM,QAAUE,SAAWL,WAAWI,QAAUE,SAAWN,YAAc3M,QAAQgN,UAAUC,UAAYK,QAAQR,OAASH,UAAYtO,UAAUT,SAASmP,OAASJ,UAAYtO,UAAUT,QAQ7M4C,SAASyL,OAAO,EAAGtO,aACnB6C,SAASyL,OAAOzL,SAAStF,OAASyC,YAAa6C,SAAStF,QAGtD,IAAK,IAAIqS,KAAO,EAAGA,KAAO/M,SAAStF,OAAQqS,OACzC/M,SAAS+M,MAAQ/M,SAAS+M,MAAMtB,OAAOtO,YAAa6C,SAAS+M,MAAMrS,OAAuB,EAAdyC,gBAIpFT,IAAK,oBACLZ,MAAO,SAA2B8B,OAU9B,IAAK,IARD0F,aAAe1F,MAAMoB,QAAQ,GAAGQ,QAAQ,GAAG9E,OAC3CyR,SAAW7N,KAAKC,MAAM+E,aAAe,GACrC0J,cAAgBpP,MAAMoB,QAAQ,GAAGQ,QAAQ9E,OAGzCuS,qBAGKT,SAAW,EAAGA,SAAWlJ,aAAckJ,WAAY,CACxDS,kBAAkBT,aAClB,IAAK,IAAIC,SAAW,EAAGA,SAAWnJ,aAAcmJ,WAC5CQ,kBAAkBT,UAAUC,UAAY,EAKhD,IAAK,IAAIhM,QAAU,EAAGA,QAAU7C,MAAMoB,QAAQtE,OAAQ+F,UAAW,CAK7D,IAAK,IAHDlB,OAAS3B,MAAMoB,QAAQyB,SAGlByM,SAAW,EAAGA,SAAWF,cAAeE,WAM3C,IAAK,IAJHC,YAAc3P,QAAQgD,eAAe5C,MAAMG,UAAWmP,SAAUtP,MAAMgB,kBACtEwO,SAAW5P,QAAQ6O,eAAe7O,QAAQ6P,WAAWF,YAAa7O,KAAKI,KAAKd,MAAMgB,mBAAoBhB,MAAMT,aAGrGmP,OAASH,SAAUG,OAASc,SAAS1S,OAASyR,SAAUG,QAAU1O,MAAMR,OAC/E,IAAK,IAAImP,OAASJ,SAAUI,OAASa,SAAS1S,OAASyR,SAAUI,QAAU3O,MAAMR,OAAQ,CAGrF,IAAK,IAAIkQ,UAAY,EAAGA,UAAYhK,aAAcgK,YAC9C,IAAK,IAAIC,UAAY,EAAGA,UAAYjK,aAAciK,YAAa,CAE3D,IAAIlQ,WAAa+P,SAASd,OAASH,SAAWmB,WAAWf,OAASJ,SAAWoB,WAG7EN,kBAAkBK,WAAWC,YAAclQ,YAAc,IAAMO,MAAMI,IAAIsE,IAAM,IAAM1E,MAAMI,IAAIwE,IAAM,IAAM5E,MAAMI,IAAIqG,cAAgB9E,OAAOC,QAAQ0N,UAAUI,WAAWC,YAOjL,IAAK,IAHDjM,MAAQ/B,OAAOS,UAAUsM,OAASH,UAAYvO,MAAMR,SAASmP,OAASJ,UAAYvO,MAAMR,QAGnFoQ,WAAa,EAAGA,WAAalK,aAAckK,aAChD,IAAK,IAAIC,WAAa,EAAGA,WAAanK,aAAcmK,aAChDlO,OAAO4C,aAAa+K,UAAUM,YAAYC,aAAeR,kBAAkBO,YAAYC,YAAcnM,MACrG2L,kBAAkBO,YAAYC,YAAc,EAQhE,IAAK,IAAIC,GAAK,EAAGA,GAAKnO,OAAOS,SAAStF,OAAQgT,KAC1C,IAAK,IAAIC,GAAK,EAAGA,GAAKpO,OAAOS,SAAStF,OAAQiT,KAC1CpO,OAAOuD,WAAavD,OAAOS,SAAS0N,IAAIC,QAMxDjR,IAAK,iBACLZ,MAAO,SAAwB8B,MAAOgQ,UAAWC,SAE7C,IAAIC,aAEJ,GAAwB,GAApB7Q,UAAUvC,OAEV,GAAIkD,iBAAiBM,QAEjB,IAAK,IAAIwF,GAAK,EAAGA,GAAK9F,MAAMwD,QAAQ1G,OAAQgJ,KACxCoK,UAAUjS,KAAK+B,MAAMwD,QAAQsC,IAAIrG,iBAElC,GAAIO,iBAAiBd,UAExB,IAAK,IAAIkG,GAAK,EAAGA,GAAKpF,MAAMoB,QAAQtE,OAAQsI,KACxC,IAAK,IAAI+K,KAAO,EAAGA,KAAOnQ,MAAMoB,QAAQgE,IAAInD,cAAcnF,OAAQqT,OAC9D,IAAK,IAAIC,KAAO,EAAGA,KAAOpQ,MAAMoB,QAAQgE,IAAInD,cAAckO,MAAMrT,OAAQsT,OACpEF,UAAUjS,KAAK+B,MAAMoB,QAAQgE,IAAInD,cAAckO,MAAMC,YAMjE,IAAK,IAAI9L,QAAU,EAAGA,QAAUtE,MAAMS,YAAY3D,OAAQwH,UACtD,IAAK,IAAIpC,IAAM,EAAGA,IAAMlC,MAAMS,YAAY,GAAG3D,OAAQoF,MACjD,IAAK,IAAI6B,IAAM,EAAGA,IAAM/D,MAAMS,YAAY,GAAG3D,OAAQiH,MACjDmM,UAAUjS,KAAK+B,MAAMS,YAAY6D,SAASpC,KAAK6B,WAO/D,GAAI/D,iBAAiBM,QAEjB,IAAK,IAAI1D,EAAIoT,UAAYC,QAASrT,GAAKoT,UAAY,GAAKC,QAASrT,IAC7DsT,UAAUjS,KAAK+B,MAAMwD,QAAQ5G,GAAG6C,iBAEjC,GAAIO,iBAAiBd,UAExB,IAAK,IAAImR,MAAQ,EAAGA,MAAQrQ,MAAMoB,QAAQ4O,WAAW/N,cAAcnF,OAAQuT,QACvE,IAAK,IAAIC,MAAQ,EAAGA,MAAQtQ,MAAMoB,QAAQ4O,WAAW/N,cAAcoO,OAAOvT,OAAQwT,QAC9EJ,UAAUjS,KAAK+B,MAAMoB,QAAQ4O,WAAW/N,cAAcoO,OAAOC,aAKrE,IAAK,IAAIC,MAAQ,EAAGA,MAAQvQ,MAAMS,YAAYuP,WAAWlT,OAAQyT,QAC7D,IAAK,IAAIC,MAAQ,EAAGA,MAAQxQ,MAAMS,YAAYuP,WAAWlT,OAAQ0T,QAC7DN,UAAUjS,KAAK+B,MAAMS,YAAYuP,WAAWO,OAAOC,QAMnE,OAAON,cAIRtQ,WAGM,oBAAVyF,SAA0BC,QAAQ1F,QAAUA,SAGnD,IAAI6Q,QAAU,WACV,SAASA,UACL,IAAIC,OAASrR,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACxE8K,aAAeuG,OAAOvG,aACtBwG,cAAgBD,OAAOjE,OACvBA,YAA2B/O,IAAlBiT,iBAAmCA,cAC5CC,gBAAkBF,OAAOjO,SACzBA,cAA+B/E,IAApBkT,gBAAgC,kBAAoBA,gBAC/DC,kBAAoBH,OAAOjR,WAC3BA,gBAAmC/B,IAAtBmT,kBAAkC,UAAYA,kBAC3DC,YAAcJ,OAAOK,KACrBA,UAAuBrT,IAAhBoT,YAA4B,mBAAqBA,YACxDvG,SAAWmG,OAAOnG,SAClBI,IAAM+F,OAAO/F,IACbrB,WAAaoH,OAAOpH,WACpB3G,SAAW+N,OAAO/N,SAClBqO,eAAiBN,OAAOvN,QACxBA,aAA6BzF,IAAnBsT,eAA+B,EAAIA,eAC7CC,SAAWP,OAAOhM,GAClBA,QAAkBhH,IAAbuT,UAAgCA,SACrCC,UAAYR,OAAO9L,GACnBA,QAAmBlH,IAAdwT,WAAiCA,UACtClM,QAAU0L,OAAO1L,QACjBhD,cAAgB0O,OAAO1O,cACvBzB,SAAWmQ,OAAOnQ,SAClBF,KAAOqQ,OAAOrQ,KACd8Q,KAAOT,OAAOS,KA8ClB,OA5CAnU,gBAAgB0C,KAAM+Q,SAEtB/Q,KAAKK,MAAQ,cACbL,KAAK+M,UACL/M,KAAKW,QACLX,KAAKyR,QACLzR,KAAK0R,OAAS,EACd1R,KAAK+K,WAAa,EAClB/K,KAAKyD,QAAqB,GAAXA,QAAmB,EAAIA,QACtCzD,KAAKgE,MAAQ,EACbjE,WAAaG,QAAQC,OAAOJ,YAC5BgD,SAAW7C,QAAQC,OAAO4C,UAC1BsO,KAAOnR,QAAQC,OAAOkR,MAElBrM,KACAhF,KAAKgF,GAAkB,kBAANA,GAAkB,KAAQA,GAC3ChF,KAAKiF,QAAU,GAGfC,KACAlF,KAAKkF,GAAkB,kBAANA,GAAkB,KAAQA,GAC3ClF,KAAKmF,QAAU,GAGfG,UACAtF,KAAKsF,QAA4B,kBAAXA,SAAwBA,QAAU,IAAOA,QAC/DtF,KAAKuF,aAAe,GAGpBkF,eAAczK,KAAKyK,aAAeA,cAClC5J,WAAUb,KAAKa,SAAWA,UAE1BF,YACuB3C,GAAnB2C,KAAKf,aAAyBI,KAAKW,KAAKf,WAAae,KAAKf,iBACtC5B,GAApB2C,KAAKd,cAA0BG,KAAKW,KAAKd,YAAcc,KAAKd,kBAC7C7B,GAAf2C,KAAKb,SAAqBE,KAAKW,KAAKb,OAASa,KAAKb,SAGtD2R,OACIA,KAAKhS,OAAMO,KAAKyR,KAAKhS,KAAOgS,KAAKhS,MACjCgS,KAAK3R,SAAQE,KAAKyR,KAAK3R,OAAS2R,KAAK3R,SAIrCiD,UAEJ,IAAK,UACD/C,KAAKyK,kBAAoCzM,GAArBgC,KAAKyK,aAA4B,KAAQzK,KAAKyK,aAClE,MAEJ,IAAK,OACDzK,KAAKyK,kBAAoCzM,GAArBgC,KAAKyK,aAA4B,IAAOzK,KAAKyK,aACjE,MAEJ,IAAK,WACDzK,KAAKiL,IAAa,MAAPA,IAAc,IAAOA,IAChC,MAEJ,QAEI,QAAyBjN,GAArBgC,KAAKyK,aAEL,OAAQ1K,YAEJ,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,MACDC,KAAKyK,aAAe,IACpB,MAEJ,IAAK,OACL,IAAK,YACDzK,KAAKyK,aAAe,KACpB,MAEJ,QACIzK,KAAKyK,aAAe,IAuCxC,GAlCAzK,KAAK+C,WAAY,EAAO,UAAM/E,GAAW2T,SAAS5O,UAAY,kBAAoBA,SAClF/C,KAAKqF,eAAiBpF,QAAQD,KAAK+C,UACnC/C,KAAKD,WAAkC,mBAAdA,WAA2BA,WAAaE,QAAQF,YAAYK,KAAKJ,MAC1FA,KAAKgD,iBAAmBjD,WACxBC,KAAKqR,KAAsB,mBAARA,KAAqBA,KAAOpR,QAAQoR,MAElC,WAAjBrR,KAAK+C,WACL/C,KAAK6K,cAAuB7M,GAAZ6M,SAAwB,IAAOA,UAGnD7K,KAAK4J,gBAA2B5L,GAAd4L,YAA2B,KAASA,WACtD5J,KAAKiD,cAAuBjF,GAAZiF,SAAwB,EAAIA,SAG5CjD,KAAKsC,eAAkBsP,aAAc,sBAEhB5T,GAAjBsE,eAA8BA,cAAcsP,eAC5C5R,KAAKsC,cAAcsP,aAAe1R,QAAQC,OAAOmC,cAAcsP,eAG5B,WAAnC5R,KAAKsC,cAAcsP,aACnB5R,KAAKsC,cAAc8I,MAAQ9I,oBAAwCtE,GAAvBsE,cAAc8I,MAAqB9I,cAAc8I,MAAQ,GAC3D,YAAnCpL,KAAKsC,cAAcsP,eAC1B5R,KAAKsC,cAAciJ,KAAOjJ,cAAciJ,MAAQ,EAChDvL,KAAKsC,cAAckJ,aAAelJ,cAAckJ,cAAgB,KAGtB,mBAAnCxL,KAAKsC,cAAcsP,aAC1B5R,KAAKqC,cAAgBrC,KAAKsC,cAAcsP,aAExC5R,KAAKqC,cAAgBpC,QAAQD,KAAKsC,cAAcsP,cAIhD7E,OAAO3P,OAEP,QAAQ,GAEJ,KAAK2P,OAAO8E,MAAM,SAAUC,MACxB,OAAOC,OAAOC,UAAUF,QAExB9R,KAAK+M,OAASA,OAAOnL,IAAI,SAAUnC,MAC/B,OAAO,IAAImB,QAAQnB,QAEvBO,KAAKK,MAAQ,cACbL,KAAKiS,aACL,MAEJ,KAAKlF,OAAO8E,MAAM,SAAUvR,OACxB,OAAOA,iBAAiBM,SAAWN,iBAAiBd,WAAac,iBAAiBQ,YAElFd,KAAKK,MAAQ,cACbL,KAAK+M,OAASA,OACd/M,KAAKiS,aACL,MAEJ,QACI,MAAM,IAAIxQ,MAAM,2DA0ThC,OArTA9C,aAAaoS,UACT3R,IAAK,aACLZ,MAAO,SAAoB8E,MAAOkD,UAE9B,OAAQxG,KAAKK,OAET,IAAK,cACD,OAEJ,IAAK,cACDL,KAAK+M,OAAO,GAAK,IAAInM,QAAQ0C,OAC7BtD,KAAK+M,OAAO,GAAK,IAAInM,QAAQI,KAAKkR,KAAK5O,MAAQkD,SAAW,EAAIA,SAAWxF,KAAKoE,IAAI9B,MAAQkD,UAAY,EAAIlD,MAAQkD,WAClHxG,KAAK+M,OAAO,GAAK,IAAInM,QAAQI,KAAKkR,KAAK1L,WAI/CxG,KAAK+M,OAAO/K,QAAQhC,KAAKmS,UAAU/R,KAAKJ,OACxCA,KAAKK,MAAQ,iBAGjBjB,IAAK,YACLZ,MAAO,SAAmB8B,MAAOE,YAE7BF,MAAMI,IAAMV,KACZM,MAAMP,gBAAiC/B,GAApBsC,MAAMP,WAA0BC,KAAKD,WAAaO,MAAMP,WAE3EO,MAAMgC,iBACN5D,OAAO0T,OAAO9R,MAAMgC,cAAetC,KAAKsC,eAEpC9B,aACAR,KAAK+M,OAAOvM,WAAa,GAAG6R,WAAW/R,OACvCA,MAAMgS,WAAWtS,KAAK+M,OAAOvM,WAAa,GAAIA,YAE9CF,MAAMgC,cAAcuJ,MAAQvL,MAAMG,UAAUhB,KAC5Ca,MAAMG,UAAU6B,cAAcwJ,OAASxL,MAAMb,KAE7Ca,MAAMwC,OACNxC,MAAMD,MAAQ,kBAItBjB,IAAK,UACLZ,MAAO,SAAiBiH,MAEpB,GAAkB,eAAdzF,KAAKK,MACL,MAAM,IAAIoB,MAAM,iDAGpB,QAAazD,IAATyH,MAA+B,OAATA,KACtB,MAAM,IAAIhE,MAAM,uCAapB,OAVIgE,KAAKrI,QAAU4C,KAAK+M,OAAO,GAAGjJ,QAAQ1G,QACtCmV,QAAQC,KAAK,8DAGjBxS,KAAK+M,OAAO,GAAGjJ,QAAQ9B,QAAQ,SAAU+B,OAAQqC,IAC7C,OAAOrC,OAAOhE,WAAa0F,KAAKW,MAEpCpG,KAAK+M,OAAO/K,QAAQ,SAAU1B,MAAO0M,IACjC,OAAOA,IAAM1M,MAAMmS,QAAQhN,QAExBzF,KAAK+M,OAAO/M,KAAK+M,OAAO3P,OAAS,GAAG0G,QAAQlC,IAAI,SAAUiE,GAC7D,OAAOA,EAAE9F,gBAIjBX,IAAK,WACLZ,MAAO,SAAkBgI,UAErB,QAAiBxI,IAAbwI,SACA,MAAM,IAAI/E,MAAM,wCAGhB+E,SAASpJ,QAAU4C,KAAK+M,OAAO/M,KAAK+M,OAAO3P,OAAS,GAAG0G,QAAQ1G,QAC/DmV,QAAQC,KAAK,iEAAkEhM,UAGnFxG,KAAK+M,OAAO/M,KAAK+M,OAAO3P,OAAS,GAAGsV,SAASlM,UAE7C,IAAK,IAAIhG,WAAaR,KAAK+M,OAAO3P,OAAS,EAAGoD,WAAa,EAAGA,aAC1DR,KAAK+M,OAAOvM,YAAYkS,cAIhCtT,IAAK,QACLZ,MAAO,SAAemU,SAClB,IAAIC,OAAS5S,KAET6S,OAASlT,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACxEmT,cAAgBD,OAAOnB,OACvBA,YAA2B1T,IAAlB8U,cAA8B,EAAIA,cAC3CC,SAAWF,OAAOE,SAClBC,WAAaH,OAAO3I,IACpBA,SAAqBlM,IAAfgV,YAAkCA,WACxCC,qBAAuBJ,OAAO9L,cAC9BA,mBAAyC/I,IAAzBiV,qBAAqC,EAAIA,qBACzDC,eAAiBL,OAAOM,QACxBA,aAA6BnV,IAAnBkV,gBAAuCA,eAIrD,OAFAlT,KAAK+G,cAAwC,kBAAjBA,eAA8BA,cAAgB4L,QAAQ,GAAGnM,SAASpJ,OAAS2J,cAEhG,IAAIqM,QAAQ,SAAUC,QAASC,QAUlC,GARIH,SACAjT,QAAQiT,QAAQR,SAGhBzI,KACAqI,QAAQrI,IAAI,6BAA+BwH,OAAS,gBAAkBkB,OAAO7L,oBAGjE/I,IAAZ2U,SAAqC,OAAZA,QAA7B,CAIoB,eAAhBC,OAAOvS,OACPuS,OAAOX,WAAWU,QAAQ,GAAGrP,MAAMlG,QAASuV,QAAQ,GAAGnM,UAAYmM,QAAQ,GAAG3I,QAAQ5M,QAG1FwV,OAAO7F,OAAO/K,QAAQ,SAAU1B,OAC5B,OAAOA,MAAMD,MAAQ,aAGzB,IAAIkT,eAAiB,EACjBC,cAAgB,EAChBC,UAAYlG,KAAKmG,MAEjBC,QAAU,WACVf,OAAOlB,SACPkB,OAAO5O,MAAQ,EACfuP,eAAiB,OAEKvV,GAAlB4U,OAAO3N,UAAsB2N,OAAO3N,QAAU,QAC5BjH,GAAlB4U,OAAOzN,UAAsByN,OAAOzN,QAAU,GAElDyO,eAGAA,YAAc,SAASA,cAEvB,GAAKjB,QAAQY,gBAAgBM,eAAe,WAAalB,QAAQY,gBAAgBM,eAAe,aAAgBlB,QAAQY,gBAAgBM,eAAe,WAAvJ,CAIA,IAAIvQ,MAAQqP,QAAQY,gBAAgBjQ,MAChC0G,OAAS4I,OAAOH,QAAQnP,OACxBzE,OAAS8T,QAAQY,gBAAgB/M,UAAYmM,QAAQY,gBAAgBvJ,OAEzE4I,OAAOF,SAAS7T,UAEV0U,eAAiBX,OAAO7L,eAAiB,GAC3C6L,OAAOkB,oBACPlB,OAAOmB,qBACAR,gBAAkBZ,QAAQvV,QACjCwV,OAAOkB,oBAGX,IAAIE,eAAiBpB,OAAOvB,KAAKxS,OAAQmL,QACrCiK,QAAU1G,KAAKmG,MAAQD,UAC3Bb,OAAO5O,OAASgQ,eAChBpB,OAAO7H,aAEgB,mBAAZgI,UACPA,UACIhI,WAAY6H,OAAO7H,WACnB/G,MAAOgQ,eACPC,QAASA,QAAS3Q,MAAOA,QAI7BiQ,eAAiBZ,QAAQvV,OACzB8W,WAAWN,YAAYxT,KAAKwS,QAAS,IAErCY,gBAEItJ,KACAqI,QAAQrI,IAAI,UAAY0I,OAAOlB,OAAS,WAAakB,OAAO5O,MAAQuP,qBAA+BvV,GAAb4U,OAAO5N,GAAkB,GAAK,cAAgB4N,OAAO3N,QAAUsO,gBAAiB,cAAgBrT,QAAQC,OAAO8T,QAAS,QAAU,sBAAwB/T,QAAQC,OAAO8T,QAAUT,cAAe,SAGxRA,cAAgB9B,OAChBiC,WAEAf,OAAO7F,OAAO/K,QAAQ,SAAU1B,OAC5B,OAAOA,MAAMD,MAAQ,gBAGrB6J,KACAqI,QAAQrI,IAAI,kCAAoChK,QAAQC,OAAO8T,QAAS,QAAU,6BAA+B/T,QAAQC,OAAO8T,QAAUV,eAAgB,SAE9JF,iBAhDQC,OAAO,uFAqD3BV,OAAOmB,oBACPJ,eAnFgBL,OAAO,yBAuF/BlU,IAAK,OACLZ,MAAO,SAAc2V,SACjB,IAAIC,OAASpU,KAETqU,OAAS1U,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACxE2U,WAAaD,OAAOnK,IACpBA,SAAqBlM,IAAfsW,YAAkCA,WACxCvB,SAAWsB,OAAOtB,SAEtB,OAAO,IAAIK,QAAQ,SAAUC,QAASC,aAElBtV,IAAZmW,SAAqC,OAAZA,SACzBb,OAAO,oBAGPpJ,KACAqI,QAAQrI,IAAI,mBAGhB,IAAIqK,WAAa,EACbhB,eAAiB,EACjBE,UAAYlG,KAAKmG,OAEL,SAASc,YAErB,IAAIlR,MAAQ6Q,QAAQZ,gBAAgBjQ,MAChC0G,OAASoK,OAAO3B,QAAQnP,OACxBzE,OAASsV,QAAQZ,gBAAgB/M,UAAY2N,QAAQZ,gBAAgBvJ,OACrEiK,QAAU1G,KAAKmG,MAAQD,UAEvBO,eAAiBI,OAAO/C,KAAKxS,OAAQmL,QACzCuK,YAAcP,eACdT,iBAEuB,mBAAZR,UACPA,UACIhI,WAAYwI,eACZvP,MAAOgQ,eACPC,QAASA,QAAS3Q,MAAOA,QAI7BiQ,eAAiBY,QAAQ/W,OACzB8W,WAAWM,UAAUpU,KAAKgU,QAAS,IAG/BlK,KACAqI,QAAQrI,IAAI,iCAAmChK,QAAQC,OAAO8T,QAAS,QAAU,6BAA+B/T,QAAQC,OAAO8T,QAAUV,eAAgB,SAG7JF,QAAQkB,WAAaJ,QAAQ/W,iBAO7CgC,IAAK,oBACLZ,MAAO,WACHwB,KAAK+M,OAAO/K,QAAQ,SAAU1B,MAAO0M,IACjC,OAAOA,IAAM1M,MAAMyT,yBAI3B3U,IAAK,oBACLZ,MAAO,WAEHwB,KAAK+M,OAAO/K,QAAQ,SAAU1B,MAAO0M,IACjC,OAAOA,IAAM1M,MAAMwT,2BAGH9V,GAAhBgC,KAAKsF,UACLtF,KAAKuF,aAAevE,KAAKI,KAAKpB,KAAKuF,cACnCtF,QAAQqF,QAAQlF,KAAKJ,YAI7BZ,IAAK,SACLZ,MAAO,WACH,OACIuO,OAAQ/M,KAAK+M,OAAOnL,IAAI,SAAUtB,OAC9B,OAAOA,MAAMmU,eAKzBrV,IAAK,WACLZ,MAAO,SAAkBiH,MAErB,QAAazH,IAATyH,MAA+B,OAATA,KACtB,MAAM,IAAIhE,MAAM,iCAGpB,GAAIgE,KAAKsH,OAAO3P,QAAU4C,KAAK+M,OAAO3P,OAClC,MAAM,IAAIqE,MAAM,sBAAwBgE,KAAKsH,OAAO3P,OAAS,+BAAiC4C,KAAK+M,OAAO3P,OAAS,gBAGvH4C,KAAK+T,oBACL/T,KAAK+M,OAAO/K,QAAQ,SAAU1B,MAAO0M,IACjC,OAAOA,IAAM1M,MAAMoU,SAASjP,KAAKsH,OAAOC,IAAKA,WAIrD5N,IAAK,UACLuV,IAAK,WACD,MAAO,YAIR5D,WAGM,oBAAVpL,SAA0BC,QAAQmL,QAAUA,SAGnD,IAAIjL,OAAS,WACT,SAASA,SACLxI,gBAAgB0C,KAAM8F,QA+F1B,OA5FAnH,aAAamH,SACT1G,IAAK,OACLZ,MAAO,WACH,IAAIoW,OAAS5U,KAET6U,OAASlV,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACxEoD,SAAW8R,OAAO9R,SAClBhD,WAAa8U,OAAO9U,WACpBkD,SAAW4R,OAAO5R,SAElBxD,KAAOO,KAAKkC,QAAQ9E,OAKxB,OAJA4C,KAAK6E,aAAe7E,KAAKkC,QAAQN,IAAI,SAAUa,GAC3C,OAAO,IAGHM,UAEJ,IAAK,OACD/C,KAAKsH,SAAW,EAChBtH,KAAKuH,eAAiB5F,OAAO7E,mBAAmB,IAAIE,MAAMyC,QAAQmC,IAAI,SAAUa,GAC5E,OAAO,IAEXzC,KAAKwH,cAAgB,SAAUtK,GAC3B,OAAO0X,OAAOrN,YAAYrK,IAE9B8C,KAAK4H,cAAgB,SAAU1K,EAAGuF,GAC9B,OAAOmS,OAAOrN,YAAYrK,GAAKuF,GAEnC,MAEJ,IAAK,UACL,IAAK,UACL,IAAK,WACDzC,KAAK+H,UAAY,EACjB/H,KAAKgI,gBAAkBrG,OAAO7E,mBAAmB,IAAIE,MAAMyC,QAAQmC,IAAI,SAAUa,GAC7E,OAAO,IAEXzC,KAAKiI,gBAAkB,SAAU/K,GAC7B,OAAO0X,OAAO5M,aAAa9K,IAE/B8C,KAAKoI,gBAAkB,SAAUlL,EAAGuF,GAChC,OAAOmS,OAAO5M,aAAa9K,GAAKuF,GAGpB,YAAZM,WACA/C,KAAKuI,kBAAoB,EACzBvI,KAAKwI,iBAAmB7G,OAAO7E,mBAAmB,IAAIE,MAAMyC,QAAQmC,IAAI,SAAUa,GAC9E,OAAO,IAEXzC,KAAKyI,iBAAmB,SAAUvL,GAC9B,OAAO0X,OAAOpM,cAActL,IAEhC8C,KAAK4I,iBAAmB,SAAU1L,EAAGuF,GACjC,OAAOmS,OAAOpM,cAActL,GAAKuF,IAGzC,MAEJ,IAAK,OACDzC,KAAK+I,EAAI,EACT/I,KAAKyC,EAAI,EAIC,SAAd1C,WACAC,KAAKgJ,WAA6B,KAAhBhI,KAAK6B,SACF,OAAd9C,aACPC,KAAKiD,SAAWA,aAIxB7D,IAAK,YACLZ,MAAO,SAAmBtB,GACtB,OAAO8C,KAAKkC,QAAQhF,MAGxBkC,IAAK,YACLZ,MAAO,SAAmBtB,EAAGuF,GACzBzC,KAAKkC,QAAQhF,GAAKuF,KAGtBrD,IAAK,iBACLZ,MAAO,SAAwBtB,GAC3B,OAAO8C,KAAK6E,aAAa3H,MAG7BkC,IAAK,iBACLZ,MAAO,SAAwBtB,EAAGuF,GAC9BzC,KAAK6E,aAAa3H,GAAKuF,MAIxBqD,UAGM,oBAAVH,SAA0BC,QAAQE,OAASA,QAGlD,IAAIhF,UAAY,WACZ,SAASA,UAAUrB,MACf,IAAIqV,OAASnV,UAAUvC,OAAS,QAAsBY,IAAjB2B,UAAU,GAAmBA,UAAU,MACxEG,OAASgV,OAAOhV,OAChBC,WAAa+U,OAAO/U,WAExBzC,gBAAgB0C,KAAMc,WAElBrB,OAAMO,KAAKP,KAAOA,MAClBK,SAAQE,KAAKF,OAASA,QAGtBE,KAAKD,gBADS/B,GAAd+B,YAAyC,GAAdA,aACY,mBAAdA,WAA2BA,WAAaE,QAAQC,QAAQC,OAAOJ,aAAaK,KAAKJ,OA6LlH,OAvLArB,aAAamC,YACT1B,IAAK,OACLZ,MAAO,eAEPY,IAAK,aACLZ,MAAO,SAAoB8B,OACvBN,KAAKO,UAAYD,SAGrBlB,IAAK,aACLZ,MAAO,SAAoB8B,MAAOE,YAC9B,IAAIuU,OAAS/U,KAEbA,KAAKS,UAAYH,MACjBN,KAAKP,KAAOO,KAAKP,MAAQO,KAAKU,IAAI+Q,KAAKhS,MAAQ,EAC/CO,KAAKF,OAASE,KAAKF,QAAUE,KAAKU,IAAI+Q,KAAK3R,QAAUE,KAAKP,KAE1D,IAAIyB,kBAAoBZ,MAAMe,WAE9B,OAAQf,MAAM2F,YAAYC,MAEtB,IAAK,UACDlG,KAAKa,SAAWb,KAAKU,IAAIG,SACzBK,kBAAoBF,KAAKG,IAAIH,KAAKC,MAAMD,KAAKI,KAAKd,MAAMb,KAAOO,KAAKa,WAAY,GAChF,MAEJ,IAAK,YACDb,KAAKa,SAAWP,MAAMb,KACtB,MAEJ,IAAK,YACDO,KAAKa,SAAWP,MAAMO,SAQ9B,GAJAb,KAAKkB,kBAAoBA,kBACzBlB,KAAKqB,YAAcH,kBAAoBlB,KAAKP,MAAQO,KAAKF,OAAS,EAClEE,KAAKsB,iBAAmBN,KAAKO,IAAIL,kBAAmB,GAEhDlB,KAAKqB,WAAa,GAAK,EACvB,MAAM,IAAII,MAAM,wEAA0EzB,KAAKqB,WAAa,2BAA6Bb,YAG7IR,KAAKe,eAAiBY,OAAO7E,mBAAmB,IAAIE,MAAMgD,KAAKa,YAAYe,IAAI,SAAUgD,SACrF,SAAUjD,OAAO7E,mBAAmB,IAAIE,MAAM+X,OAAO1T,cAAcO,IAAI,SAAUY,KAC7E,SAAUb,OAAO7E,mBAAmB,IAAIE,MAAM+X,OAAO1T,cAAcO,IAAI,SAAUa,GAC7E,OAAO,QAInBzC,KAAKsE,UAAY3C,OAAO7E,mBAAmB,IAAIE,MAAMgD,KAAKa,YAAYe,IAAI,SAAUgD,SAChF,SAAUjD,OAAO7E,mBAAmB,IAAIE,MAAMkE,qBAAqBU,IAAI,SAAUY,KAC7E,SAAUb,OAAO7E,mBAAmB,IAAIE,MAAMkE,qBAAqBU,IAAI,SAAUa,GAC7E,OAAO,QAInBzC,KAAK0M,QAAU1M,KAAKe,YAAYa,IAAI,SAAUgD,SAC1C,OAAOA,QAAQhD,IAAI,SAAUY,KACzB,OAAOA,IAAIZ,IAAI,SAAUa,GACrB,OAAQ,EAAG,YAM3BrD,IAAK,UACLZ,MAAO,WACH,IAAK,IAAIoG,QAAU,EAAGA,QAAU5E,KAAKa,SAAU+D,UAKzC,GAHF3E,QAAQ+U,QAAQhV,KAAM4E,SAGhB5E,KAAKD,WACP,IAAK,IAAIyC,IAAM,EAAGA,IAAMxC,KAAKqB,WAAYmB,MACrC,IAAK,IAAI6B,IAAM,EAAGA,IAAMrE,KAAKqB,WAAYgD,MACrCrE,KAAKe,YAAY6D,SAASpC,KAAK6B,KAAOrE,KAAKD,WAAWC,KAAKe,YAAY6D,SAASpC,KAAK6B,MAAM,EAAOrE,KAAKU,QAO3HtB,IAAK,WACLZ,MAAO,WAGH,IAAK,IAAIoG,QAAU,EAAGA,QAAU5E,KAAKa,SAAU+D,UAC3C,IAAK,IAAIpC,IAAM,EAAGA,IAAMxC,KAAKsE,OAAO,GAAGlH,OAAQoF,MAC3C,IAAK,IAAI6B,IAAM,EAAGA,IAAMrE,KAAKsE,OAAO,GAAGlH,OAAQiH,MAC3CrE,KAAKsE,OAAOM,SAASpC,KAAK6B,KAAO,EAK7C,GAAIrE,KAAKO,qBAAqBK,QAE1B,IAAK,IAAIqU,SAAW,EAAGA,SAAWjV,KAAKa,SAAUoU,WAC7C,IAAK,IAAIC,MAAQ,EAAGA,MAAQlV,KAAKqB,WAAY6T,QACzC,IAAK,IAAIC,MAAQ,EAAGA,MAAQnV,KAAKqB,WAAY8T,QAQzC,IAAK,IAND1E,KAAOzQ,KAAK0M,QAAQuI,UAAUC,OAAOC,OAAO,GAAKD,MAAQlV,KAAKF,OAC9D4Q,KAAO1Q,KAAK0M,QAAQuI,UAAUC,OAAOC,OAAO,GAAKA,MAAQnV,KAAKF,OAG9D8D,aAFqB5C,KAAKO,IAAIvB,KAAKqB,WAAY,GAAarB,KAAKqB,WAEnD4T,SAAWjU,KAAKO,IAAIvB,KAAKqB,WAAY,GAAK6T,MAAQlV,KAAKqB,WAAa8T,OAE7EpR,OAAS,EAAGA,OAAS/D,KAAKO,UAAUuD,QAAQ1G,OAAQ2G,SACzD/D,KAAKsE,OAAO2Q,UAAUxE,MAAMC,OAAS1Q,KAAKO,UAAUuD,QAAQC,QAAQC,MAAQhE,KAAKO,UAAUuD,QAAQC,QAAQ7B,QAAQ0B,kBAKhI,GAAI5D,KAAKO,qBAAqBf,UAEjC,IAAK,IAAI4V,UAAY,EAAGA,UAAYpV,KAAKa,SAAUuU,YAAa,CAI5D,IAAK,IAFDC,QAEKC,MAAQ,EAAGA,MAAQtV,KAAKqB,WAAYiU,QACzCD,KAAKC,OAAS,EAIlBpV,QAAQgE,kBAAkBlE,KAAKO,UAAW8U,KAAMD,WAEhD,IAAK,IAAIG,MAAQ,EAAGA,MAAQvV,KAAKqB,WAAYkU,QACzC,IAAK,IAAIC,MAAQ,EAAGA,MAAQxV,KAAKqB,WAAYmU,QAAS,CAElD,IAAIC,MAAQzV,KAAK0M,QAAQ0I,WAAWG,OAAOC,OAAO,GAAKD,MAAQvV,KAAKF,OAChE4V,MAAQ1V,KAAK0M,QAAQ0I,WAAWG,OAAOC,OAAO,GAAKA,MAAQxV,KAAKF,OAEpEE,KAAKsE,OAAO8Q,WAAWK,OAAOC,QAAUL,KAAKE,OAAOC,aAMhE,IAAK,IAAIG,UAAY,EAAGA,UAAY3V,KAAKa,SAAU8U,YAC/C,IAAK,IAAIC,MAAQ,EAAGA,MAAQ5V,KAAKqB,WAAYuU,QACzC,IAAK,IAAIC,MAAQ,EAAGA,MAAQ7V,KAAKqB,WAAYwU,QAAS,CAElD,IAAIC,OAAS9V,KAAK0M,QAAQiJ,WAAWC,OAAOC,OAAO,GAAKD,MAAQ5V,KAAKF,OACjEiW,OAAS/V,KAAK0M,QAAQiJ,WAAWC,OAAOC,OAAO,GAAKA,MAAQ7V,KAAKF,OAErEE,KAAKsE,OAAOqR,WAAWG,QAAQC,SAAW/V,KAAKO,UAAU+D,OAAOqR,WAAWC,OAAOC,OAOlG,GAAI7V,KAAKD,WACL,IAAK,IAAIiW,UAAY,EAAGA,UAAYhW,KAAKa,SAAUmV,YAE/C,IAAK,IAAIC,MAAQ,EAAGA,MAAQjW,KAAK0M,QAAQsJ,WAAW5Y,OAAQ6Y,QACxD,IAAK,IAAIC,MAAQ,EAAGA,MAAQlW,KAAK0M,QAAQsJ,WAAW5Y,OAAQ8Y,QAAS,CAEjE,IAAIC,OAASnW,KAAK0M,QAAQsJ,WAAWC,OAAOC,OAAO,GAAKD,MAAQjW,KAAKF,OACjEsW,OAASpW,KAAK0M,QAAQsJ,WAAWC,OAAOC,OAAO,GAAKA,MAAQlW,KAAKF,OAErEE,KAAKsE,OAAO0R,WAAWG,QAAQC,SAAWpW,KAAKD,WAAWC,KAAKsE,OAAO0R,WAAWG,QAAQC,SAAS,EAAMpW,KAAKU,SAOjItB,IAAK,oBACLZ,MAAO,eAEPY,IAAK,oBACLZ,MAAO,eAEPY,IAAK,SACLZ,MAAO,WACH,YAGJY,IAAK,WACLZ,MAAO,gBAGJsC,aAGM,oBAAV6E,SAA0BC,QAAQ9E,UAAYA","sourcesContent":["\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ConvLayer = function () {\n    function ConvLayer(size) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            filterSize = _ref.filterSize,\n            zeroPadding = _ref.zeroPadding,\n            stride = _ref.stride,\n            activation = _ref.activation;\n\n        _classCallCheck(this, ConvLayer);\n\n        if (filterSize) this.filterSize = filterSize;\n        if (stride) this.stride = stride;\n        if (size) this.size = size;\n\n        this.zeroPadding = zeroPadding;\n\n        if (activation != undefined) {\n\n            if (typeof activation == \"boolean\" && !activation) {\n                this.activation = false;\n            } else {\n                this.activation = typeof activation == \"function\" ? activation : NetMath[NetUtil.format(activation)].bind(this);\n            }\n        }\n\n        this.state = \"not-initialised\";\n    }\n\n    _createClass(ConvLayer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer, layerIndex) {\n\n            this.prevLayer = layer;\n\n            this.size = this.size || 4;\n            this.filterSize = this.filterSize || this.net.conv.filterSize || 3;\n            this.stride = this.stride || this.net.conv.stride || 1;\n\n            switch (true) {\n                case layer instanceof FCLayer:\n                    this.channels = this.net.channels || 1;\n                    break;\n\n                case layer instanceof ConvLayer:\n                    this.channels = layer.size;\n                    break;\n\n                case layer instanceof PoolLayer:\n                    this.channels = layer.activations.length;\n                    break;\n            }\n\n            if (this.zeroPadding == undefined) {\n                this.zeroPadding = this.net.conv.zeroPadding == undefined ? Math.floor(this.filterSize / 2) : this.net.conv.zeroPadding;\n            }\n\n            // Caching calculations\n            var prevLayerOutWidth = layer instanceof FCLayer ? Math.max(Math.floor(Math.sqrt(layer.size / this.channels)), 1) : layer.outMapSize;\n\n            this.inMapValuesCount = Math.pow(prevLayerOutWidth, 2);\n            this.inZPMapValuesCount = Math.pow(prevLayerOutWidth + this.zeroPadding * 2, 2);\n            this.outMapSize = (prevLayerOutWidth - this.filterSize + 2 * this.zeroPadding) / this.stride + 1;\n\n            if (this.outMapSize % 1 != 0) {\n                throw new Error(\"Misconfigured hyperparameters. Activation volume dimensions would be \" + this.outMapSize + \" in conv layer at index \" + layerIndex);\n            }\n\n            this.filters = [].concat(_toConsumableArray(new Array(this.size))).map(function (f) {\n                return new Filter();\n            });\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var _this = this;\n\n            this.filters.forEach(function (filter) {\n\n                filter.weights = [].concat(_toConsumableArray(new Array(_this.channels))).map(function (channelWeights) {\n                    return [].concat(_toConsumableArray(new Array(_this.filterSize))).map(function (weightsRow) {\n                        return _this.net.weightsInitFn(_this.filterSize * (_this.prevLayer.channels || 1), _this.weightsConfig);\n                    });\n                });\n\n                filter.activationMap = [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (v) {\n                        return 0;\n                    });\n                });\n                filter.errorMap = [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (v) {\n                        return 0;\n                    });\n                });\n                filter.dropoutMap = filter.activationMap.map(function (row) {\n                    return row.map(function (v) {\n                        return false;\n                    });\n                });\n                filter.bias = Math.random() * 0.2 - 0.1;\n\n                filter.init({\n                    updateFn: _this.net.updateFn,\n                    activation: _this.net.activationConfig,\n                    eluAlpha: _this.net.eluAlpha\n                });\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward() {\n\n            var activations = NetUtil.getActivations(this.prevLayer);\n\n            for (var filterI = 0; filterI < this.size; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                filter.sumMap = NetUtil.convolve({\n                    input: activations,\n                    zeroPadding: this.zeroPadding,\n                    weights: filter.weights,\n                    channels: this.channels,\n                    stride: this.stride,\n                    bias: filter.bias\n                });\n\n                for (var sumY = 0; sumY < filter.sumMap.length; sumY++) {\n                    for (var sumX = 0; sumX < filter.sumMap.length; sumX++) {\n                        if (this.state == \"training\" && (filter.dropoutMap[sumY][sumX] = Math.random() > this.net.dropout)) {\n                            filter.activationMap[sumY][sumX] = 0;\n                        } else if (this.activation) {\n                            filter.activationMap[sumY][sumX] = this.activation(filter.sumMap[sumY][sumX], false, filter) / (this.net.dropout || 1);\n                        } else {\n                            filter.activationMap[sumY][sumX] = filter.sumMap[sumY][sumX];\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"backward\",\n        value: function backward() {\n\n            // First, get the filters' error maps\n            if (this.nextLayer instanceof FCLayer) {\n\n                // For each filter, build the errorMap from the weighted neuron errors in the next FCLayer corresponding to each value in the activation map\n                for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                    var filter = this.filters[filterI];\n\n                    for (var emY = 0; emY < filter.errorMap.length; emY++) {\n                        for (var emX = 0; emX < filter.errorMap.length; emX++) {\n\n                            var weightIndex = filterI * Math.pow(this.outMapSize, 2) + emY * filter.errorMap.length + emX;\n\n                            for (var neuronI = 0; neuronI < this.nextLayer.neurons.length; neuronI++) {\n\n                                var neuron = this.nextLayer.neurons[neuronI];\n                                filter.errorMap[emY][emX] += neuron.error * neuron.weights[weightIndex];\n                            }\n                        }\n                    }\n                }\n            } else if (this.nextLayer instanceof ConvLayer) {\n\n                for (var _filterI = 0; _filterI < this.filters.length; _filterI++) {\n                    NetUtil.buildConvErrorMap(this.nextLayer, this.filters[_filterI].errorMap, _filterI);\n                }\n            } else {\n\n                for (var _filterI2 = 0; _filterI2 < this.filters.length; _filterI2++) {\n\n                    var _filter = this.filters[_filterI2];\n\n                    for (var row = 0; row < _filter.errorMap.length; row++) {\n                        for (var col = 0; col < _filter.errorMap.length; col++) {\n                            _filter.errorMap[row][col] = this.nextLayer.errors[_filterI2][row][col];\n                        }\n                    }\n                }\n            }\n\n            // Apply derivative to each error value\n            for (var _filterI3 = 0; _filterI3 < this.filters.length; _filterI3++) {\n\n                var _filter2 = this.filters[_filterI3];\n\n                for (var _row = 0; _row < _filter2.errorMap.length; _row++) {\n                    for (var _col = 0; _col < _filter2.errorMap[0].length; _col++) {\n\n                        if (_filter2.dropoutMap[_row][_col]) {\n                            _filter2.errorMap[_row][_col] = 0;\n                        } else if (this.activation) {\n                            _filter2.errorMap[_row][_col] *= this.activation(_filter2.sumMap[_row][_col], true, _filter2);\n                        }\n                    }\n                }\n            }\n\n            // Then use the error map values to build the delta weights\n            NetUtil.buildConvDWeights(this);\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                for (var channel = 0; channel < filter.deltaWeights.length; channel++) {\n                    for (var row = 0; row < filter.deltaWeights[0].length; row++) {\n                        for (var col = 0; col < filter.deltaWeights[0][0].length; col++) {\n                            filter.deltaWeights[channel][row][col] = 0;\n                        }\n                    }\n                }\n\n                for (var _row2 = 0; _row2 < filter.dropoutMap.length; _row2++) {\n                    for (var _col2 = 0; _col2 < filter.dropoutMap[0].length; _col2++) {\n                        filter.dropoutMap[_row2][_col2] = false;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                for (var channel = 0; channel < filter.deltaWeights.length; channel++) {\n                    for (var row = 0; row < filter.deltaWeights[0].length; row++) {\n                        for (var col = 0; col < filter.deltaWeights[0][0].length; col++) {\n\n                            if (this.net.l2 != undefined) this.net.l2Error += 0.5 * this.net.l2 * Math.pow(filter.weights[channel][row][col], 2);\n                            if (this.net.l1 != undefined) this.net.l1Error += this.net.l1 * Math.abs(filter.weights[channel][row][col]);\n\n                            filter.weights[channel][row][col] = this.net.weightUpdateFn.bind(this.net, filter.weights[channel][row][col], filter.deltaWeights[channel][row][col], filter, [channel, row, col])();\n\n                            if (this.net.maxNorm != undefined) this.net.maxNormTotal += Math.pow(filter.weights[channel][row][col], 2);\n                        }\n                    }\n                }\n\n                filter.bias = this.net.weightUpdateFn.bind(this.net, filter.bias, filter.deltaBias, filter)();\n            }\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                weights: this.filters.map(function (filter) {\n                    return {\n                        bias: filter.bias,\n                        weights: filter.weights\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data, layerIndex) {\n            this.filters.forEach(function (filter, fi) {\n\n                if (data.weights[fi].weights.length != filter.weights.length) {\n                    throw new Error(\"Mismatched weights depth. Given: \" + data.weights[fi].weights.length + \" Existing: \" + filter.weights.length + \". At: layers[\" + layerIndex + \"], filters[\" + fi + \"]\");\n                }\n\n                if (data.weights[fi].weights[0].length != filter.weights[0].length) {\n                    throw new Error(\"Mismatched weights size. Given: \" + data.weights[fi].weights[0].length + \" Existing: \" + filter.weights[0].length + \". At: layers[\" + layerIndex + \"], filters[\" + fi + \"]\");\n                }\n\n                filter.bias = data.weights[fi].bias;\n                filter.weights = data.weights[fi].weights;\n            });\n        }\n    }]);\n\n    return ConvLayer;\n}();\n\ntypeof window == \"undefined\" && (exports.ConvLayer = ConvLayer);\n\"use strict\";\n\nvar FCLayer = function () {\n    function FCLayer(size) {\n        _classCallCheck(this, FCLayer);\n\n        this.size = size;\n        this.neurons = [].concat(_toConsumableArray(new Array(size))).map(function (n) {\n            return new Neuron();\n        });\n        this.state = \"not-initialised\";\n    }\n\n    _createClass(FCLayer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer) {\n            this.prevLayer = layer;\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var _this2 = this;\n\n            this.neurons.forEach(function (neuron) {\n\n                var weightsCount = void 0;\n\n                switch (_this2.prevLayer.constructor.name) {\n                    case \"FCLayer\":\n                        weightsCount = _this2.prevLayer.size;\n                        break;\n\n                    case \"ConvLayer\":\n                        weightsCount = _this2.prevLayer.filters.length * Math.pow(_this2.prevLayer.outMapSize, 2);\n                        break;\n\n                    case \"PoolLayer\":\n                        weightsCount = _this2.prevLayer.activations.length * Math.pow(_this2.prevLayer.outMapSize, 2);\n                        break;\n                }\n\n                neuron.weights = _this2.net.weightsInitFn(weightsCount, _this2.weightsConfig);\n                neuron.bias = Math.random() * 0.2 - 0.1;\n\n                neuron.init({\n                    updateFn: _this2.net.updateFn,\n                    activationConfig: _this2.net.activationConfig,\n                    eluAlpha: _this2.net.eluAlpha\n                });\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward() {\n            var _this3 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n                if (_this3.state == \"training\" && (neuron.dropped = Math.random() > _this3.net.dropout)) {\n                    neuron.activation = 0;\n                } else {\n                    neuron.sum = neuron.bias;\n\n                    var activations = NetUtil.getActivations(_this3.prevLayer);\n\n                    for (var ai = 0; ai < activations.length; ai++) {\n                        neuron.sum += activations[ai] * neuron.weights[ai];\n                    }\n\n                    neuron.activation = _this3.activation(neuron.sum, false, neuron) / (_this3.net.dropout || 1);\n                }\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            var _this4 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (neuron.dropped) {\n                    neuron.error = 0;\n                    neuron.deltaBias = 0;\n                } else {\n                    if (typeof expected !== \"undefined\") {\n                        neuron.error = expected[ni] - neuron.activation;\n                    } else {\n                        neuron.derivative = _this4.activation(neuron.sum, true, neuron);\n                        neuron.error = neuron.derivative * _this4.nextLayer.neurons.map(function (n) {\n                            return n.error * (n.weights[ni] | 0);\n                        }).reduce(function (p, c) {\n                            return p + c;\n                        }, 0);\n                    }\n\n                    var activations = NetUtil.getActivations(_this4.prevLayer);\n\n                    for (var wi = 0; wi < neuron.weights.length; wi++) {\n                        neuron.deltaWeights[wi] += neuron.error * activations[wi] * (1 + ((_this4.net.l2 || 0) + (_this4.net.l1 || 0)) / _this4.net.miniBatchSize * neuron.deltaWeights[wi]);\n                    }\n\n                    neuron.deltaBias = neuron.error;\n                }\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            for (var n = 0; n < this.neurons.length; n++) {\n                for (var dwi = 0; dwi < this.neurons[n].deltaWeights.length; dwi++) {\n                    this.neurons[n].deltaWeights[dwi] = 0;\n                }\n            }\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            for (var n = 0; n < this.neurons.length; n++) {\n\n                var neuron = this.neurons[n];\n\n                for (var dwi = 0; dwi < this.neurons[n].deltaWeights.length; dwi++) {\n\n                    if (this.net.l2 != undefined) this.net.l2Error += 0.5 * this.net.l2 * Math.pow(neuron.weights[dwi], 2);\n                    if (this.net.l1 != undefined) this.net.l1Error += this.net.l1 * Math.abs(neuron.weights[dwi]);\n\n                    neuron.weights[dwi] = this.net.weightUpdateFn.bind(this.net, neuron.weights[dwi], neuron.deltaWeights[dwi], neuron, dwi)();\n\n                    if (this.net.maxNorm != undefined) this.net.maxNormTotal += Math.pow(neuron.weights[dwi], 2);\n                }\n\n                neuron.bias = this.net.weightUpdateFn.bind(this.net, neuron.bias, neuron.deltaBias, neuron)();\n            }\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                weights: this.neurons.map(function (neuron) {\n                    return {\n                        bias: neuron.bias,\n                        weights: neuron.weights\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data, layerIndex) {\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (data.weights[ni].weights.length != neuron.weights.length) {\n                    throw new Error(\"Mismatched weights count. Given: \" + data.weights[ni].weights.length + \" Existing: \" + neuron.weights.length + \". At layers[\" + layerIndex + \"], neurons[\" + ni + \"]\");\n                }\n\n                neuron.bias = data.weights[ni].bias;\n                neuron.weights = data.weights[ni].weights;\n            });\n        }\n    }]);\n\n    return FCLayer;\n}();\n\nvar Layer = FCLayer;\n\ntypeof window == \"undefined\" && (exports.FCLayer = exports.Layer = FCLayer);\n\"use strict\";\n\nvar Filter = function () {\n    function Filter() {\n        _classCallCheck(this, Filter);\n    }\n\n    _createClass(Filter, [{\n        key: \"init\",\n        value: function init() {\n            var _this5 = this;\n\n            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                updateFn = _ref2.updateFn,\n                activation = _ref2.activation,\n                eluAlpha = _ref2.eluAlpha;\n\n            var size = this.weights.length;\n\n            this.deltaWeights = this.weights.map(function (channel) {\n                return channel.map(function (wRow) {\n                    return wRow.map(function (w) {\n                        return 0;\n                    });\n                });\n            });\n            this.deltaBias = 0;\n\n            switch (updateFn) {\n\n                case \"gain\":\n                    this.biasGain = 1;\n                    this.weightGains = this.weights.map(function (channel) {\n                        return channel.map(function (wRow) {\n                            return wRow.map(function (w) {\n                                return 1;\n                            });\n                        });\n                    });\n                    this.getWeightGain = function (_ref3) {\n                        var _ref4 = _slicedToArray(_ref3, 3),\n                            channel = _ref4[0],\n                            row = _ref4[1],\n                            column = _ref4[2];\n\n                        return _this5.weightGains[channel][row][column];\n                    };\n                    this.setWeightGain = function (_ref5, v) {\n                        var _ref6 = _slicedToArray(_ref5, 3),\n                            channel = _ref6[0],\n                            row = _ref6[1],\n                            column = _ref6[2];\n\n                        return _this5.weightGains[channel][row][column] = v;\n                    };\n                    break;\n\n                case \"adagrad\":\n                case \"rmsprop\":\n                case \"adadelta\":\n                    this.biasCache = 0;\n                    this.weightsCache = this.weights.map(function (channel) {\n                        return channel.map(function (wRow) {\n                            return wRow.map(function (w) {\n                                return 0;\n                            });\n                        });\n                    });\n                    this.getWeightsCache = function (_ref7) {\n                        var _ref8 = _slicedToArray(_ref7, 3),\n                            channel = _ref8[0],\n                            row = _ref8[1],\n                            column = _ref8[2];\n\n                        return _this5.weightsCache[channel][row][column];\n                    };\n                    this.setWeightsCache = function (_ref9, v) {\n                        var _ref10 = _slicedToArray(_ref9, 3),\n                            channel = _ref10[0],\n                            row = _ref10[1],\n                            column = _ref10[2];\n\n                        return _this5.weightsCache[channel][row][column] = v;\n                    };\n\n                    if (updateFn == \"adadelta\") {\n                        this.adadeltaBiasCache = 0;\n                        this.adadeltaCache = this.weights.map(function (channel) {\n                            return channel.map(function (wRow) {\n                                return wRow.map(function (w) {\n                                    return 0;\n                                });\n                            });\n                        });\n                        this.getAdadeltaCache = function (_ref11) {\n                            var _ref12 = _slicedToArray(_ref11, 3),\n                                channel = _ref12[0],\n                                row = _ref12[1],\n                                column = _ref12[2];\n\n                            return _this5.adadeltaCache[channel][row][column];\n                        };\n                        this.setAdadeltaCache = function (_ref13, v) {\n                            var _ref14 = _slicedToArray(_ref13, 3),\n                                channel = _ref14[0],\n                                row = _ref14[1],\n                                column = _ref14[2];\n\n                            return _this5.adadeltaCache[channel][row][column] = v;\n                        };\n                    }\n                    break;\n\n                case \"adam\":\n                    this.m = 0;\n                    this.v = 0;\n            }\n\n            if (activation == \"rrelu\") {\n                this.rreluSlope = Math.random() * 0.001;\n            } else if (activation == \"elu\") {\n                this.eluAlpha = eluAlpha;\n            }\n        }\n    }, {\n        key: \"getWeight\",\n        value: function getWeight(_ref15) {\n            var _ref16 = _slicedToArray(_ref15, 3),\n                channel = _ref16[0],\n                row = _ref16[1],\n                column = _ref16[2];\n\n            return this.weights[channel][row][column];\n        }\n    }, {\n        key: \"setWeight\",\n        value: function setWeight(_ref17, v) {\n            var _ref18 = _slicedToArray(_ref17, 3),\n                channel = _ref18[0],\n                row = _ref18[1],\n                column = _ref18[2];\n\n            this.weights[channel][row][column] = v;\n        }\n    }, {\n        key: \"getDeltaWeight\",\n        value: function getDeltaWeight(_ref19) {\n            var _ref20 = _slicedToArray(_ref19, 3),\n                channel = _ref20[0],\n                row = _ref20[1],\n                column = _ref20[2];\n\n            return this.deltaWeights[channel][row][column];\n        }\n    }, {\n        key: \"setDeltaWeight\",\n        value: function setDeltaWeight(_ref21, v) {\n            var _ref22 = _slicedToArray(_ref21, 3),\n                channel = _ref22[0],\n                row = _ref22[1],\n                column = _ref22[2];\n\n            this.deltaWeights[channel][row][column] = v;\n        }\n    }]);\n\n    return Filter;\n}();\n\ntypeof window == \"undefined\" && (exports.Filter = Filter);\n\n\"use strict\";\n\nvar NetMath = function () {\n    function NetMath() {\n        _classCallCheck(this, NetMath);\n    }\n\n    _createClass(NetMath, null, [{\n        key: \"sigmoid\",\n\n\n        // Activation functions\n        value: function sigmoid(value, prime) {\n            var val = 1 / (1 + Math.exp(-value));\n            return prime ? val * (1 - val) : val;\n        }\n    }, {\n        key: \"tanh\",\n        value: function tanh(value, prime) {\n            var exp = Math.exp(2 * value);\n            return prime ? 4 / Math.pow(Math.exp(value) + Math.exp(-value), 2) || 1e-18 : (exp - 1) / (exp + 1) || 1e-18;\n        }\n    }, {\n        key: \"relu\",\n        value: function relu(value, prime) {\n            return prime ? value > 0 ? 1 : 0 : Math.max(value, 0);\n        }\n    }, {\n        key: \"lrelu\",\n        value: function lrelu(value, prime) {\n            return prime ? value > 0 ? 1 : this.lreluSlope || -0.0005 : Math.max((this.lreluSlope || -0.0005) * Math.abs(value), value);\n        }\n    }, {\n        key: \"rrelu\",\n        value: function rrelu(value, prime, neuron) {\n            return prime ? value > 0 ? 1 : neuron.rreluSlope : Math.max(neuron.rreluSlope, value);\n        }\n    }, {\n        key: \"lecuntanh\",\n        value: function lecuntanh(value, prime) {\n            return prime ? 1.15333 * Math.pow(NetMath.sech(2 / 3 * value), 2) : 1.7159 * NetMath.tanh(2 / 3 * value);\n        }\n    }, {\n        key: \"elu\",\n        value: function elu(value, prime, neuron) {\n            return prime ? value >= 0 ? 1 : NetMath.elu(value, false, neuron) + neuron.eluAlpha : value >= 0 ? value : neuron.eluAlpha * (Math.exp(value) - 1);\n        }\n\n        // Cost functions\n\n    }, {\n        key: \"crossentropy\",\n        value: function crossentropy(target, output) {\n            return output.map(function (value, vi) {\n                return target[vi] * Math.log(value + 1e-15) + (1 - target[vi]) * Math.log(1 + 1e-15 - value);\n            }).reduce(function (p, c) {\n                return p - c;\n            }, 0);\n        }\n    }, {\n        key: \"meansquarederror\",\n        value: function meansquarederror(calculated, desired) {\n            return calculated.map(function (output, index) {\n                return Math.pow(output - desired[index], 2);\n            }).reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0) / calculated.length;\n        }\n\n        // Weight updating functions\n\n    }, {\n        key: \"vanillaupdatefn\",\n        value: function vanillaupdatefn(value, deltaValue) {\n            return value + this.learningRate * deltaValue;\n        }\n    }, {\n        key: \"gain\",\n        value: function gain(value, deltaValue, neuron, weightI) {\n\n            var newVal = value + this.learningRate * deltaValue * (weightI == null ? neuron.biasGain : neuron.getWeightGain(weightI));\n\n            if (newVal <= 0 && value > 0 || newVal >= 0 && value < 0) {\n                if (weightI != null) {\n                    neuron.setWeightGain(weightI, Math.max(neuron.getWeightGain(weightI) * 0.95, 0.5));\n                } else {\n                    neuron.biasGain = Math.max(neuron.biasGain * 0.95, 0.5);\n                }\n            } else {\n                if (weightI != null) {\n                    neuron.setWeightGain(weightI, Math.min(neuron.getWeightGain(weightI) + 0.05, 5));\n                } else {\n                    neuron.biasGain = Math.min(neuron.biasGain + 0.05, 5);\n                }\n            }\n\n            return newVal;\n        }\n    }, {\n        key: \"adagrad\",\n        value: function adagrad(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, neuron.getWeightsCache(weightI) + Math.pow(deltaValue, 2));\n            } else {\n                neuron.biasCache += Math.pow(deltaValue, 2);\n            }\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.getWeightsCache(weightI) : neuron.biasCache));\n        }\n    }, {\n        key: \"rmsprop\",\n        value: function rmsprop(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, this.rmsDecay * neuron.getWeightsCache(weightI) + (1 - this.rmsDecay) * Math.pow(deltaValue, 2));\n            } else {\n                neuron.biasCache = this.rmsDecay * neuron.biasCache + (1 - this.rmsDecay) * Math.pow(deltaValue, 2);\n            }\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.getWeightsCache(weightI) : neuron.biasCache));\n        }\n    }, {\n        key: \"adam\",\n        value: function adam(value, deltaValue, neuron) {\n\n            neuron.m = 0.9 * neuron.m + (1 - 0.9) * deltaValue;\n            var mt = neuron.m / (1 - Math.pow(0.9, this.iterations + 1));\n\n            neuron.v = 0.999 * neuron.v + (1 - 0.999) * Math.pow(deltaValue, 2);\n            var vt = neuron.v / (1 - Math.pow(0.999, this.iterations + 1));\n\n            return value + this.learningRate * mt / (Math.sqrt(vt) + 1e-8);\n        }\n    }, {\n        key: \"adadelta\",\n        value: function adadelta(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, this.rho * neuron.getWeightsCache(weightI) + (1 - this.rho) * Math.pow(deltaValue, 2));\n                var newVal = value + Math.sqrt((neuron.getAdadeltaCache(weightI) + 1e-6) / (neuron.getWeightsCache(weightI) + 1e-6)) * deltaValue;\n                neuron.setAdadeltaCache(weightI, this.rho * neuron.getAdadeltaCache(weightI) + (1 - this.rho) * Math.pow(deltaValue, 2));\n                return newVal;\n            } else {\n                neuron.biasCache = this.rho * neuron.biasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                var _newVal = value + Math.sqrt((neuron.adadeltaBiasCache + 1e-6) / (neuron.biasCache + 1e-6)) * deltaValue;\n                neuron.adadeltaBiasCache = this.rho * neuron.adadeltaBiasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                return _newVal;\n            }\n        }\n\n        // Weights init\n\n    }, {\n        key: \"uniform\",\n        value: function uniform(size, _ref23) {\n            var limit = _ref23.limit;\n\n            var values = [];\n\n            for (var i = 0; i < size; i++) {\n                values.push(Math.random() * 2 * limit - limit);\n            }\n\n            return values;\n        }\n    }, {\n        key: \"gaussian\",\n        value: function gaussian(size, _ref24) {\n            var mean = _ref24.mean,\n                stdDeviation = _ref24.stdDeviation;\n\n            var values = [];\n\n            // Polar Box Muller\n            for (var i = 0; i < size; i++) {\n                var x1 = void 0,\n                    x2 = void 0,\n                    r = void 0,\n                    y = void 0;\n\n                do {\n                    x1 = 2 * Math.random() - 1;\n                    x2 = 2 * Math.random() - 1;\n                    r = Math.pow(x1, 2) + Math.pow(x2, 2);\n                } while (r >= 1 || !r);\n\n                values.push(mean + x1 * Math.sqrt(-2 * Math.log(r) / r) * stdDeviation);\n            }\n\n            return values;\n        }\n    }, {\n        key: \"xaviernormal\",\n        value: function xaviernormal(size, _ref25) {\n            var fanIn = _ref25.fanIn,\n                fanOut = _ref25.fanOut;\n\n            return fanOut || fanOut == 0 ? NetMath.gaussian(size, { mean: 0, stdDeviation: Math.sqrt(2 / (fanIn + fanOut)) }) : NetMath.lecunnormal(size, { fanIn: fanIn });\n        }\n    }, {\n        key: \"xavieruniform\",\n        value: function xavieruniform(size, _ref26) {\n            var fanIn = _ref26.fanIn,\n                fanOut = _ref26.fanOut;\n\n            return fanOut || fanOut == 0 ? NetMath.uniform(size, { limit: Math.sqrt(6 / (fanIn + fanOut)) }) : NetMath.lecununiform(size, { fanIn: fanIn });\n        }\n    }, {\n        key: \"lecunnormal\",\n        value: function lecunnormal(size, _ref27) {\n            var fanIn = _ref27.fanIn;\n\n            return NetMath.gaussian(size, { mean: 0, stdDeviation: Math.sqrt(1 / fanIn) });\n        }\n    }, {\n        key: \"lecununiform\",\n        value: function lecununiform(size, _ref28) {\n            var fanIn = _ref28.fanIn;\n\n            return NetMath.uniform(size, { limit: Math.sqrt(3 / fanIn) });\n        }\n\n        // Pool\n\n    }, {\n        key: \"maxPool\",\n        value: function maxPool(layer, channel) {\n\n            var activations = NetUtil.getActivations(layer.prevLayer, channel, layer.inMapValuesCount);\n\n            for (var row = 0; row < layer.outMapSize; row++) {\n                for (var col = 0; col < layer.outMapSize; col++) {\n\n                    var rowStart = row * layer.stride;\n                    var colStart = col * layer.stride;\n\n                    // The first value\n                    var activation = activations[rowStart * layer.prevLayerOutWidth + colStart];\n\n                    for (var filterRow = 0; filterRow < layer.size; filterRow++) {\n                        for (var filterCol = 0; filterCol < layer.size; filterCol++) {\n\n                            var value = activations[(rowStart + filterRow) * layer.prevLayerOutWidth + (colStart + filterCol)];\n\n                            if (value > activation) {\n                                activation = value;\n                                layer.indeces[channel][row][col] = [filterRow, filterCol];\n                            }\n                        }\n                    }\n\n                    layer.activations[channel][row][col] = activation;\n                }\n            }\n        }\n\n        // Other\n\n    }, {\n        key: \"softmax\",\n        value: function softmax(values) {\n            var total = values.reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0);\n            return values.map(function (value) {\n                return value / total;\n            });\n        }\n    }, {\n        key: \"sech\",\n        value: function sech(value) {\n            return 2 * Math.exp(-value) / (1 + Math.exp(-2 * value));\n        }\n    }, {\n        key: \"standardDeviation\",\n        value: function standardDeviation(arr) {\n            var avg = arr.reduce(function (p, c) {\n                return p + c;\n            }) / arr.length;\n            var diffs = arr.map(function (v) {\n                return v - avg;\n            }).map(function (v) {\n                return Math.pow(v, 2);\n            });\n            return Math.sqrt(diffs.reduce(function (p, c) {\n                return p + c;\n            }) / diffs.length);\n        }\n    }, {\n        key: \"maxNorm\",\n        value: function maxNorm() {\n\n            if (this.maxNormTotal > this.maxNorm) {\n\n                var multiplier = this.maxNorm / (1e-18 + this.maxNormTotal);\n\n                this.layers.forEach(function (layer, li) {\n                    li && layer.neurons.forEach(function (neuron) {\n                        neuron.weights.forEach(function (w, wi) {\n                            return neuron.setWeight(wi, neuron.getWeight(wi) * multiplier);\n                        });\n                    });\n                });\n            }\n\n            this.maxNormTotal = 0;\n        }\n    }]);\n\n    return NetMath;\n}();\n\ntypeof window == \"undefined\" && (exports.NetMath = NetMath);\n\"use strict\";\n\nvar NetUtil = function () {\n    function NetUtil() {\n        _classCallCheck(this, NetUtil);\n    }\n\n    _createClass(NetUtil, null, [{\n        key: \"format\",\n        value: function format(value) {\n            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"string\";\n\n            switch (true) {\n\n                case type == \"string\" && typeof value == \"string\":\n                    value = value.replace(/(_|\\s)/g, \"\").toLowerCase();\n                    break;\n\n                case type == \"time\" && typeof value == \"number\":\n                    var date = new Date(value);\n                    var formatted = [];\n\n                    if (value < 1000) {\n                        formatted.push(date.getMilliseconds() + \"ms\");\n                    } else if (value < 60000) {\n                        formatted.push(date.getSeconds() + \".\" + date.getMilliseconds() + \"s\");\n                    } else {\n\n                        if (value >= 3600000) formatted.push(date.getHours() + \"h\");\n                        if (value >= 60000) formatted.push(date.getMinutes() + \"m\");\n\n                        formatted.push(date.getSeconds() + \"s\");\n                    }\n\n                    value = formatted.join(\" \");\n                    break;\n            }\n\n            return value;\n        }\n    }, {\n        key: \"shuffle\",\n        value: function shuffle(arr) {\n            for (var i = arr.length; i; i--) {\n                var j = Math.floor(Math.random() * i);\n                var x = arr[i - 1];\n                arr[i - 1] = arr[j];\n                arr[j] = x;\n            }\n        }\n    }, {\n        key: \"addZeroPadding\",\n        value: function addZeroPadding(map, zP) {\n\n            var data = [];\n\n            for (var row = 0; row < map.length; row++) {\n                data.push(map[row].slice(0));\n            }\n\n            var extraRows = [];\n\n            for (var i = 0; i < data.length + 2 * zP; i++) {\n                extraRows.push(0);\n            }\n\n            for (var col = 0; col < data.length; col++) {\n                for (var _i = 0; _i < zP; _i++) {\n                    data[col].splice(0, 0, 0);\n                    data[col].splice(data.length + 1, data.length, 0);\n                }\n            }\n\n            for (var _i2 = 0; _i2 < zP; _i2++) {\n                data.splice(0, 0, extraRows.slice(0));\n                data.splice(data.length, data.length - 1, extraRows.slice(0));\n            }\n\n            return data;\n        }\n    }, {\n        key: \"arrayToMap\",\n        value: function arrayToMap(arr, size) {\n            var map = [];\n\n            for (var i = 0; i < size; i++) {\n                map[i] = [];\n\n                for (var j = 0; j < size; j++) {\n                    map[i][j] = arr[i * size + j];\n                }\n            }\n\n            return map;\n        }\n    }, {\n        key: \"arrayToVolume\",\n        value: function arrayToVolume(arr, channels) {\n\n            var vol = [];\n            var size = Math.sqrt(arr.length / channels);\n            var mapValues = Math.pow(size, 2);\n\n            for (var d = 0; d < Math.floor(arr.length / mapValues); d++) {\n\n                var map = [];\n\n                for (var i = 0; i < size; i++) {\n                    map[i] = [];\n\n                    for (var j = 0; j < size; j++) {\n                        map[i][j] = arr[d * mapValues + i * size + j];\n                    }\n                }\n\n                vol[d] = map;\n            }\n\n            return vol;\n        }\n    }, {\n        key: \"convolve\",\n        value: function convolve(_ref29) {\n            var input = _ref29.input,\n                zeroPadding = _ref29.zeroPadding,\n                weights = _ref29.weights,\n                channels = _ref29.channels,\n                stride = _ref29.stride,\n                bias = _ref29.bias;\n\n\n            var inputVol = NetUtil.arrayToVolume(input, channels);\n            var outputMap = [];\n\n            var paddedLength = inputVol[0].length + zeroPadding * 2;\n            var fSSpread = Math.floor(weights[0].length / 2\n\n            // For each input channels,\n            );for (var di = 0; di < channels; di++) {\n                inputVol[di] = NetUtil.addZeroPadding(inputVol[di], zeroPadding\n                // For each inputY without ZP\n                );for (var inputY = fSSpread; inputY < paddedLength - fSSpread; inputY += stride) {\n                    outputMap[(inputY - fSSpread) / stride] = outputMap[(inputY - fSSpread) / stride] || [];\n                    // For each inputX without zP\n                    for (var inputX = fSSpread; inputX < paddedLength - fSSpread; inputX += stride) {\n                        var sum = 0;\n                        // For each weightsY on input\n                        for (var weightsY = 0; weightsY < weights[0].length; weightsY++) {\n                            // For each weightsX on input\n                            for (var weightsX = 0; weightsX < weights[0].length; weightsX++) {\n                                sum += inputVol[di][inputY + (weightsY - fSSpread)][inputX + (weightsX - fSSpread)] * weights[di][weightsY][weightsX];\n                            }\n                        }\n\n                        outputMap[(inputY - fSSpread) / stride][(inputX - fSSpread) / stride] = (outputMap[(inputY - fSSpread) / stride][(inputX - fSSpread) / stride] || 0) + sum;\n                    }\n                }\n            }\n\n            // Then add bias\n            for (var outY = 0; outY < outputMap.length; outY++) {\n                for (var outX = 0; outX < outputMap.length; outX++) {\n                    outputMap[outY][outX] += bias;\n                }\n            }\n\n            return outputMap;\n        }\n    }, {\n        key: \"buildConvErrorMap\",\n        value: function buildConvErrorMap(nextLayer, errorMap, filterI) {\n\n            // Cache / convenience\n            var zeroPadding = nextLayer.zeroPadding;\n            var paddedLength = errorMap.length + zeroPadding * 2;\n            var fSSpread = Math.floor(nextLayer.filterSize / 2\n\n            // Zero pad and clear the error map, to allow easy convoling\n            );var paddedRow = [];\n\n            for (var val = 0; val < paddedLength; val++) {\n                paddedRow.push(0);\n            }\n\n            for (var row = 0; row < paddedLength; row++) {\n                errorMap[row] = paddedRow.slice(0);\n            }\n\n            // For each channel in filter in the next layer which corresponds to this filter\n            for (var nlFilterI = 0; nlFilterI < nextLayer.size; nlFilterI++) {\n\n                var weights = nextLayer.filters[nlFilterI].weights[filterI];\n                var errMap = nextLayer.filters[nlFilterI].errorMap;\n\n                // Unconvolve their error map using the weights\n                for (var inputY = fSSpread; inputY < paddedLength - fSSpread; inputY += nextLayer.stride) {\n                    for (var inputX = fSSpread; inputX < paddedLength - fSSpread; inputX += nextLayer.stride) {\n\n                        for (var weightsY = 0; weightsY < nextLayer.filterSize; weightsY++) {\n                            for (var weightsX = 0; weightsX < nextLayer.filterSize; weightsX++) {\n                                errorMap[inputY + (weightsY - fSSpread)][inputX + (weightsX - fSSpread)] += weights[weightsY][weightsX] * errMap[(inputY - fSSpread) / nextLayer.stride][(inputX - fSSpread) / nextLayer.stride];\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Take out the zero padding. Rows:\n            errorMap.splice(0, zeroPadding);\n            errorMap.splice(errorMap.length - zeroPadding, errorMap.length\n\n            // Columns:\n            );for (var emXI = 0; emXI < errorMap.length; emXI++) {\n                errorMap[emXI] = errorMap[emXI].splice(zeroPadding, errorMap[emXI].length - zeroPadding * 2);\n            }\n        }\n    }, {\n        key: \"buildConvDWeights\",\n        value: function buildConvDWeights(layer) {\n\n            var weightsCount = layer.filters[0].weights[0].length;\n            var fSSpread = Math.floor(weightsCount / 2);\n            var channelsCount = layer.filters[0].weights.length;\n\n            // Adding an intermediary step to allow regularization to work\n            var deltaDeltaWeights = [];\n\n            // Filling the deltaDeltaWeights with 0 values\n            for (var weightsY = 0; weightsY < weightsCount; weightsY++) {\n                deltaDeltaWeights[weightsY] = [];\n                for (var weightsX = 0; weightsX < weightsCount; weightsX++) {\n                    deltaDeltaWeights[weightsY][weightsX] = 0;\n                }\n            }\n\n            // For each filter\n            for (var filterI = 0; filterI < layer.filters.length; filterI++) {\n\n                var filter = layer.filters[filterI];\n\n                // Each channel will take the error map and the corresponding inputMap from the input...\n                for (var channelI = 0; channelI < channelsCount; channelI++) {\n\n                    var inputValues = NetUtil.getActivations(layer.prevLayer, channelI, layer.inMapValuesCount);\n                    var inputMap = NetUtil.addZeroPadding(NetUtil.arrayToMap(inputValues, Math.sqrt(layer.inMapValuesCount)), layer.zeroPadding\n\n                    // ...slide the filter with correct stride across the zero-padded inputMap...\n                    );for (var inputY = fSSpread; inputY < inputMap.length - fSSpread; inputY += layer.stride) {\n                        for (var inputX = fSSpread; inputX < inputMap.length - fSSpread; inputX += layer.stride) {\n\n                            // ...and at each location...\n                            for (var _weightsY = 0; _weightsY < weightsCount; _weightsY++) {\n                                for (var _weightsX = 0; _weightsX < weightsCount; _weightsX++) {\n\n                                    var activation = inputMap[inputY - fSSpread + _weightsY][inputX - fSSpread + _weightsX];\n\n                                    // Increment and regularize the delta delta weights by the input activation (later multiplied by the error)\n                                    deltaDeltaWeights[_weightsY][_weightsX] += activation * (1 + ((layer.net.l2 || 0) + (layer.net.l1 || 0)) / layer.net.miniBatchSize * filter.weights[channelI][_weightsY][_weightsX]);\n                                }\n                            }\n\n                            var error = filter.errorMap[(inputY - fSSpread) / layer.stride][(inputX - fSSpread) / layer.stride];\n\n                            // Applying and resetting the deltaDeltaWeights\n                            for (var _weightsY2 = 0; _weightsY2 < weightsCount; _weightsY2++) {\n                                for (var _weightsX2 = 0; _weightsX2 < weightsCount; _weightsX2++) {\n                                    filter.deltaWeights[channelI][_weightsY2][_weightsX2] += deltaDeltaWeights[_weightsY2][_weightsX2] * error;\n                                    deltaDeltaWeights[_weightsY2][_weightsX2] = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Increment the deltaBias by the sum of all errors in the filter\n                for (var eY = 0; eY < filter.errorMap.length; eY++) {\n                    for (var eX = 0; eX < filter.errorMap.length; eX++) {\n                        filter.deltaBias += filter.errorMap[eY][eX];\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getActivations\",\n        value: function getActivations(layer, mapStartI, mapSize) {\n\n            var returnArr = [];\n\n            if (arguments.length == 1) {\n\n                if (layer instanceof FCLayer) {\n\n                    for (var ni = 0; ni < layer.neurons.length; ni++) {\n                        returnArr.push(layer.neurons[ni].activation);\n                    }\n                } else if (layer instanceof ConvLayer) {\n\n                    for (var fi = 0; fi < layer.filters.length; fi++) {\n                        for (var rowI = 0; rowI < layer.filters[fi].activationMap.length; rowI++) {\n                            for (var colI = 0; colI < layer.filters[fi].activationMap[rowI].length; colI++) {\n                                returnArr.push(layer.filters[fi].activationMap[rowI][colI]);\n                            }\n                        }\n                    }\n                } else {\n\n                    for (var channel = 0; channel < layer.activations.length; channel++) {\n                        for (var row = 0; row < layer.activations[0].length; row++) {\n                            for (var col = 0; col < layer.activations[0].length; col++) {\n                                returnArr.push(layer.activations[channel][row][col]);\n                            }\n                        }\n                    }\n                }\n            } else {\n\n                if (layer instanceof FCLayer) {\n\n                    for (var i = mapStartI * mapSize; i < (mapStartI + 1) * mapSize; i++) {\n                        returnArr.push(layer.neurons[i].activation);\n                    }\n                } else if (layer instanceof ConvLayer) {\n\n                    for (var _row3 = 0; _row3 < layer.filters[mapStartI].activationMap.length; _row3++) {\n                        for (var _col3 = 0; _col3 < layer.filters[mapStartI].activationMap[_row3].length; _col3++) {\n                            returnArr.push(layer.filters[mapStartI].activationMap[_row3][_col3]);\n                        }\n                    }\n                } else {\n\n                    for (var _row4 = 0; _row4 < layer.activations[mapStartI].length; _row4++) {\n                        for (var _col4 = 0; _col4 < layer.activations[mapStartI].length; _col4++) {\n                            returnArr.push(layer.activations[mapStartI][_row4][_col4]);\n                        }\n                    }\n                }\n            }\n\n            return returnArr;\n        }\n    }]);\n\n    return NetUtil;\n}();\n\ntypeof window == \"undefined\" && (exports.NetUtil = NetUtil);\n\"use strict\";\n\nvar Network = function () {\n    function Network() {\n        var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            learningRate = _ref30.learningRate,\n            _ref30$layers = _ref30.layers,\n            layers = _ref30$layers === undefined ? [] : _ref30$layers,\n            _ref30$updateFn = _ref30.updateFn,\n            updateFn = _ref30$updateFn === undefined ? \"vanillaupdatefn\" : _ref30$updateFn,\n            _ref30$activation = _ref30.activation,\n            activation = _ref30$activation === undefined ? \"sigmoid\" : _ref30$activation,\n            _ref30$cost = _ref30.cost,\n            cost = _ref30$cost === undefined ? \"meansquarederror\" : _ref30$cost,\n            rmsDecay = _ref30.rmsDecay,\n            rho = _ref30.rho,\n            lreluSlope = _ref30.lreluSlope,\n            eluAlpha = _ref30.eluAlpha,\n            _ref30$dropout = _ref30.dropout,\n            dropout = _ref30$dropout === undefined ? 1 : _ref30$dropout,\n            _ref30$l = _ref30.l2,\n            l2 = _ref30$l === undefined ? true : _ref30$l,\n            _ref30$l2 = _ref30.l1,\n            l1 = _ref30$l2 === undefined ? true : _ref30$l2,\n            maxNorm = _ref30.maxNorm,\n            weightsConfig = _ref30.weightsConfig,\n            channels = _ref30.channels,\n            conv = _ref30.conv,\n            pool = _ref30.pool;\n\n        _classCallCheck(this, Network);\n\n        this.state = \"not-defined\";\n        this.layers = [];\n        this.conv = {};\n        this.pool = {};\n        this.epochs = 0;\n        this.iterations = 0;\n        this.dropout = dropout == false ? 1 : dropout;\n        this.error = 0;\n        activation = NetUtil.format(activation);\n        updateFn = NetUtil.format(updateFn);\n        cost = NetUtil.format(cost);\n\n        if (l2) {\n            this.l2 = typeof l2 == \"boolean\" ? 0.001 : l2;\n            this.l2Error = 0;\n        }\n\n        if (l1) {\n            this.l1 = typeof l1 == \"boolean\" ? 0.005 : l1;\n            this.l1Error = 0;\n        }\n\n        if (maxNorm) {\n            this.maxNorm = typeof maxNorm == \"boolean\" && maxNorm ? 1000 : maxNorm;\n            this.maxNormTotal = 0;\n        }\n\n        if (learningRate) this.learningRate = learningRate;\n        if (channels) this.channels = channels;\n\n        if (conv) {\n            if (conv.filterSize != undefined) this.conv.filterSize = conv.filterSize;\n            if (conv.zeroPadding != undefined) this.conv.zeroPadding = conv.zeroPadding;\n            if (conv.stride != undefined) this.conv.stride = conv.stride;\n        }\n\n        if (pool) {\n            if (pool.size) this.pool.size = pool.size;\n            if (pool.stride) this.pool.stride = pool.stride;\n        }\n\n        // Activation function / Learning Rate\n        switch (updateFn) {\n\n            case \"rmsprop\":\n                this.learningRate = this.learningRate == undefined ? 0.001 : this.learningRate;\n                break;\n\n            case \"adam\":\n                this.learningRate = this.learningRate == undefined ? 0.01 : this.learningRate;\n                break;\n\n            case \"adadelta\":\n                this.rho = rho == null ? 0.95 : rho;\n                break;\n\n            default:\n\n                if (this.learningRate == undefined) {\n\n                    switch (activation) {\n\n                        case \"relu\":\n                        case \"lrelu\":\n                        case \"rrelu\":\n                        case \"elu\":\n                            this.learningRate = 0.01;\n                            break;\n\n                        case \"tanh\":\n                        case \"lecuntanh\":\n                            this.learningRate = 0.001;\n                            break;\n\n                        default:\n                            this.learningRate = 0.2;\n                    }\n                }\n        }\n\n        this.updateFn = [false, null, undefined].includes(updateFn) ? \"vanillaupdatefn\" : updateFn;\n        this.weightUpdateFn = NetMath[this.updateFn];\n        this.activation = typeof activation == \"function\" ? activation : NetMath[activation].bind(this);\n        this.activationConfig = activation;\n        this.cost = typeof cost == \"function\" ? cost : NetMath[cost];\n\n        if (this.updateFn == \"rmsprop\") {\n            this.rmsDecay = rmsDecay == undefined ? 0.99 : rmsDecay;\n        }\n\n        this.lreluSlope = lreluSlope == undefined ? -0.0005 : lreluSlope;\n        this.eluAlpha = eluAlpha == undefined ? 1 : eluAlpha;\n\n        // Weights distributiom\n        this.weightsConfig = { distribution: \"xavieruniform\" };\n\n        if (weightsConfig != undefined && weightsConfig.distribution) {\n            this.weightsConfig.distribution = NetUtil.format(weightsConfig.distribution);\n        }\n\n        if (this.weightsConfig.distribution == \"uniform\") {\n            this.weightsConfig.limit = weightsConfig && weightsConfig.limit != undefined ? weightsConfig.limit : 0.1;\n        } else if (this.weightsConfig.distribution == \"gaussian\") {\n            this.weightsConfig.mean = weightsConfig.mean || 0;\n            this.weightsConfig.stdDeviation = weightsConfig.stdDeviation || 0.05;\n        }\n\n        if (typeof this.weightsConfig.distribution == \"function\") {\n            this.weightsInitFn = this.weightsConfig.distribution;\n        } else {\n            this.weightsInitFn = NetMath[this.weightsConfig.distribution];\n        }\n\n        // State\n        if (layers.length) {\n\n            switch (true) {\n\n                case layers.every(function (item) {\n                    return Number.isInteger(item);\n                }):\n                    this.layers = layers.map(function (size) {\n                        return new FCLayer(size);\n                    });\n                    this.state = \"constructed\";\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (layer) {\n                    return layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer;\n                }):\n                    this.state = \"constructed\";\n                    this.layers = layers;\n                    this.initLayers();\n                    break;\n\n                default:\n                    throw new Error(\"There was an error constructing from the layers given.\");\n            }\n        }\n    }\n\n    _createClass(Network, [{\n        key: \"initLayers\",\n        value: function initLayers(input, expected) {\n\n            switch (this.state) {\n\n                case \"initialised\":\n                    return;\n\n                case \"not-defined\":\n                    this.layers[0] = new FCLayer(input);\n                    this.layers[1] = new FCLayer(Math.ceil(input / expected > 5 ? expected + Math.abs(input - expected) / 4 : input + expected));\n                    this.layers[2] = new FCLayer(Math.ceil(expected));\n                    break;\n            }\n\n            this.layers.forEach(this.joinLayer.bind(this));\n            this.state = \"initialised\";\n        }\n    }, {\n        key: \"joinLayer\",\n        value: function joinLayer(layer, layerIndex) {\n\n            layer.net = this;\n            layer.activation = layer.activation == undefined ? this.activation : layer.activation;\n\n            layer.weightsConfig = {};\n            Object.assign(layer.weightsConfig, this.weightsConfig);\n\n            if (layerIndex) {\n                this.layers[layerIndex - 1].assignNext(layer);\n                layer.assignPrev(this.layers[layerIndex - 1], layerIndex);\n\n                layer.weightsConfig.fanIn = layer.prevLayer.size;\n                layer.prevLayer.weightsConfig.fanOut = layer.size;\n\n                layer.init();\n                layer.state = \"initialised\";\n            }\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n\n            if (this.state != \"initialised\") {\n                throw new Error(\"The network layers have not been initialised.\");\n            }\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No data passed to Network.forward()\");\n            }\n\n            if (data.length != this.layers[0].neurons.length) {\n                console.warn(\"Input data length did not match input layer neurons count.\");\n            }\n\n            this.layers[0].neurons.forEach(function (neuron, ni) {\n                return neuron.activation = data[ni];\n            });\n            this.layers.forEach(function (layer, li) {\n                return li && layer.forward(data);\n            });\n            return this.layers[this.layers.length - 1].neurons.map(function (n) {\n                return n.activation;\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n\n            if (expected === undefined) {\n                throw new Error(\"No data passed to Network.backward()\");\n            }\n\n            if (expected.length != this.layers[this.layers.length - 1].neurons.length) {\n                console.warn(\"Expected data length did not match output layer neurons count.\", expected);\n            }\n\n            this.layers[this.layers.length - 1].backward(expected);\n\n            for (var layerIndex = this.layers.length - 2; layerIndex > 0; layerIndex--) {\n                this.layers[layerIndex].backward();\n            }\n        }\n    }, {\n        key: \"train\",\n        value: function train(dataSet) {\n            var _this6 = this;\n\n            var _ref31 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref31$epochs = _ref31.epochs,\n                epochs = _ref31$epochs === undefined ? 1 : _ref31$epochs,\n                callback = _ref31.callback,\n                _ref31$log = _ref31.log,\n                log = _ref31$log === undefined ? true : _ref31$log,\n                _ref31$miniBatchSize = _ref31.miniBatchSize,\n                miniBatchSize = _ref31$miniBatchSize === undefined ? 1 : _ref31$miniBatchSize,\n                _ref31$shuffle = _ref31.shuffle,\n                shuffle = _ref31$shuffle === undefined ? false : _ref31$shuffle;\n\n            this.miniBatchSize = typeof miniBatchSize == \"boolean\" && miniBatchSize ? dataSet[0].expected.length : miniBatchSize;\n\n            return new Promise(function (resolve, reject) {\n\n                if (shuffle) {\n                    NetUtil.shuffle(dataSet);\n                }\n\n                if (log) {\n                    console.log(\"Training started. Epochs: \" + epochs + \" Batch Size: \" + _this6.miniBatchSize);\n                }\n\n                if (dataSet === undefined || dataSet === null) {\n                    return void reject(\"No data provided\");\n                }\n\n                if (_this6.state != \"initialised\") {\n                    _this6.initLayers(dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length);\n                }\n\n                _this6.layers.forEach(function (layer) {\n                    return layer.state = \"training\";\n                });\n\n                var iterationIndex = 0;\n                var epochsCounter = 0;\n                var startTime = Date.now();\n\n                var doEpoch = function doEpoch() {\n                    _this6.epochs++;\n                    _this6.error = 0;\n                    iterationIndex = 0;\n\n                    if (_this6.l2Error != undefined) _this6.l2Error = 0;\n                    if (_this6.l1Error != undefined) _this6.l1Error = 0;\n\n                    doIteration();\n                };\n\n                var doIteration = function doIteration() {\n\n                    if (!dataSet[iterationIndex].hasOwnProperty(\"input\") || !dataSet[iterationIndex].hasOwnProperty(\"expected\") && !dataSet[iterationIndex].hasOwnProperty(\"output\")) {\n                        return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\");\n                    }\n\n                    var input = dataSet[iterationIndex].input;\n                    var output = _this6.forward(input);\n                    var target = dataSet[iterationIndex].expected || dataSet[iterationIndex].output;\n\n                    _this6.backward(target);\n\n                    if (++iterationIndex % _this6.miniBatchSize == 0) {\n                        _this6.applyDeltaWeights();\n                        _this6.resetDeltaWeights();\n                    } else if (iterationIndex >= dataSet.length) {\n                        _this6.applyDeltaWeights();\n                    }\n\n                    var iterationError = _this6.cost(target, output);\n                    var elapsed = Date.now() - startTime;\n                    _this6.error += iterationError;\n                    _this6.iterations++;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: _this6.iterations,\n                            error: iterationError,\n                            elapsed: elapsed, input: input\n                        });\n                    }\n\n                    if (iterationIndex < dataSet.length) {\n                        setTimeout(doIteration.bind(_this6), 0);\n                    } else {\n                        epochsCounter++;\n\n                        if (log) {\n                            console.log(\"Epoch: \" + _this6.epochs + \" Error: \" + _this6.error / iterationIndex + (_this6.l2 == undefined ? \"\" : \" L2 Error: \" + _this6.l2Error / iterationIndex), \"\\nElapsed: \" + NetUtil.format(elapsed, \"time\") + \" Average Duration: \" + NetUtil.format(elapsed / epochsCounter, \"time\"));\n                        }\n\n                        if (epochsCounter < epochs) {\n                            doEpoch();\n                        } else {\n                            _this6.layers.forEach(function (layer) {\n                                return layer.state = \"initialised\";\n                            });\n\n                            if (log) {\n                                console.log(\"Training finished. Total time: \" + NetUtil.format(elapsed, \"time\") + \"  Average iteration time: \" + NetUtil.format(elapsed / iterationIndex, \"time\"));\n                            }\n                            resolve();\n                        }\n                    }\n                };\n\n                _this6.resetDeltaWeights();\n                doEpoch();\n            });\n        }\n    }, {\n        key: \"test\",\n        value: function test(testSet) {\n            var _this7 = this;\n\n            var _ref32 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref32$log = _ref32.log,\n                log = _ref32$log === undefined ? true : _ref32$log,\n                callback = _ref32.callback;\n\n            return new Promise(function (resolve, reject) {\n\n                if (testSet === undefined || testSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                if (log) {\n                    console.log(\"Testing started\");\n                }\n\n                var totalError = 0;\n                var iterationIndex = 0;\n                var startTime = Date.now();\n\n                var testInput = function testInput() {\n\n                    var input = testSet[iterationIndex].input;\n                    var output = _this7.forward(input);\n                    var target = testSet[iterationIndex].expected || testSet[iterationIndex].output;\n                    var elapsed = Date.now() - startTime;\n\n                    var iterationError = _this7.cost(target, output);\n                    totalError += iterationError;\n                    iterationIndex++;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: iterationIndex,\n                            error: iterationError,\n                            elapsed: elapsed, input: input\n                        });\n                    }\n\n                    if (iterationIndex < testSet.length) {\n                        setTimeout(testInput.bind(_this7), 0);\n                    } else {\n\n                        if (log) {\n                            console.log(\"Testing finished. Total time: \" + NetUtil.format(elapsed, \"time\") + \"  Average iteration time: \" + NetUtil.format(elapsed / iterationIndex, \"time\"));\n                        }\n\n                        resolve(totalError / testSet.length);\n                    }\n                };\n                testInput();\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            this.layers.forEach(function (layer, li) {\n                return li && layer.resetDeltaWeights();\n            });\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n\n            this.layers.forEach(function (layer, li) {\n                return li && layer.applyDeltaWeights();\n            });\n\n            if (this.maxNorm != undefined) {\n                this.maxNormTotal = Math.sqrt(this.maxNormTotal);\n                NetMath.maxNorm.bind(this)();\n            }\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                layers: this.layers.map(function (layer) {\n                    return layer.toJSON();\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data) {\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No JSON data given to import.\");\n            }\n\n            if (data.layers.length != this.layers.length) {\n                throw new Error(\"Mismatched layers (\" + data.layers.length + \" layers in import data, but \" + this.layers.length + \" configured)\");\n            }\n\n            this.resetDeltaWeights();\n            this.layers.forEach(function (layer, li) {\n                return li && layer.fromJSON(data.layers[li], li);\n            });\n        }\n    }], [{\n        key: \"version\",\n        get: function get() {\n            return \"2.0.0\";\n        }\n    }]);\n\n    return Network;\n}();\n\ntypeof window == \"undefined\" && (exports.Network = Network);\n\"use strict\";\n\nvar Neuron = function () {\n    function Neuron() {\n        _classCallCheck(this, Neuron);\n    }\n\n    _createClass(Neuron, [{\n        key: \"init\",\n        value: function init() {\n            var _this8 = this;\n\n            var _ref33 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                updateFn = _ref33.updateFn,\n                activation = _ref33.activation,\n                eluAlpha = _ref33.eluAlpha;\n\n            var size = this.weights.length;\n            this.deltaWeights = this.weights.map(function (v) {\n                return 0;\n            });\n\n            switch (updateFn) {\n\n                case \"gain\":\n                    this.biasGain = 1;\n                    this.weightGains = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 1;\n                    });\n                    this.getWeightGain = function (i) {\n                        return _this8.weightGains[i];\n                    };\n                    this.setWeightGain = function (i, v) {\n                        return _this8.weightGains[i] = v;\n                    };\n                    break;\n\n                case \"adagrad\":\n                case \"rmsprop\":\n                case \"adadelta\":\n                    this.biasCache = 0;\n                    this.weightsCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 0;\n                    });\n                    this.getWeightsCache = function (i) {\n                        return _this8.weightsCache[i];\n                    };\n                    this.setWeightsCache = function (i, v) {\n                        return _this8.weightsCache[i] = v;\n                    };\n\n                    if (updateFn == \"adadelta\") {\n                        this.adadeltaBiasCache = 0;\n                        this.adadeltaCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                            return 0;\n                        });\n                        this.getAdadeltaCache = function (i) {\n                            return _this8.adadeltaCache[i];\n                        };\n                        this.setAdadeltaCache = function (i, v) {\n                            return _this8.adadeltaCache[i] = v;\n                        };\n                    }\n                    break;\n\n                case \"adam\":\n                    this.m = 0;\n                    this.v = 0;\n                    break;\n            }\n\n            if (activation == \"rrelu\") {\n                this.rreluSlope = Math.random() * 0.001;\n            } else if (activation == \"elu\") {\n                this.eluAlpha = eluAlpha;\n            }\n        }\n    }, {\n        key: \"getWeight\",\n        value: function getWeight(i) {\n            return this.weights[i];\n        }\n    }, {\n        key: \"setWeight\",\n        value: function setWeight(i, v) {\n            this.weights[i] = v;\n        }\n    }, {\n        key: \"getDeltaWeight\",\n        value: function getDeltaWeight(i) {\n            return this.deltaWeights[i];\n        }\n    }, {\n        key: \"setDeltaWeight\",\n        value: function setDeltaWeight(i, v) {\n            this.deltaWeights[i] = v;\n        }\n    }]);\n\n    return Neuron;\n}();\n\ntypeof window == \"undefined\" && (exports.Neuron = Neuron);\n\"use strict\";\n\nvar PoolLayer = function () {\n    function PoolLayer(size) {\n        var _ref34 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            stride = _ref34.stride,\n            activation = _ref34.activation;\n\n        _classCallCheck(this, PoolLayer);\n\n        if (size) this.size = size;\n        if (stride) this.stride = stride;\n\n        if (activation != undefined && activation != false) {\n            this.activation = typeof activation == \"function\" ? activation : NetMath[NetUtil.format(activation)].bind(this);\n        } else {\n            this.activation = false;\n        }\n    }\n\n    _createClass(PoolLayer, [{\n        key: \"init\",\n        value: function init() {}\n    }, {\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer, layerIndex) {\n            var _this9 = this;\n\n            this.prevLayer = layer;\n            this.size = this.size || this.net.pool.size || 2;\n            this.stride = this.stride || this.net.pool.stride || this.size;\n\n            var prevLayerOutWidth = layer.outMapSize;\n\n            switch (layer.constructor.name) {\n\n                case \"FCLayer\":\n                    this.channels = this.net.channels;\n                    prevLayerOutWidth = Math.max(Math.floor(Math.sqrt(layer.size / this.channels)), 1);\n                    break;\n\n                case \"ConvLayer\":\n                    this.channels = layer.size;\n                    break;\n\n                case \"PoolLayer\":\n                    this.channels = layer.channels;\n                    break;\n            }\n\n            this.prevLayerOutWidth = prevLayerOutWidth;\n            this.outMapSize = (prevLayerOutWidth - this.size) / this.stride + 1;\n            this.inMapValuesCount = Math.pow(prevLayerOutWidth, 2);\n\n            if (this.outMapSize % 1 != 0) {\n                throw new Error(\"Misconfigured hyperparameters. Activation volume dimensions would be \" + this.outMapSize + \" in pool layer at index \" + layerIndex);\n            }\n\n            this.activations = [].concat(_toConsumableArray(new Array(this.channels))).map(function (channel) {\n                return [].concat(_toConsumableArray(new Array(_this9.outMapSize))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(_this9.outMapSize))).map(function (v) {\n                        return 0;\n                    });\n                });\n            });\n            this.errors = [].concat(_toConsumableArray(new Array(this.channels))).map(function (channel) {\n                return [].concat(_toConsumableArray(new Array(prevLayerOutWidth))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(prevLayerOutWidth))).map(function (v) {\n                        return 0;\n                    });\n                });\n            });\n            this.indeces = this.activations.map(function (channel) {\n                return channel.map(function (row) {\n                    return row.map(function (v) {\n                        return [0, 0];\n                    });\n                });\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward() {\n            for (var channel = 0; channel < this.channels; channel++) {\n\n                NetMath.maxPool(this, channel\n\n                // Apply activations\n                );if (this.activation) {\n                    for (var row = 0; row < this.outMapSize; row++) {\n                        for (var col = 0; col < this.outMapSize; col++) {\n                            this.activations[channel][row][col] = this.activation(this.activations[channel][row][col], false, this.net);\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"backward\",\n        value: function backward() {\n\n            // Clear the existing error values, first\n            for (var channel = 0; channel < this.channels; channel++) {\n                for (var row = 0; row < this.errors[0].length; row++) {\n                    for (var col = 0; col < this.errors[0].length; col++) {\n                        this.errors[channel][row][col] = 0;\n                    }\n                }\n            }\n\n            if (this.nextLayer instanceof FCLayer) {\n\n                for (var _channel = 0; _channel < this.channels; _channel++) {\n                    for (var _row5 = 0; _row5 < this.outMapSize; _row5++) {\n                        for (var _col5 = 0; _col5 < this.outMapSize; _col5++) {\n\n                            var rowI = this.indeces[_channel][_row5][_col5][0] + _row5 * this.stride;\n                            var colI = this.indeces[_channel][_row5][_col5][1] + _col5 * this.stride;\n                            var neuronI = _channel * Math.pow(this.outMapSize, 2) + _row5 * this.outMapSize + _col5;\n\n                            var weightIndex = _channel * Math.pow(this.outMapSize, 2) + _row5 * this.outMapSize + _col5;\n\n                            for (var neuron = 0; neuron < this.nextLayer.neurons.length; neuron++) {\n                                this.errors[_channel][rowI][colI] += this.nextLayer.neurons[neuron].error * this.nextLayer.neurons[neuron].weights[weightIndex];\n                            }\n                        }\n                    }\n                }\n            } else if (this.nextLayer instanceof ConvLayer) {\n\n                for (var _channel2 = 0; _channel2 < this.channels; _channel2++) {\n\n                    var errs = [];\n\n                    for (var _col6 = 0; _col6 < this.outMapSize; _col6++) {\n                        errs[_col6] = 0;\n                    }\n\n                    // Convolve on the error map\n                    NetUtil.buildConvErrorMap(this.nextLayer, errs, _channel2);\n\n                    for (var _row6 = 0; _row6 < this.outMapSize; _row6++) {\n                        for (var _col7 = 0; _col7 < this.outMapSize; _col7++) {\n\n                            var _rowI = this.indeces[_channel2][_row6][_col7][0] + _row6 * this.stride;\n                            var _colI = this.indeces[_channel2][_row6][_col7][1] + _col7 * this.stride;\n\n                            this.errors[_channel2][_rowI][_colI] += errs[_row6][_col7];\n                        }\n                    }\n                }\n            } else {\n\n                for (var _channel3 = 0; _channel3 < this.channels; _channel3++) {\n                    for (var _row7 = 0; _row7 < this.outMapSize; _row7++) {\n                        for (var _col8 = 0; _col8 < this.outMapSize; _col8++) {\n\n                            var _rowI2 = this.indeces[_channel3][_row7][_col8][0] + _row7 * this.stride;\n                            var _colI2 = this.indeces[_channel3][_row7][_col8][1] + _col8 * this.stride;\n\n                            this.errors[_channel3][_rowI2][_colI2] += this.nextLayer.errors[_channel3][_row7][_col8];\n                        }\n                    }\n                }\n            }\n\n            // Apply derivatives\n            if (this.activation) {\n                for (var _channel4 = 0; _channel4 < this.channels; _channel4++) {\n\n                    for (var _row8 = 0; _row8 < this.indeces[_channel4].length; _row8++) {\n                        for (var _col9 = 0; _col9 < this.indeces[_channel4].length; _col9++) {\n\n                            var _rowI3 = this.indeces[_channel4][_row8][_col9][0] + _row8 * this.stride;\n                            var _colI3 = this.indeces[_channel4][_row8][_col9][1] + _col9 * this.stride;\n\n                            this.errors[_channel4][_rowI3][_colI3] *= this.activation(this.errors[_channel4][_rowI3][_colI3], true, this.net);\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {}\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {}\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {};\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON() {}\n    }]);\n\n    return PoolLayer;\n}();\n\ntypeof window == \"undefined\" && (exports.PoolLayer = PoolLayer);\n//# sourceMappingURL=jsNet.concat.js.map\n//# sourceMappingURL=jsNet.min.js.map\n"]}