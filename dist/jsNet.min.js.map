{"version":3,"sources":["jsNet.concat.js"],"names":["ConvLayer","[object Object]","size","filterSize","zeroPadding","stride","activation","this","undefined","NetMath","NetUtil","format","bind","state","layer","nextLayer","layerIndex","prevLayer","net","conv","FCLayer","channels","PoolLayer","activations","length","Math","floor","prevLayerOutWidth","max","sqrt","outMapSize","inMapValuesCount","pow","inZPMapValuesCount","Error","filters","Array","map","f","Filter","forEach","filter","weights","channelWeights","weightsRow","weightsInitFn","weightsConfig","activationMap","row","v","errorMap","bias","dropout","dropoutMap","init","updateFn","activationConfig","eluAlpha","getActivations","filterI","sumMap","convolve","input","sumY","sumX","random","emY","emX","weightIndex","neuronI","neurons","neuron","error","buildConvErrorMap","col","errors","buildConvDWeights","deltaBias","channel","deltaWeights","l2","l2Error","l1","l1Error","abs","weightUpdateFn","maxNorm","maxNormTotal","data","fi","window","exports","n","Neuron","weightsCount","ni","dropped","sum","ai","expected","derivative","reduce","p","c","wi","miniBatchSize","dwi","Layer","wRow","w","biasGain","weightGains","getWeightGain","column","setWeightGain","biasCache","weightsCache","getWeightsCache","setWeightsCache","adadeltaBiasCache","adadeltaCache","getAdadeltaCache","setAdadeltaCache","m","rreluSlope","value","prime","val","exp","lreluSlope","sech","tanh","elu","target","output","vi","log","calculated","desired","index","prev","curr","deltaValue","learningRate","weightI","newVal","min","rmsDecay","mt","iterations","vt","rho","limit","values","i","push","mean","stdDeviation","x1","x2","r","fanIn","fanOut","gaussian","lecunnormal","uniform","lecununiform","rowStart","colStart","filterRow","filterCol","indeces","slice","maxValue","exponentials","exponentialsSum","e","arr","avg","diffs","multiplier","layers","li","setWeight","getWeight","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","j","x","zP","extraRows","splice","vol","mapValues","d","inputVol","arrayToVolume","outputMap","paddedLength","fSSpread","di","addZeroPadding","inputY","inputX","weightsY","weightsX","outY","outX","paddedRow","nlFilterI","errMap","emYI","channelsCount","deltaDeltaWeights","channelI","inputValues","inputMap","arrayToMap","eY","eX","mapStartI","mapSize","returnArr","arguments","rowI","colI","Network","cost","pool","epochs","includes","distribution","every","item","Number","isInteger","initLayers","ceil","joinLayer","Object","assign","assignNext","assignPrev","console","warn","forward","backward","dataSet","callback","shuffle","Promise","resolve","reject","iterationIndex","epochsCounter","startTime","now","doEpoch","doIteration","hasOwnProperty","applyDeltaWeights","resetDeltaWeights","iterationError","elapsed","setTimeout","testSet","totalError","testInput","toJSON","fromJSON","version","constructor","name","maxPool","errs"],"mappings":"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","file":"jsNet.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n    constructor (size, {filterSize, zeroPadding, stride, activation}={}) {\r\n\r\n        if (filterSize)     this.filterSize = filterSize\r\n        if (stride)         this.stride = stride\r\n        if (size)           this.size = size\r\n\r\n        this.zeroPadding = zeroPadding\r\n\r\n        if (activation!=undefined) {\r\n\r\n            if (typeof activation==\"boolean\" && !activation) {\r\n                this.activation = false\r\n            } else {\r\n                this.activation = typeof activation==\"function\" ? activation : NetMath[NetUtil.format(activation)].bind(this)\r\n            }\r\n        }\r\n\r\n        this.state = \"not-initialised\"\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n\r\n        this.prevLayer = layer\r\n\r\n        this.layerIndex = layerIndex\r\n        this.size = this.size || 4\r\n        this.filterSize = this.filterSize || this.net.conv.filterSize || 3\r\n        this.stride = this.stride || this.net.conv.stride || 1\r\n\r\n        switch (true) {\r\n            case layer instanceof FCLayer:\r\n                this.channels = this.net.channels ||1\r\n                break\r\n\r\n            case layer instanceof ConvLayer:\r\n                this.channels = layer.size\r\n                break\r\n\r\n            case layer instanceof PoolLayer:\r\n                this.channels = layer.activations.length\r\n                break\r\n        }\r\n\r\n        if (this.zeroPadding==undefined) {\r\n            this.zeroPadding = this.net.conv.zeroPadding==undefined ? Math.floor(this.filterSize/2) : this.net.conv.zeroPadding\r\n        }\r\n\r\n        // Caching calculations\r\n        const prevLayerOutWidth = layer instanceof FCLayer ? Math.max(Math.floor(Math.sqrt(layer.size/this.channels)), 1)\r\n                                                           : layer.outMapSize\r\n\r\n        this.inMapValuesCount = Math.pow(prevLayerOutWidth, 2)\r\n        this.inZPMapValuesCount = Math.pow(prevLayerOutWidth + this.zeroPadding*2, 2)\r\n        this.outMapSize = (prevLayerOutWidth - this.filterSize + 2*this.zeroPadding) / this.stride + 1\r\n\r\n        if (this.outMapSize%1!=0) {\r\n            throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${this.outMapSize} in conv layer at index ${layerIndex}`)\r\n        }\r\n\r\n        this.filters = [...new Array(this.size)].map(f => new Filter())\r\n    }\r\n\r\n    init () {\r\n        this.filters.forEach(filter => {\r\n\r\n            filter.weights = [...new Array(this.channels)].map(channelWeights => {\r\n                return [...new Array(this.filterSize)].map(weightsRow => this.net.weightsInitFn(this.filterSize * (this.prevLayer.channels||1), this.weightsConfig))\r\n            })\r\n\r\n            filter.activationMap = [...new Array(this.outMapSize)].map(row => [...new Array(this.outMapSize)].map(v => 0))\r\n            filter.errorMap = [...new Array(this.outMapSize)].map(row => [...new Array(this.outMapSize)].map(v => 0))\r\n            filter.bias = 0\r\n\r\n            if (this.net.dropout != 1) {\r\n                filter.dropoutMap = filter.activationMap.map(row => row.map(v => false))\r\n            }\r\n\r\n            filter.init({\r\n                updateFn: this.net.updateFn,\r\n                activation: this.net.activationConfig,\r\n                eluAlpha: this.net.eluAlpha\r\n            })\r\n        })\r\n    }\r\n\r\n    forward () {\r\n\r\n        const activations = NetUtil.getActivations(this.prevLayer)\r\n\r\n        for (let filterI=0; filterI<this.size; filterI++) {\r\n\r\n            const filter = this.filters[filterI]\r\n\r\n            filter.sumMap = NetUtil.convolve({\r\n                input: activations,\r\n                zeroPadding: this.zeroPadding,\r\n                weights: filter.weights,\r\n                channels: this.channels,\r\n                stride: this.stride,\r\n                bias: filter.bias\r\n            })\r\n\r\n            for (let sumY=0; sumY<filter.sumMap.length; sumY++) {\r\n                for (let sumX=0; sumX<filter.sumMap.length; sumX++) {\r\n                    if (this.state==\"training\" && filter.dropoutMap && (filter.dropoutMap[sumY][sumX] = Math.random() > this.net.dropout)) {\r\n                        filter.activationMap[sumY][sumX] = 0\r\n                    } else if (this.activation) {\r\n                        filter.activationMap[sumY][sumX] = this.activation(filter.sumMap[sumY][sumX], false, filter) / (this.net.dropout||1)\r\n                    } else {\r\n                        filter.activationMap[sumY][sumX] = filter.sumMap[sumY][sumX]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    backward () {\r\n\r\n        // First, get the filters' error maps\r\n        if (this.nextLayer instanceof FCLayer) {\r\n\r\n            // For each filter, build the errorMap from the weighted neuron errors in the next FCLayer corresponding to each value in the activation map\r\n            for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n\r\n                const filter = this.filters[filterI]\r\n\r\n                for (let emY=0; emY<filter.errorMap.length; emY++) {\r\n                    for (let emX=0; emX<filter.errorMap.length; emX++) {\r\n\r\n                        const weightIndex = filterI * this.outMapSize**2 + emY * filter.errorMap.length + emX\r\n\r\n                        for (let neuronI=0; neuronI<this.nextLayer.neurons.length; neuronI++) {\r\n\r\n                            const neuron = this.nextLayer.neurons[neuronI]\r\n                            filter.errorMap[emY][emX] += neuron.error * neuron.weights[weightIndex]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if (this.nextLayer instanceof ConvLayer) {\r\n\r\n            for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n                NetUtil.buildConvErrorMap(this.nextLayer, this.filters[filterI].errorMap, filterI)\r\n            }\r\n\r\n        } else {\r\n\r\n            for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n\r\n                const filter = this.filters[filterI]\r\n\r\n                for (let row=0; row<filter.errorMap.length; row++) {\r\n                    for (let col=0; col<filter.errorMap.length; col++) {\r\n                        filter.errorMap[row][col] = this.nextLayer.errors[filterI][row][col]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply derivative to each error value\r\n        for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n\r\n            const filter = this.filters[filterI]\r\n\r\n            for (let row=0; row<filter.errorMap.length; row++) {\r\n                for (let col=0; col<filter.errorMap[0].length; col++) {\r\n\r\n                    if (filter.dropoutMap && filter.dropoutMap[row][col]) {\r\n                        filter.errorMap[row][col] = 0\r\n                    } else if (this.activation){\r\n                        filter.errorMap[row][col] *= this.activation(filter.sumMap[row][col], true, filter)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Then use the error map values to build the delta weights\r\n        NetUtil.buildConvDWeights(this)\r\n    }\r\n\r\n    resetDeltaWeights () {\r\n        for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n\r\n            const filter = this.filters[filterI]\r\n            filter.deltaBias = 0\r\n\r\n            for (let channel=0; channel<filter.deltaWeights.length; channel++) {\r\n                for (let row=0; row<filter.deltaWeights[0].length; row++) {\r\n                    for (let col=0; col<filter.deltaWeights[0][0].length; col++) {\r\n                        filter.deltaWeights[channel][row][col] = 0\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (filter.dropoutMap) {\r\n                for (let row=0; row<filter.dropoutMap.length; row++) {\r\n                    for (let col=0; col<filter.dropoutMap[0].length; col++) {\r\n                        filter.dropoutMap[row][col] = false\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    applyDeltaWeights () {\r\n        for (let filterI=0; filterI<this.filters.length; filterI++) {\r\n\r\n            const filter = this.filters[filterI]\r\n\r\n            for (let channel=0; channel<filter.deltaWeights.length; channel++) {\r\n                for (let row=0; row<filter.deltaWeights[0].length; row++) {\r\n                    for (let col=0; col<filter.deltaWeights[0][0].length; col++) {\r\n\r\n                        if (this.net.l2!=undefined) this.net.l2Error += 0.5 * this.net.l2 * filter.weights[channel][row][col]**2\r\n                        if (this.net.l1!=undefined) this.net.l1Error += this.net.l1 * Math.abs(filter.weights[channel][row][col])\r\n\r\n                        filter.weights[channel][row][col] = this.net.weightUpdateFn.bind(this.net, filter.weights[channel][row][col],\r\n                                                                filter.deltaWeights[channel][row][col], filter, [channel, row, col])()\r\n\r\n                        if (this.net.maxNorm!=undefined) this.net.maxNormTotal += filter.weights[channel][row][col]**2\r\n                    }\r\n                }\r\n            }\r\n\r\n            filter.bias = this.net.weightUpdateFn.bind(this.net, filter.bias, filter.deltaBias, filter)()\r\n        }\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.filters.map(filter => {\r\n                return {\r\n                    bias: filter.bias,\r\n                    weights: filter.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n        this.filters.forEach((filter, fi) => {\r\n\r\n            if (data.weights[fi].weights.length != filter.weights.length) {\r\n                throw new Error(`Mismatched weights depth. Given: ${data.weights[fi].weights.length} Existing: ${filter.weights.length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            if (data.weights[fi].weights[0].length != filter.weights[0].length) {\r\n                throw new Error(`Mismatched weights size. Given: ${data.weights[fi].weights[0].length} Existing: ${filter.weights[0].length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            filter.bias = data.weights[fi].bias\r\n            filter.weights = data.weights[fi].weights\r\n        })\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.ConvLayer = ConvLayer)\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.state = \"not-initialised\"\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach(neuron => {\r\n\r\n            let weightsCount\r\n\r\n            switch (true) {\r\n                case this.prevLayer instanceof FCLayer:\r\n                    weightsCount = this.prevLayer.size\r\n                    break\r\n\r\n                case this.prevLayer instanceof ConvLayer:\r\n                    weightsCount = this.prevLayer.filters.length * this.prevLayer.outMapSize**2\r\n                    break\r\n\r\n                case this.prevLayer instanceof PoolLayer:\r\n                    weightsCount = this.prevLayer.activations.length * this.prevLayer.outMapSize**2\r\n                    break\r\n            }\r\n\r\n            neuron.weights = this.net.weightsInitFn(weightsCount, this.weightsConfig)\r\n            neuron.bias = 0\r\n\r\n            neuron.init({\r\n                updateFn: this.net.updateFn,\r\n                activationConfig: this.net.activationConfig,\r\n                eluAlpha: this.net.eluAlpha\r\n            })\r\n        })\r\n    }\r\n\r\n    forward () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            if (this.state==\"training\" && (neuron.dropped = Math.random() > this.net.dropout)) {\r\n                neuron.activation = 0\r\n            } else {\r\n                neuron.sum = neuron.bias\r\n\r\n                const activations = NetUtil.getActivations(this.prevLayer)\r\n\r\n                for (let ai=0; ai<activations.length; ai++) {\r\n                    neuron.sum += activations[ai] * neuron.weights[ai]\r\n                }\r\n\r\n                neuron.activation = this.activation(neuron.sum, false, neuron) / (this.net.dropout||1)\r\n            }\r\n        })\r\n    }\r\n\r\n    backward (expected) {\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (neuron.dropped) {\r\n                neuron.error = 0\r\n                neuron.deltaBias = 0\r\n            } else {\r\n                if (typeof expected !== \"undefined\") {\r\n                    neuron.error = expected[ni] - neuron.activation\r\n                } else {\r\n                    neuron.derivative = this.activation(neuron.sum, true, neuron)\r\n                    neuron.error = neuron.derivative * this.nextLayer.neurons.map(n => n.error * (n.weights[ni]||0))\r\n                                                                             .reduce((p,c) => p+c, 0)\r\n                }\r\n\r\n                const activations = NetUtil.getActivations(this.prevLayer)\r\n\r\n                for (let wi=0; wi<neuron.weights.length; wi++) {\r\n                    neuron.deltaWeights[wi] += (neuron.error * activations[wi]) *\r\n                        (1 + (((this.net.l2||0)+(this.net.l1||0))/this.net.miniBatchSize) * neuron.deltaWeights[wi])\r\n                }\r\n\r\n                neuron.deltaBias = neuron.error\r\n            }\r\n        })\r\n    }\r\n\r\n    resetDeltaWeights () {\r\n        for (let n=0; n<this.neurons.length; n++) {\r\n            for (let dwi=0; dwi<this.neurons[n].deltaWeights.length; dwi++) {\r\n                this.neurons[n].deltaWeights[dwi] = 0\r\n            }\r\n        }\r\n    }\r\n\r\n    applyDeltaWeights () {\r\n        for (let n=0; n<this.neurons.length; n++) {\r\n\r\n            const neuron = this.neurons[n]\r\n\r\n            for (let dwi=0; dwi<this.neurons[n].deltaWeights.length; dwi++) {\r\n\r\n                if (this.net.l2!=undefined) this.net.l2Error += 0.5 * this.net.l2 * neuron.weights[dwi]**2\r\n                if (this.net.l1!=undefined) this.net.l1Error += this.net.l1 * Math.abs(neuron.weights[dwi])\r\n\r\n                neuron.weights[dwi] = this.net.weightUpdateFn.bind(this.net, neuron.weights[dwi], neuron.deltaWeights[dwi], neuron, dwi)()\r\n\r\n                if (this.net.maxNorm!=undefined) this.net.maxNormTotal += neuron.weights[dwi]**2\r\n            }\r\n\r\n            neuron.bias = this.net.weightUpdateFn.bind(this.net, neuron.bias, neuron.deltaBias, neuron)()\r\n        }\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=neuron.weights.length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\ntypeof window==\"undefined\" && (exports.FCLayer = exports.Layer = FCLayer)\r\n\"use strict\"\r\n\r\nclass Filter {\r\n\r\n    constructor () {}\r\n\r\n    init ({updateFn, activation, eluAlpha}={}) {\r\n\r\n        this.deltaWeights = this.weights.map(channel => channel.map(wRow => wRow.map(w => 0)))\r\n        this.deltaBias = 0\r\n\r\n        switch (updateFn) {\r\n\r\n            case \"gain\":\r\n                this.biasGain = 1\r\n                this.weightGains = this.weights.map(channel => channel.map(wRow => wRow.map(w => 1)))\r\n                this.getWeightGain = ([channel, row, column]) => this.weightGains[channel][row][column]\r\n                this.setWeightGain = ([channel, row, column], v) => this.weightGains[channel][row][column] = v\r\n                break\r\n\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                this.biasCache = 0\r\n                this.weightsCache = this.weights.map(channel => channel.map(wRow => wRow.map(w => 0)))\r\n                this.getWeightsCache = ([channel, row, column]) => this.weightsCache[channel][row][column]\r\n                this.setWeightsCache = ([channel, row, column], v) => this.weightsCache[channel][row][column] = v\r\n\r\n                if (updateFn==\"adadelta\") {\r\n                    this.adadeltaBiasCache = 0\r\n                    this.adadeltaCache = this.weights.map(channel => channel.map(wRow => wRow.map(w => 0)))\r\n                    this.getAdadeltaCache = ([channel, row, column]) => this.adadeltaCache[channel][row][column]\r\n                    this.setAdadeltaCache = ([channel, row, column], v) => this.adadeltaCache[channel][row][column] = v\r\n                }\r\n                break\r\n\r\n            case \"adam\":\r\n                this.m = 0\r\n                this.v = 0\r\n                break\r\n        }\r\n\r\n        if (activation==\"rrelu\") {\r\n            this.rreluSlope = Math.random() * 0.001\r\n\r\n        } else if (activation==\"elu\") {\r\n            this.eluAlpha = eluAlpha\r\n        }\r\n    }\r\n\r\n    getWeight ([channel, row, column]) {\r\n        return this.weights[channel][row][column]\r\n    }\r\n\r\n    setWeight ([channel, row, column], v) {\r\n        this.weights[channel][row][column] = v\r\n    }\r\n\r\n    getDeltaWeight ([channel, row, column]) {\r\n        return this.deltaWeights[channel][row][column]\r\n    }\r\n\r\n    setDeltaWeight ([channel, row, column], v) {\r\n        this.deltaWeights[channel][row][column] = v\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Filter = Filter)\r\n\r\n\r\n\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n\r\n    // Activation functions\r\n    static sigmoid (value, prime) {\r\n        const val = 1/(1+Math.exp(-value))\r\n        return prime ? val*(1-val)\r\n                     : val\r\n    }\r\n\r\n    static tanh (value, prime) {\r\n        const exp = Math.exp(2*value)\r\n        return prime ? 4/Math.pow(Math.exp(value)+Math.exp(-value), 2) || 1e-18\r\n                     : (exp-1)/(exp+1) || 1e-18\r\n    }\r\n\r\n    static relu (value, prime) {\r\n        return prime ? value > 0 ? 1 : 0\r\n                     : Math.max(value, 0)\r\n    }\r\n\r\n    static lrelu (value, prime) {\r\n        return prime ? value > 0 ? 1 : (this.lreluSlope || -0.0005)\r\n                     : Math.max((this.lreluSlope || -0.0005)*Math.abs(value), value)\r\n    }\r\n\r\n    static rrelu (value, prime, neuron) {\r\n        return prime ? value > 0 ? 1 : neuron.rreluSlope\r\n                     : Math.max(neuron.rreluSlope, value)\r\n    }\r\n\r\n    static lecuntanh (value, prime) {\r\n        return prime ? 1.15333 * Math.pow(NetMath.sech((2/3) * value), 2)\r\n                     : 1.7159 * NetMath.tanh((2/3) * value)\r\n    }\r\n\r\n    static elu (value, prime, neuron) {\r\n        return prime ? value >=0 ? 1 : NetMath.elu(value, false, neuron) + neuron.eluAlpha\r\n                     : value >=0 ? value : neuron.eluAlpha * (Math.exp(value) - 1)\r\n    }\r\n\r\n    // Cost functions\r\n    static crossentropy (target, output) {\r\n        return output.map((value, vi) => target[vi] * Math.log(value+1e-15) + ((1-target[vi]) * Math.log((1+1e-15)-value)))\r\n                     .reduce((p,c) => p-c, 0)\r\n    }\r\n\r\n    static meansquarederror (calculated, desired) {\r\n        return calculated.map((output, index) => Math.pow(output - desired[index], 2))\r\n                         .reduce((prev, curr) => prev+curr, 0) / calculated.length\r\n    }\r\n\r\n    // Weight updating functions\r\n    static vanillaupdatefn (value, deltaValue) {\r\n        return value + this.learningRate * deltaValue\r\n    }\r\n\r\n    static gain (value, deltaValue, neuron, weightI) {\r\n\r\n        const newVal = value + this.learningRate * deltaValue * (weightI==null ? neuron.biasGain : neuron.getWeightGain(weightI))\r\n\r\n        if (newVal<=0 && value>0 || newVal>=0 && value<0){\r\n            if (weightI!=null) {\r\n                neuron.setWeightGain(weightI, Math.max(neuron.getWeightGain(weightI)*0.95, 0.5))\r\n            } else {\r\n                neuron.biasGain = Math.max(neuron.biasGain*0.95, 0.5)\r\n            }\r\n        } else {\r\n            if (weightI!=null) {\r\n                neuron.setWeightGain(weightI, Math.min(neuron.getWeightGain(weightI)+0.05, 5))\r\n            } else {\r\n                neuron.biasGain = Math.min(neuron.biasGain+0.05, 5)\r\n            }\r\n        }\r\n\r\n        return newVal\r\n    }\r\n\r\n    static adagrad (value, deltaValue, neuron, weightI) {\r\n\r\n        if (weightI!=null) {\r\n            neuron.setWeightsCache(weightI, neuron.getWeightsCache(weightI) + Math.pow(deltaValue, 2))\r\n        } else {\r\n            neuron.biasCache += Math.pow(deltaValue, 2)\r\n        }\r\n\r\n        return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI!=null ? neuron.getWeightsCache(weightI)\r\n                                                                                        : neuron.biasCache))\r\n    }\r\n\r\n    static rmsprop (value, deltaValue, neuron, weightI) {\r\n\r\n        if (weightI!=null) {\r\n            neuron.setWeightsCache(weightI, this.rmsDecay * neuron.getWeightsCache(weightI) + (1 - this.rmsDecay) * Math.pow(deltaValue, 2))\r\n        } else {\r\n            neuron.biasCache = this.rmsDecay * neuron.biasCache + (1 - this.rmsDecay) * Math.pow(deltaValue, 2)\r\n        }\r\n\r\n        return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI!=null ? neuron.getWeightsCache(weightI)\r\n                                                                                        : neuron.biasCache))\r\n    }\r\n\r\n    static adam (value, deltaValue, neuron) {\r\n\r\n        neuron.m = 0.9*neuron.m + (1-0.9) * deltaValue\r\n        const mt = neuron.m / (1-Math.pow(0.9, this.iterations + 1))\r\n\r\n        neuron.v = 0.999*neuron.v + (1-0.999) * Math.pow(deltaValue, 2)\r\n        const vt = neuron.v / (1-Math.pow(0.999, this.iterations + 1))\r\n\r\n        return value + this.learningRate * mt / (Math.sqrt(vt) + 1e-8)\r\n    }\r\n\r\n    static adadelta (value, deltaValue, neuron, weightI) {\r\n\r\n        if (weightI!=null) {\r\n            neuron.setWeightsCache(weightI, this.rho * neuron.getWeightsCache(weightI) + (1-this.rho) * Math.pow(deltaValue, 2))\r\n            const newVal = value + Math.sqrt((neuron.getAdadeltaCache(weightI) + 1e-6)/(neuron.getWeightsCache(weightI) + 1e-6)) * deltaValue\r\n            neuron.setAdadeltaCache(weightI, this.rho * neuron.getAdadeltaCache(weightI) + (1-this.rho) * Math.pow(deltaValue, 2))\r\n            return newVal\r\n\r\n        } else {\r\n            neuron.biasCache = this.rho * neuron.biasCache + (1-this.rho) * Math.pow(deltaValue, 2)\r\n            const newVal = value + Math.sqrt((neuron.adadeltaBiasCache + 1e-6)/(neuron.biasCache + 1e-6)) * deltaValue\r\n            neuron.adadeltaBiasCache = this.rho * neuron.adadeltaBiasCache + (1-this.rho) * Math.pow(deltaValue, 2)\r\n            return newVal\r\n        }\r\n    }\r\n\r\n    // Weights init\r\n    static uniform (size, {limit}) {\r\n        const values = []\r\n\r\n        for (let i=0; i<size; i++) {\r\n            values.push(Math.random()*2*limit-limit)\r\n        }\r\n\r\n        return values\r\n    }\r\n\r\n    static gaussian (size, {mean, stdDeviation}) {\r\n        const values = []\r\n\r\n        // Polar Box Muller\r\n        for (let i=0; i<size; i++) {\r\n            let x1, x2, r\r\n\r\n            do {\r\n                x1 = 2 * Math.random() -1\r\n                x2 = 2 * Math.random() -1\r\n                r = x1**2 + x2**2\r\n            } while (r >= 1 || !r)\r\n\r\n            values.push(mean + (x1 * (Math.sqrt(-2 * Math.log(r) / r))) * stdDeviation)\r\n        }\r\n\r\n        return values\r\n    }\r\n\r\n    static xaviernormal (size, {fanIn, fanOut}) {\r\n        return fanOut || fanOut==0 ? NetMath.gaussian(size, {mean: 0, stdDeviation: Math.sqrt(2/(fanIn+fanOut))})\r\n                                   : NetMath.lecunnormal(size, {fanIn})\r\n    }\r\n\r\n    static xavieruniform (size, {fanIn, fanOut}) {\r\n        return fanOut || fanOut==0 ? NetMath.uniform(size, {limit: Math.sqrt(6/(fanIn+fanOut))})\r\n                                   : NetMath.lecununiform(size, {fanIn})\r\n    }\r\n\r\n    static lecunnormal (size, {fanIn}) {\r\n        return NetMath.gaussian(size, {mean: 0, stdDeviation: Math.sqrt(1/fanIn)})\r\n    }\r\n\r\n    static lecununiform (size, {fanIn}) {\r\n        return NetMath.uniform(size, {limit: Math.sqrt(3/fanIn)})\r\n    }\r\n\r\n    // Pool\r\n    static maxPool (layer, channel) {\r\n\r\n        const activations = NetUtil.getActivations(layer.prevLayer, channel, layer.inMapValuesCount)\r\n\r\n        for (let row=0; row<layer.outMapSize; row++) {\r\n            for (let col=0; col<layer.outMapSize; col++) {\r\n\r\n                const rowStart = row * layer.stride\r\n                const colStart = col * layer.stride\r\n\r\n                // The first value\r\n                let activation = activations[rowStart*layer.prevLayerOutWidth + colStart]\r\n\r\n                for (let filterRow=0; filterRow<layer.size; filterRow++) {\r\n                    for (let filterCol=0; filterCol<layer.size; filterCol++) {\r\n\r\n                        const value = activations[ ((rowStart+filterRow) * layer.prevLayerOutWidth) + (colStart+filterCol) ]\r\n\r\n                        if (value > activation) {\r\n                            activation = value\r\n                            layer.indeces[channel][row][col] = [filterRow, filterCol]\r\n                        }\r\n                    }\r\n                }\r\n\r\n                layer.activations[channel][row][col] = activation\r\n            }\r\n        }\r\n    }\r\n\r\n    // Other\r\n    static softmax (v) {\r\n\r\n        const values = v.slice(0)\r\n        let maxValue = values[0]\r\n\r\n        for (let i=1; i<values.length; i++) {\r\n            if (values[i] > maxValue) {\r\n                maxValue = values[i]\r\n            }\r\n        }\r\n\r\n        // Exponentials\r\n        const exponentials = new Array(values.length)\r\n        let exponentialsSum = 0.0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            let e = Math.exp(values[i] - maxValue)\r\n            exponentialsSum += e\r\n            exponentials[i] = e\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            exponentials[i] /= exponentialsSum\r\n            values[i] = exponentials[i]\r\n        }\r\n\r\n        return values\r\n    }\r\n\r\n    static sech (value) {\r\n        return (2*Math.exp(-value))/(1+Math.exp(-2*value))\r\n    }\r\n\r\n    static standardDeviation (arr) {\r\n        const avg = arr.reduce((p,c) => p+c) / arr.length\r\n        const diffs = arr.map(v => v - avg).map(v => v**2)\r\n        return Math.sqrt(diffs.reduce((p,c) => p+c) / diffs.length)\r\n    }\r\n\r\n    static maxNorm () {\r\n\r\n        if (this.maxNormTotal > this.maxNorm) {\r\n\r\n            const multiplier = this.maxNorm / (1e-18 + this.maxNormTotal)\r\n\r\n            this.layers.forEach((layer, li) => {\r\n                li && layer.neurons.forEach(neuron => {\r\n                    neuron.weights.forEach((w, wi) => neuron.setWeight(wi, neuron.getWeight(wi) * multiplier))\r\n                })\r\n            })\r\n        }\r\n\r\n        this.maxNormTotal = 0\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetMath = NetMath)\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static shuffle (arr) {\r\n        for (let i=arr.length; i; i--) {\r\n            const j = Math.floor(Math.random() * i)\r\n            const x = arr[i-1]\r\n            arr[i-1] = arr[j]\r\n            arr[j] = x\r\n        }\r\n    }\r\n\r\n    static addZeroPadding (map, zP) {\r\n\r\n        const data = []\r\n\r\n        for (let row=0; row<map.length; row++) {\r\n            data.push(map[row].slice(0))\r\n        }\r\n\r\n        const extraRows = []\r\n\r\n        for (let i=0; i<data.length+2*zP; i++) {\r\n            extraRows.push(0)\r\n        }\r\n\r\n        for (let col=0; col<data.length; col++) {\r\n            for (let i=0; i<zP; i++) {\r\n                data[col].splice(0, 0, 0)\r\n                data[col].splice(data[col].length+1, data[col].length, 0)\r\n            }\r\n        }\r\n\r\n        for (let i=0; i<zP; i++) {\r\n            data.splice(0, 0, extraRows.slice(0))\r\n            data.splice(data.length, data.length-1, extraRows.slice(0))\r\n        }\r\n\r\n        return data\r\n    }\r\n\r\n    static arrayToMap (arr, size) {\r\n        const map = []\r\n\r\n        for (let i=0; i<size; i++) {\r\n            map[i] = []\r\n\r\n            for (let j=0; j<size; j++) {\r\n                map[i][j] = arr[i*size+j]\r\n            }\r\n        }\r\n\r\n        return map\r\n    }\r\n\r\n    static arrayToVolume (arr, channels) {\r\n\r\n        const vol = []\r\n        const size = Math.sqrt(arr.length/channels)\r\n        const mapValues = size**2\r\n\r\n        for (let d=0; d<Math.floor(arr.length/mapValues); d++) {\r\n\r\n            const map = []\r\n\r\n            for (let i=0; i<size; i++) {\r\n                map[i] = []\r\n\r\n                for (let j=0; j<size; j++) {\r\n                    map[i][j] = arr[d*mapValues  + i*size+j]\r\n                }\r\n            }\r\n\r\n            vol[d] = map\r\n        }\r\n\r\n        return vol\r\n    }\r\n\r\n    static convolve ({input, zeroPadding, weights, channels, stride, bias}) {\n\r\n        const inputVol = NetUtil.arrayToVolume(input, channels)\n        const outputMap = []\r\n\r\n        const paddedLength = inputVol[0].length + zeroPadding*2\n        const fSSpread = Math.floor(weights[0].length / 2)\n\r\n        // For each input channel,\r\n        for (let di=0; di<channels; di++) {\n            inputVol[di] = NetUtil.addZeroPadding(inputVol[di], zeroPadding)\n            // For each inputY without ZP\r\n            for (let inputY=fSSpread; inputY<paddedLength-fSSpread; inputY+=stride) {\n                outputMap[(inputY-fSSpread)/stride] = outputMap[(inputY-fSSpread)/stride] || []\n                // For each inputX without zP\r\n                for (let inputX=fSSpread; inputX<paddedLength-fSSpread; inputX+=stride) {\n                    let sum = 0\n                    // For each weightsY on input\r\n                    for (let weightsY=0; weightsY<weights[0].length; weightsY++) {\r\n                        // For each weightsX on input\r\n                        for (let weightsX=0; weightsX<weights[0].length; weightsX++) {\r\n                            sum += inputVol[di][inputY+(weightsY-fSSpread)][inputX+(weightsX-fSSpread)] * weights[di][weightsY][weightsX]\n                        }\r\n                    }\r\n\r\n                    outputMap[(inputY-fSSpread)/stride][(inputX-fSSpread)/stride] = (outputMap[(inputY-fSSpread)/stride][(inputX-fSSpread)/stride]||0) + sum\n                }\r\n            }\r\n        }\n\r\n        // Then add bias\r\n        for (let outY=0; outY<outputMap.length; outY++) {\n            for (let outX=0; outX<outputMap.length; outX++) {\n                outputMap[outY][outX] += bias\n            }\n        }\n\r\n        return outputMap\r\n    }\r\n\r\n    static buildConvErrorMap (nextLayer, errorMap, filterI) {\r\n\r\n        // Cache / convenience\r\n        const zeroPadding = nextLayer.zeroPadding\r\n        const paddedLength = errorMap.length + zeroPadding*2\r\n        const fSSpread = Math.floor(nextLayer.filterSize / 2)\r\n\r\n        // Zero pad and clear the error map, to allow easy convoling\r\n        const paddedRow = []\r\n\r\n        for (let val=0; val<paddedLength; val++) {\r\n            paddedRow.push(0)\r\n        }\r\n\r\n        for (let row=0; row<paddedLength; row++) {\r\n            errorMap[row] = paddedRow.slice(0)\r\n        }\r\n\r\n        // For each channel in filter in the next layer which corresponds to this filter\r\n        for (let nlFilterI=0; nlFilterI<nextLayer.size; nlFilterI++) {\r\n\r\n            const weights = nextLayer.filters[nlFilterI].weights[filterI]\r\n            const errMap = nextLayer.filters[nlFilterI].errorMap\r\n\r\n            // Unconvolve their error map using the weights\r\n            for (let inputY=fSSpread; inputY<paddedLength - fSSpread; inputY+=nextLayer.stride) {\r\n                for (let inputX=fSSpread; inputX<paddedLength - fSSpread; inputX+=nextLayer.stride) {\r\n\r\n                    for (let weightsY=0; weightsY<nextLayer.filterSize; weightsY++) {\r\n                        for (let weightsX=0; weightsX<nextLayer.filterSize; weightsX++) {\r\n                            errorMap[inputY+(weightsY-fSSpread)][inputX+(weightsX-fSSpread)] += weights[weightsY][weightsX]\r\n                                * errMap[(inputY-fSSpread)/nextLayer.stride][(inputX-fSSpread)/nextLayer.stride]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Take out the zero padding. Rows:\r\n        errorMap.splice(0, zeroPadding)\r\n        errorMap.splice(errorMap.length-zeroPadding, errorMap.length)\r\n\r\n        // Columns:\r\n        for (let emYI=0; emYI<errorMap.length; emYI++) {\r\n            errorMap[emYI] = errorMap[emYI].splice(zeroPadding, errorMap[emYI].length - zeroPadding*2)\r\n        }\r\n    }\r\n\r\n    static buildConvDWeights (layer) {\r\n\r\n        const weightsCount = layer.filters[0].weights[0].length\r\n        const fSSpread = Math.floor(weightsCount / 2)\r\n        const channelsCount = layer.filters[0].weights.length\r\n\r\n        // Adding an intermediary step to allow regularization to work\r\n        const deltaDeltaWeights = []\r\n\r\n        // Filling the deltaDeltaWeights with 0 values\r\n        for (let weightsY=0; weightsY<weightsCount; weightsY++) {\r\n            deltaDeltaWeights[weightsY] = []\r\n            for (let weightsX=0; weightsX<weightsCount; weightsX++) {\r\n                deltaDeltaWeights[weightsY][weightsX] = 0\r\n            }\r\n        }\r\n\r\n        // For each filter\r\n        for (let filterI=0; filterI<layer.filters.length; filterI++) {\r\n\r\n            const filter = layer.filters[filterI]\r\n\r\n            // Each channel will take the error map and the corresponding inputMap from the input...\r\n            for (let channelI=0; channelI<channelsCount; channelI++) {\r\n\r\n                const inputValues = NetUtil.getActivations(layer.prevLayer, channelI, layer.inMapValuesCount)\r\n                const inputMap = NetUtil.addZeroPadding(NetUtil.arrayToMap(inputValues, Math.sqrt(layer.inMapValuesCount)), layer.zeroPadding)\r\n\r\n                // ...slide the filter with correct stride across the zero-padded inputMap...\r\n                for (let inputY=fSSpread; inputY<inputMap.length-fSSpread; inputY+=layer.stride) {\r\n                    for (let inputX=fSSpread; inputX<inputMap.length-fSSpread; inputX+=layer.stride) {\r\n\r\n                        // ...and at each location...\r\n                        for (let weightsY=0; weightsY<weightsCount; weightsY++) {\r\n                            for (let weightsX=0; weightsX<weightsCount; weightsX++) {\r\n\r\n                                const activation = inputMap[inputY-fSSpread+weightsY][inputX-fSSpread+weightsX]\r\n\r\n                                // Increment and regularize the delta delta weights by the input activation (later multiplied by the error)\r\n                                deltaDeltaWeights[weightsY][weightsX] += activation *\r\n                                     (1 + (((layer.net.l2||0)+(layer.net.l1||0))/layer.net.miniBatchSize) * filter.weights[channelI][weightsY][weightsX])\r\n                            }\r\n                        }\r\n\r\n                        const error = filter.errorMap[(inputY-fSSpread)/layer.stride][(inputX-fSSpread)/layer.stride]\r\n\r\n                        // Applying and resetting the deltaDeltaWeights\r\n                        for (let weightsY=0; weightsY<weightsCount; weightsY++) {\r\n                            for (let weightsX=0; weightsX<weightsCount; weightsX++) {\r\n                                filter.deltaWeights[channelI][weightsY][weightsX] += deltaDeltaWeights[weightsY][weightsX] * error\r\n                                deltaDeltaWeights[weightsY][weightsX] = 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Increment the deltaBias by the sum of all errors in the filter\r\n            for (let eY=0; eY<filter.errorMap.length; eY++) {\r\n                for (let eX=0; eX<filter.errorMap.length; eX++) {\r\n                    filter.deltaBias += filter.errorMap[eY][eX]\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static getActivations (layer, mapStartI, mapSize){\r\n\r\n        const returnArr = []\r\n\r\n        if (arguments.length==1) {\r\n\r\n            if (layer instanceof FCLayer) {\r\n\r\n                for (let ni=0; ni<layer.neurons.length; ni++) {\r\n                    returnArr.push(layer.neurons[ni].activation)\r\n                }\r\n\r\n            } else if (layer instanceof ConvLayer) {\r\n\r\n                for (let fi=0; fi<layer.filters.length; fi++) {\r\n                    for (let rowI=0; rowI<layer.filters[fi].activationMap.length; rowI++) {\r\n                        for (let colI=0; colI<layer.filters[fi].activationMap[rowI].length; colI++) {\r\n                            returnArr.push(layer.filters[fi].activationMap[rowI][colI])\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } else {\r\n\r\n                for (let channel=0; channel<layer.activations.length; channel++) {\r\n                    for (let row=0; row<layer.activations[0].length; row++) {\r\n                        for (let col=0; col<layer.activations[0].length; col++) {\r\n                            returnArr.push(layer.activations[channel][row][col])\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n\r\n            if (layer instanceof FCLayer) {\r\n\r\n                for (let i=mapStartI*mapSize; i<(mapStartI+1)*mapSize; i++) {\r\n                    returnArr.push(layer.neurons[i].activation)\r\n                }\r\n\r\n            } else if (layer instanceof ConvLayer) {\r\n\r\n                for (let row=0; row<layer.filters[mapStartI].activationMap.length; row++) {\r\n                    for (let col=0; col<layer.filters[mapStartI].activationMap[row].length; col++) {\r\n                        returnArr.push(layer.filters[mapStartI].activationMap[row][col])\r\n                    }\r\n                }\r\n\r\n            } else {\r\n\r\n                for (let row=0; row<layer.activations[mapStartI].length; row++) {\r\n                    for (let col=0; col<layer.activations[mapStartI].length; col++) {\r\n                        returnArr.push(layer.activations[mapStartI][row][col])\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return returnArr\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetUtil = NetUtil)\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({learningRate, layers=[], updateFn=\"vanillaupdatefn\", activation=\"sigmoid\", cost=\"meansquarederror\",\r\n        rmsDecay, rho, lreluSlope, eluAlpha, dropout=1, l2=true, l1=true, maxNorm, weightsConfig, channels, conv, pool}={}) {\r\n\r\n        this.state = \"not-defined\"\r\n        this.layers = []\r\n        this.conv = {}\r\n        this.pool = {}\r\n        this.epochs = 0\r\n        this.iterations = 0\r\n        this.dropout = dropout==false ? 1 : dropout\r\n        this.error = 0\r\n        activation = NetUtil.format(activation)\r\n        updateFn = NetUtil.format(updateFn)\r\n        cost = NetUtil.format(cost)\r\n\r\n        if (l2) {\r\n            this.l2 = typeof l2==\"boolean\" ? 0.001 : l2\r\n            this.l2Error = 0\r\n        }\r\n\r\n        if (l1) {\r\n            this.l1 = typeof l1==\"boolean\" ? 0.005 : l1\r\n            this.l1Error = 0\r\n        }\r\n\r\n        if (maxNorm) {\r\n            this.maxNorm = typeof maxNorm==\"boolean\" && maxNorm ? 1000 : maxNorm\r\n            this.maxNormTotal = 0\r\n        }\r\n\r\n        if (learningRate)   this.learningRate = learningRate\r\n        if (channels)       this.channels = channels\r\n\r\n        if (conv) {\r\n            if (conv.filterSize!=undefined)     this.conv.filterSize = conv.filterSize\r\n            if (conv.zeroPadding!=undefined)    this.conv.zeroPadding = conv.zeroPadding\r\n            if (conv.stride!=undefined)         this.conv.stride = conv.stride\r\n        }\r\n\r\n        if (pool) {\r\n            if (pool.size)      this.pool.size = pool.size\r\n            if (pool.stride)    this.pool.stride = pool.stride\r\n        }\r\n\r\n        // Activation function / Learning Rate\r\n        switch (updateFn) {\r\n\r\n            case \"rmsprop\":\r\n                this.learningRate = this.learningRate==undefined ? 0.001 : this.learningRate\r\n                break\r\n\r\n            case \"adam\":\r\n                this.learningRate = this.learningRate==undefined ? 0.01 : this.learningRate\r\n                break\r\n\r\n            case \"adadelta\":\r\n                this.rho = rho==null ? 0.95 : rho\r\n                break\r\n\r\n            default:\r\n\r\n                if (this.learningRate==undefined) {\r\n\r\n                    switch (activation) {\r\n\r\n                        case \"relu\":\r\n                        case \"lrelu\":\r\n                        case \"rrelu\":\r\n                        case \"elu\":\r\n                            this.learningRate = 0.01\r\n                            break\r\n\r\n                        case \"tanh\":\r\n                        case \"lecuntanh\":\r\n                            this.learningRate = 0.001\r\n                            break\r\n\r\n                        default:\r\n                            this.learningRate = 0.2\r\n                    }\r\n                }\r\n        }\r\n\r\n        this.updateFn = [false, null, undefined].includes(updateFn) ? \"vanillaupdatefn\" : updateFn\r\n        this.weightUpdateFn = NetMath[this.updateFn]\r\n        this.activation = typeof activation==\"function\" ? activation : NetMath[activation].bind(this)\r\n        this.activationConfig = activation\r\n        this.cost = typeof cost==\"function\" ? cost : NetMath[cost]\r\n\r\n        if (this.updateFn==\"rmsprop\") {\r\n            this.rmsDecay = rmsDecay==undefined ? 0.99 : rmsDecay\r\n        }\r\n\r\n        this.lreluSlope = lreluSlope==undefined ? -0.0005 : lreluSlope\r\n        this.eluAlpha = eluAlpha==undefined ? 1 : eluAlpha\r\n\r\n        // Weights distributiom\r\n        this.weightsConfig = {distribution: \"xavieruniform\"}\r\n\r\n        if (weightsConfig != undefined && weightsConfig.distribution) {\r\n            this.weightsConfig.distribution = NetUtil.format(weightsConfig.distribution)\r\n        }\r\n\r\n        if (this.weightsConfig.distribution == \"uniform\") {\r\n            this.weightsConfig.limit = weightsConfig && weightsConfig.limit!=undefined ? weightsConfig.limit : 0.1\r\n\r\n        } else if (this.weightsConfig.distribution == \"gaussian\") {\r\n            this.weightsConfig.mean = weightsConfig.mean || 0\r\n            this.weightsConfig.stdDeviation = weightsConfig.stdDeviation || 0.05\r\n        }\r\n\r\n        if (typeof this.weightsConfig.distribution==\"function\") {\r\n            this.weightsInitFn = this.weightsConfig.distribution\r\n        } else {\r\n            this.weightsInitFn = NetMath[this.weightsConfig.distribution]\r\n        }\r\n\r\n        if (layers.length) {\r\n\r\n            switch (true) {\r\n\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.state = \"constructed\"\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.state = \"constructed\"\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        switch (this.state) {\r\n\r\n            case \"initialised\":\r\n                return\r\n\r\n            case \"not-defined\":\r\n                this.layers[0] = new FCLayer(input)\r\n                this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                          : input + expected))\r\n                this.layers[2] = new FCLayer(Math.ceil(expected))\r\n                break\r\n        }\r\n\r\n        this.layers.forEach(this.joinLayer.bind(this))\r\n        this.state = \"initialised\"\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.net = this\r\n        layer.activation = layer.activation==undefined ? this.activation : layer.activation\r\n\r\n        layer.weightsConfig = {}\r\n        Object.assign(layer.weightsConfig, this.weightsConfig)\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.layers[layerIndex-1], layerIndex)\r\n\r\n            layer.weightsConfig.fanIn = layer.prevLayer.size\r\n            layer.prevLayer.weightsConfig.fanOut = layer.size\r\n\r\n            layer.init()\r\n            layer.state = \"initialised\"\r\n        }\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        this.layers[0].neurons.forEach((neuron, ni) => neuron.activation = data[ni])\r\n        this.layers.forEach((layer, li) => li && layer.forward())\r\n        return this.layers[this.layers.length-1].neurons.map(n => n.activation)\r\n    }\r\n\r\n    backward (expected) {\r\n\r\n        if (expected === undefined) {\r\n            throw new Error(\"No data passed to Network.backward()\")\r\n        }\r\n\r\n        if (expected.length != this.layers[this.layers.length-1].neurons.length) {\r\n            console.warn(\"Expected data length did not match output layer neurons count.\", expected)\r\n        }\r\n\r\n        this.layers[this.layers.length-1].backward(expected)\r\n\r\n        for (let layerIndex=this.layers.length-2; layerIndex>0; layerIndex--) {\r\n            this.layers[layerIndex].backward()\r\n        }\r\n    }\r\n\r\n    train (dataSet, {epochs=1, callback, log=true, miniBatchSize=1, shuffle=false}={}) {\r\n\r\n        this.miniBatchSize = typeof miniBatchSize==\"boolean\" && miniBatchSize ? dataSet[0].expected.length : miniBatchSize\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (shuffle) {\r\n                NetUtil.shuffle(dataSet)\r\n            }\r\n\r\n            if (log) {\r\n                console.log(`Training started. Epochs: ${epochs} Batch Size: ${this.miniBatchSize}`)\r\n            }\r\n\r\n            if (dataSet === undefined || dataSet === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                // this.initLayers(dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length)\r\n                this.initLayers.bind(this, dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length)()\r\n            }\r\n\r\n            this.layers.forEach(layer => layer.state = \"training\")\r\n\r\n            let iterationIndex = 0\r\n            let epochsCounter = 0\r\n            const startTime = Date.now()\r\n\r\n            const doEpoch = () => {\r\n                this.epochs++\r\n                this.error = 0\r\n                iterationIndex = 0\r\n\r\n                if (this.l2Error!=undefined) this.l2Error = 0\r\n                if (this.l1Error!=undefined) this.l1Error = 0\r\n\r\n                doIteration()\r\n            }\r\n\r\n            const doIteration = () => {\r\n\r\n                if (!dataSet[iterationIndex].hasOwnProperty(\"input\") || (!dataSet[iterationIndex].hasOwnProperty(\"expected\") && !dataSet[iterationIndex].hasOwnProperty(\"output\"))) {\r\n                    return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\")\r\n                }\r\n\r\n                const input = dataSet[iterationIndex].input\r\n                const output = this.forward(input)\r\n                const target = dataSet[iterationIndex].expected || dataSet[iterationIndex].output\r\n\r\n                this.backward(target)\r\n\r\n                if (++iterationIndex%this.miniBatchSize==0) {\r\n                    this.applyDeltaWeights()\r\n                    this.resetDeltaWeights()\r\n                } else if (iterationIndex >= dataSet.length) {\r\n                    this.applyDeltaWeights()\r\n                }\r\n\r\n                const iterationError = this.cost(target, output)\r\n                const elapsed = Date.now() - startTime\r\n                this.error += iterationError\r\n                this.iterations++\r\n\r\n                if (typeof callback==\"function\") {\r\n                    callback({\r\n                        iterations: this.iterations,\r\n                        error: iterationError,\r\n                        elapsed, input\r\n                    })\r\n                }\r\n\r\n                if (iterationIndex < dataSet.length) {\r\n                    setTimeout(doIteration.bind(this), 0)\r\n\r\n                } else {\r\n                    epochsCounter++\r\n\r\n                    if (log) {\r\n                        console.log(`Epoch: ${this.epochs} Error: ${this.error/iterationIndex}${this.l2==undefined ? \"\": ` L2 Error: ${this.l2Error/iterationIndex}`}`,\r\n                                    `\\nElapsed: ${NetUtil.format(elapsed, \"time\")} Average Duration: ${NetUtil.format(elapsed/epochsCounter, \"time\")}`)\r\n                    }\r\n\r\n                    if (epochsCounter < epochs) {\r\n                        doEpoch()\r\n                    } else {\r\n                        this.layers.forEach(layer => layer.state = \"initialised\")\r\n\r\n                        if (log) {\r\n                            console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex, \"time\")}`)\r\n                        }\r\n                        resolve()\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.resetDeltaWeights()\r\n            doEpoch()\r\n        })\r\n    }\r\n\r\n    test (testSet, {log=true, callback}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (testSet === undefined || testSet === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            let totalError = 0\r\n            let iterationIndex = 0\r\n            const startTime = Date.now()\r\n\r\n            const testInput = () => {\r\n\r\n                const input = testSet[iterationIndex].input\r\n                const output = this.forward(input)\r\n                const target = testSet[iterationIndex].expected || testSet[iterationIndex].output\r\n                const elapsed = Date.now() - startTime\r\n\r\n                const iterationError = this.cost(target, output)\r\n                totalError += iterationError\r\n                iterationIndex++\r\n\r\n                if (typeof callback==\"function\") {\r\n                    callback({\r\n                        iterations: iterationIndex,\r\n                        error: iterationError,\r\n                        elapsed, input\r\n                    })\r\n                }\r\n\r\n                if (iterationIndex < testSet.length) {\r\n                    setTimeout(testInput.bind(this), 0)\r\n\r\n                } else {\r\n\r\n                    if (log) {\r\n                        console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex, \"time\")}`)\r\n                    }\r\n\r\n                    resolve(totalError/testSet.length)\r\n                }\r\n            }\r\n            testInput()\r\n        })\r\n    }\r\n\r\n    resetDeltaWeights () {\r\n        this.layers.forEach((layer, li) => li && layer.resetDeltaWeights())\r\n    }\r\n\r\n    applyDeltaWeights () {\r\n\r\n        this.layers.forEach((layer, li) => li && layer.applyDeltaWeights())\r\n\r\n        if (this.maxNorm!=undefined) {\r\n            this.maxNormTotal = Math.sqrt(this.maxNormTotal)\r\n            NetMath.maxNorm.bind(this)()\r\n        }\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.resetDeltaWeights()\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    static get version () {\r\n        return \"2.1.1\"\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Network = Network)\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init ({updateFn, activation, eluAlpha}={}) {\r\n\r\n        const size = this.weights.length\r\n        this.deltaWeights = this.weights.map(v => 0)\r\n\r\n        switch (updateFn) {\r\n\r\n            case \"gain\":\r\n                this.biasGain = 1\r\n                this.weightGains = [...new Array(size)].map(v => 1)\r\n                this.getWeightGain = i => this.weightGains[i]\r\n                this.setWeightGain = (i,v) => this.weightGains[i] = v\r\n                break\r\n\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                this.biasCache = 0\r\n                this.weightsCache = [...new Array(size)].map(v => 0)\r\n                this.getWeightsCache = i => this.weightsCache[i]\r\n                this.setWeightsCache = (i,v) => this.weightsCache[i] = v\r\n\r\n                if (updateFn==\"adadelta\") {\r\n                    this.adadeltaBiasCache = 0\r\n                    this.adadeltaCache = [...new Array(size)].map(v => 0)\r\n                    this.getAdadeltaCache = i => this.adadeltaCache[i]\r\n                    this.setAdadeltaCache = (i,v) => this.adadeltaCache[i] = v\r\n                }\r\n                break\r\n\r\n            case \"adam\":\r\n                this.m = 0\r\n                this.v = 0\r\n                break\r\n        }\r\n\r\n        if (activation==\"rrelu\") {\r\n            this.rreluSlope = Math.random() * 0.001\r\n\r\n        } else if (activation==\"elu\") {\r\n            this.eluAlpha = eluAlpha\r\n        }\r\n    }\r\n\r\n    getWeight (i) {\r\n        return this.weights[i]\r\n    }\r\n\r\n    setWeight (i, v) {\r\n        this.weights[i] = v\r\n    }\r\n\r\n    getDeltaWeight (i) {\r\n        return this.deltaWeights[i]\r\n    }\r\n\r\n    setDeltaWeight (i, v) {\r\n        this.deltaWeights[i] = v\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Neuron = Neuron)\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n    constructor (size, {stride, activation}={}) {\r\n\r\n        if (size)   this.size = size\r\n        if (stride) this.stride = stride\r\n\r\n        if (activation!=undefined && activation!=false) {\r\n            this.activation = typeof activation==\"function\" ? activation : NetMath[NetUtil.format(activation)].bind(this)\r\n        } else {\r\n            this.activation = false\r\n        }\r\n    }\r\n\r\n    init () {}\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n\r\n        this.prevLayer = layer\r\n        this.size = this.size || this.net.pool.size || 2\r\n        this.stride = this.stride || this.net.pool.stride || this.size\r\n        this.layerIndex = layerIndex\r\n\r\n        let prevLayerOutWidth = layer.outMapSize\r\n\r\n        switch (layer.constructor.name) {\r\n\r\n            case \"FCLayer\":\r\n                this.channels = this.net.channels\r\n                prevLayerOutWidth = Math.max(Math.floor(Math.sqrt(layer.size/this.channels)), 1)\r\n                break\r\n\r\n            case \"ConvLayer\":\r\n                this.channels = layer.size\r\n                break\r\n\r\n            case \"PoolLayer\":\r\n                this.channels = layer.channels\r\n                break\r\n        }\r\n\r\n        this.prevLayerOutWidth = prevLayerOutWidth\r\n        this.outMapSize = (prevLayerOutWidth - this.size) / this.stride + 1\r\n        this.inMapValuesCount = prevLayerOutWidth ** 2\r\n\r\n        if (this.outMapSize%1 != 0) {\r\n            throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${this.outMapSize} in pool layer at index ${layerIndex}`)\r\n        }\r\n\r\n        this.activations = [...new Array(this.channels)].map(channel => {\r\n            return [...new Array(this.outMapSize)].map(row => [...new Array(this.outMapSize)].map(v => 0))\r\n        })\r\n        this.errors = [...new Array(this.channels)].map(channel => {\r\n            return [...new Array(prevLayerOutWidth)].map(row => [...new Array(prevLayerOutWidth)].map(v => 0))\r\n        })\r\n        this.indeces = this.activations.map(channel => channel.map(row => row.map(v => [0,0])))\r\n    }\r\n\r\n    forward () {\r\n        for (let channel=0; channel<this.channels; channel++) {\r\n\r\n            NetMath.maxPool(this, channel)\r\n\r\n            // Apply activations\r\n            if (this.activation) {\r\n                for (let row=0; row<this.outMapSize; row++) {\r\n                    for (let col=0; col<this.outMapSize; col++) {\r\n                        this.activations[channel][row][col] = this.activation(this.activations[channel][row][col], false, this.net)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    backward () {\r\n\r\n        // Clear the existing error values, first\r\n        for (let channel=0; channel<this.channels; channel++) {\r\n            for (let row=0; row<this.errors[0].length; row++) {\r\n                for (let col=0; col<this.errors[0].length; col++) {\r\n                    this.errors[channel][row][col] = 0\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.nextLayer instanceof FCLayer) {\r\n\r\n            for (let channel=0; channel<this.channels; channel++) {\r\n                for (let row=0; row<this.outMapSize; row++) {\r\n                    for (let col=0; col<this.outMapSize; col++) {\r\n\r\n                        const rowI = this.indeces[channel][row][col][0] + row * this.stride\r\n                        const colI = this.indeces[channel][row][col][1] + col * this.stride\r\n                        const weightIndex = channel * this.outMapSize**2 + row * this.outMapSize + col\r\n\r\n                        for (let neuron=0; neuron<this.nextLayer.neurons.length; neuron++) {\r\n                            this.errors[channel][rowI][colI] += this.nextLayer.neurons[neuron].error\r\n                                                                * this.nextLayer.neurons[neuron].weights[weightIndex]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if (this.nextLayer instanceof ConvLayer) {\r\n\r\n            for (let channel=0; channel<this.channels; channel++) {\r\n\r\n                const errs = []\r\n\r\n                for (let col=0; col<this.outMapSize; col++) {\r\n                    errs[col] = 0\r\n                }\r\n\r\n                // Convolve on the error map\r\n                NetUtil.buildConvErrorMap(this.nextLayer, errs, channel)\r\n\r\n                for (let row=0; row<this.outMapSize; row++) {\r\n                    for (let col=0; col<this.outMapSize; col++) {\r\n\r\n                        const rowI = this.indeces[channel][row][col][0] + row * this.stride\r\n                        const colI = this.indeces[channel][row][col][1] + col * this.stride\r\n\r\n                        this.errors[channel][rowI][colI] += errs[row][col]\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n\r\n            for (let channel=0; channel<this.channels; channel++) {\r\n                for (let row=0; row<this.outMapSize; row++) {\r\n                    for (let col=0; col<this.outMapSize; col++) {\r\n\r\n                        const rowI = this.indeces[channel][row][col][0] + row * this.stride\r\n                        const colI = this.indeces[channel][row][col][1] + col * this.stride\r\n\r\n                        this.errors[channel][rowI][colI] += this.nextLayer.errors[channel][row][col]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply derivatives\r\n        if (this.activation) {\r\n            for (let channel=0; channel<this.channels; channel++) {\r\n\r\n                for (let row=0; row<this.indeces[channel].length; row++) {\r\n                    for (let col=0; col<this.indeces[channel].length; col++) {\r\n\r\n                        const rowI = this.indeces[channel][row][col][0] + row * this.stride\r\n                        const colI = this.indeces[channel][row][col][1] + col * this.stride\r\n\r\n                        this.errors[channel][rowI][colI] *= this.activation(this.errors[channel][rowI][colI], true, this.net)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    resetDeltaWeights () {}\r\n\r\n    applyDeltaWeights () {}\r\n\r\n    toJSON () {return {}}\r\n\r\n    fromJSON () {}\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.PoolLayer = PoolLayer)\n//# sourceMappingURL=jsNet.concat.js.map"]}