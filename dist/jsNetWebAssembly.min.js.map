{"version":3,"sources":["jsNetWebAssembly.concat.js"],"names":["ConvLayer","window","exports","FCLayer","[object Object]","size","this","neurons","Array","map","n","Neuron","layerIndex","layer","nextLayer","netInstance","prevLayer","forEach","neuron","ni","init","weights","bias","data","length","Error","Layer","NetMath","values","total","i","NetUtil","func","returnType","paramTypes","params","heapIn","heapOut","returnArraySize","heapMap","HEAP8","Int8Array","HEAPU8","Uint8Array","HEAP16","Int16Array","HEAPU16","Uint16Array","HEAP32","Int32Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","res","error","returnTypeParam","parameters","parameterTypes","bufs","p","isArray","typedArray","buf","Module","_malloc","BYTES_PER_ELEMENT","set","push","undefined","ccall","e","b","_free","returnData","v","value","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","self","prop","valTypes","getCallback","x","setCallback","Object","defineProperty","get","val","concat","returnSize","ccallArrays","Network","learningRate","activation","updateFn","rho","cost","layers","state","cwrap","bind","activationsIndeces","sigmoid","relu","activationName","format","costIndeces","meansquarederror","crossentropy","costFunctionName","updateFnIndeces","vanillaupdatefn","gain","adadelta","index","keys","find","key","name","epochs","iterations","every","item","Number","isInteger","initLayers","PoolLayer","input","expected","Math","ceil","abs","l","joinLayer","assignNext","assignPrev","console","warn","Promise","resolve","reject","output","startTime","now","dimension","itemSize","itemsCount","di","hasOwnProperty","ii","ei","elapsed","log","avgError","toJSON","li","fromJSON","version","neuronIndex","defineArrayProperty"],"mappings":"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","file":"jsNetWebAssembly.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.ConvLayer = ConvLayer)\r\n\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.layerIndex = 0\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (netInstance, layer, layerIndex) {\r\n        this.netInstance = netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            switch (true) {\r\n                case this.prevLayer instanceof FCLayer:\r\n                    neuron.size = this.prevLayer.size\r\n                    break\r\n            }\r\n\r\n            neuron.init(this.netInstance, this.layerIndex, ni)\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=(neuron.weights).length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\ntypeof window==\"undefined\" && (exports.FCLayer = exports.Layer = FCLayer)\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n    static softmax (values) {\r\n        let total = 0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            total += values[i]\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            if (total) {\r\n                values[i] /= total\r\n            }\r\n        }\r\n\r\n        return values\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetMath = NetMath)\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static ccallArrays (func, returnType, paramTypes, params, {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", returnArraySize=1}={}) {\r\n\r\n        const heapMap = {}\r\n        heapMap.HEAP8 = Int8Array // int8_t\r\n        heapMap.HEAPU8 = Uint8Array // uint8_t\r\n        heapMap.HEAP16 = Int16Array // int16_t\r\n        heapMap.HEAPU16 = Uint16Array // uint16_t\r\n        heapMap.HEAP32 = Int32Array // int32_t\r\n        heapMap.HEAPU32 = Uint32Array // uint32_t\r\n        heapMap.HEAPF32 = Float32Array // float\r\n        heapMap.HEAPF64 = Float64Array // double\r\n\r\n        let res\r\n        let error\r\n        paramTypes = paramTypes || []\r\n        const returnTypeParam = returnType==\"array\" ? \"number\" : returnType\r\n        const parameters = []\r\n        const parameterTypes = []\r\n        const bufs = []\r\n\r\n        try {\r\n            if (params) {\r\n                for (let p=0; p<params.length; p++) {\r\n\r\n                    if (paramTypes[p] == \"array\" || Array.isArray(params[p])) {\r\n\r\n                        const typedArray = new heapMap[heapIn](params[p].length)\r\n\r\n                        for (let i=0; i<params[p].length; i++) {\r\n                            typedArray[i] = params[p][i]\r\n                        }\r\n\r\n                        const buf = NetUtil.Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT)\r\n\r\n                        switch (heapIn) {\r\n                            case \"HEAP8\": case \"HEAPU8\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf)\r\n                                break\r\n                            case \"HEAP16\": case \"HEAPU16\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 1)\r\n                                break\r\n                            case \"HEAP32\": case \"HEAPU32\": case \"HEAPF32\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 2)\r\n                                break\r\n                            case \"HEAPF64\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 3)\r\n                                break\r\n                        }\r\n\r\n                        bufs.push(buf)\r\n                        parameters.push(buf)\r\n                        parameters.push(params[p].length)\r\n                        parameterTypes.push(\"number\")\r\n                        parameterTypes.push(\"number\")\r\n\r\n                    } else {\r\n                        parameters.push(params[p])\r\n                        parameterTypes.push(paramTypes[p]==undefined ? \"number\" : paramTypes[p])\r\n                    }\r\n                }\r\n            }\r\n\r\n            res = NetUtil.Module.ccall(func, returnTypeParam, parameterTypes, parameters)\r\n        } catch (e) {\r\n            error = e\r\n        } finally {\r\n            for (let b=0; b<bufs.length; b++) {\r\n                NetUtil.Module._free(bufs[b])\r\n            }\r\n        }\r\n\r\n        if (error) throw error\r\n\r\n\r\n        if (returnType==\"array\") {\r\n            const returnData = []\r\n\r\n            for (let v=0; v<returnArraySize; v++) {\r\n                returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v])\r\n            }\r\n\r\n            return returnData\r\n        } else {\r\n            return res\r\n        }\r\n    }\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static defineProperty (self, prop, valTypes=[], values=[], {getCallback=x=>x, setCallback=x=>x}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(this.Module.ccall(`get_${prop}`, \"number\", valTypes, values)),\r\n            set: val => this.Module.ccall(`set_${prop}`, null, valTypes.concat(\"number\"), values.concat(setCallback(val)))\r\n        })\r\n    }\r\n\r\n    static defineArrayProperty (self, prop, valTypes, values, returnSize) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => NetUtil.ccallArrays(`get_${prop}`, \"array\", valTypes, values, {returnArraySize: returnSize, heapOut: \"HEAPF64\"}),\r\n            set: (value) => NetUtil.ccallArrays(`set_${prop}`, null, valTypes.concat(\"array\"), values.concat([value]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetUtil = NetUtil)\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({Module, learningRate=0.2, activation=\"sigmoid\", updateFn=\"vanillaupdatefn\", rho, cost=\"meansquarederror\", layers=[]}) {\r\n\r\n        if (!Module) {\r\n            throw new Error(\"WASM module not provided\")\r\n        }\r\n\r\n        if (typeof activation == \"function\" || typeof cost == \"function\") {\r\n            throw new Error(\"Custom functions are not (yet) supported with WASM.\")\r\n        }\r\n\r\n        NetUtil.Module = Module\r\n        this.Module = Module\r\n        this.netInstance = this.Module.ccall(\"newNetwork\", null, null, null)\r\n        this.state = \"not-defined\"\r\n\r\n        // Learning Rate get / set\r\n        Object.defineProperty(this, \"learningRate\", {\r\n            get: this.Module.cwrap(\"getLearningRate\", null, null).bind(this, this.netInstance),\r\n            set: this.Module.cwrap(\"setLearningRate\", \"number\", null).bind(this, this.netInstance)\r\n        })\r\n        this.learningRate = learningRate\r\n\r\n        // Activation function get / set\r\n        const activationsIndeces = {\r\n            sigmoid: 0,\r\n            relu: 1\r\n        }\r\n        let activationName = NetUtil.format(activation)\r\n        Object.defineProperty(this, \"activation\", {\r\n            get: () => `WASM ${activationName}`,\r\n            set: activation => {\r\n\r\n                if (activationsIndeces[activation] == undefined) {\r\n                    throw new Error(`The ${activation} function does not exist`)\r\n                }\r\n                activationName = activation\r\n                this.Module.ccall(\"setActivation\", null, [\"number\", \"number\"], [this.netInstance, activationsIndeces[activation]])\r\n            }\r\n        })\r\n        this.activation = activationName\r\n\r\n        // Cost function get / set\r\n        const costIndeces = {\r\n            meansquarederror: 0,\r\n            crossentropy: 1\r\n        }\r\n        let costFunctionName = NetUtil.format(cost)\r\n        Object.defineProperty(this, \"cost\", {\r\n            get: () => `WASM ${costFunctionName}`,\r\n            set: cost => {\r\n                if (costIndeces[cost] == undefined) {\r\n                    throw new Error(`The ${cost} function does not exist`)\r\n                }\r\n                costFunctionName = cost\r\n                this.Module.ccall(\"setCostFunction\", null, [\"number\", \"number\"], [this.netInstance, costIndeces[cost]])\r\n            }\r\n        })\r\n        this.cost = costFunctionName\r\n\r\n\r\n        const updateFnIndeces = {\r\n            vanillaupdatefn: 0,\r\n            gain: 1,\r\n            adadelta: 5\r\n        }\r\n        NetUtil.defineProperty(this, \"updateFn\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(updateFnIndeces).find(key => updateFnIndeces[key]==index),\r\n            setCallback: name => updateFnIndeces[name]\r\n        })\r\n        this.updateFn = NetUtil.format(updateFn)\r\n\r\n        switch (NetUtil.format(updateFn)) {\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"rho\", [\"number\"], [this.netInstance])\r\n                this.rho = rho==null ? 0.95 : rho\r\n                break\r\n        }\r\n\r\n\r\n        this.layers = []\r\n        this.epochs = 0\r\n        this.iterations = 0\r\n\r\n\r\n        if (layers.length) {\r\n\r\n            this.state = \"constructed\"\r\n\r\n            switch (true) {\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        if (this.state == \"initialised\") {\r\n            return\r\n        }\r\n\r\n        if (this.state == \"not-defined\") {\r\n            this.layers[0] = new FCLayer(input)\r\n            this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                      : input + expected))\r\n            this.layers[2] = new FCLayer(Math.ceil(expected))\r\n        }\r\n\r\n        this.state = \"initialised\"\r\n\r\n        for (let l=0; l<this.layers.length; l++) {\r\n\r\n            const layer = this.layers[l]\r\n\r\n            if (layer instanceof FCLayer) {\r\n                this.Module.ccall(\"addFCLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                this.joinLayer(layer, l)\r\n                // layer.init()\r\n            }\r\n\r\n        }\r\n\r\n        this.Module.ccall(\"initLayers\", null, [\"number\"], [this.netInstance])\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.layerIndex = layerIndex\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.netInstance, this.layers[layerIndex-1], layerIndex)\r\n            layer.init()\r\n        }\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        return NetUtil.ccallArrays(\"forward\", \"array\", [\"number\", \"array\"], [this.netInstance, data], {\r\n            heapOut: \"HEAPF64\",\r\n            returnArraySize: this.layers[this.layers.length-1].neurons.length\r\n        })\r\n    }\r\n\r\n    train (data, {epochs=1}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                this.initLayers(data[0].input.length, (data[0].expected || data[0].output).length)\r\n            }\r\n\r\n            const startTime = Date.now()\r\n\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                if (!data[di].hasOwnProperty(\"input\") || (!data[di].hasOwnProperty(\"expected\") && !data[di].hasOwnProperty(\"output\"))) {\r\n                    return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\")\r\n                }\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            for (let e=0; e<epochs; e++) {\r\n                this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                                [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            }\r\n\r\n            this.Module._free(buf)\r\n            const elapsed = Date.now() - startTime\r\n            console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}`)\r\n            resolve()\r\n        })\r\n    }\r\n\r\n    test (data, {log=true}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            const startTime = Date.now()\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n            const avgError = this.Module.ccall(\"test\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            this.Module._free(buf)\r\n\r\n            const elapsed = Date.now() - startTime\r\n\r\n            if (log) {\r\n                console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/data.length, \"time\")}`)\r\n            }\r\n\r\n            resolve(avgError)\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.Module.ccall(\"resetDeltaWeights\", null, [\"number\"], [this.netInstance])\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    static get version () {\r\n        return \"2.1.1\"\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Network = Network)\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, neuronIndex) {\r\n\r\n\r\n        NetUtil.defineArrayProperty(this, \"weights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n        NetUtil.defineProperty(this, \"bias\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n        NetUtil.defineArrayProperty(this, \"deltaWeights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n        NetUtil.defineProperty(this, \"biasGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n        NetUtil.defineArrayProperty(this, \"weightGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Neuron = Neuron)\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.PoolLayer = PoolLayer)\r\n\n//# sourceMappingURL=jsNetWebAssembly.concat.js.map"]}