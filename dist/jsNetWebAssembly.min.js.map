{"version":3,"sources":["jsNetWebAssembly.concat.js"],"names":["ConvLayer","window","exports","FCLayer","[object Object]","size","this","neurons","Array","map","n","Neuron","layerIndex","layer","nextLayer","netInstance","prevLayer","forEach","neuron","ni","init","weights","bias","data","length","Error","Layer","NetMath","values","total","i","NetUtil","func","returnType","paramTypes","params","heapIn","heapOut","returnArraySize","heapMap","HEAP8","Int8Array","HEAPU8","Uint8Array","HEAP16","Int16Array","HEAPU16","Uint16Array","HEAP32","Int32Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","res","error","returnTypeParam","parameters","parameterTypes","bufs","p","isArray","typedArray","buf","Module","_malloc","BYTES_PER_ELEMENT","set","push","undefined","ccall","e","b","_free","returnData","v","value","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","Network","learningRate","activation","cost","layers","state","Object","defineProperty","get","cwrap","bind","activationsIndeces","sigmoid","relu","activationName","format","costFunctionsIndeces","meansquarederror","crossentropy","costFunctionName","epochs","iterations","every","item","Number","isInteger","initLayers","PoolLayer","input","expected","Math","ceil","abs","l","joinLayer","assignNext","assignPrev","console","warn","ccallArrays","Promise","resolve","reject","output","startTime","now","dimension","itemSize","itemsCount","di","hasOwnProperty","index","ii","ei","elapsed","log","avgError","toJSON","li","fromJSON","version","neuronIndex","deltaWeights"],"mappings":"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","file":"jsNetWebAssembly.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.ConvLayer = ConvLayer)\r\n\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.layerIndex = 0\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (netInstance, layer, layerIndex) {\r\n        this.netInstance = netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            switch (true) {\r\n                case this.prevLayer instanceof FCLayer:\r\n                    neuron.size = this.prevLayer.size\r\n                    break\r\n            }\r\n\r\n            neuron.init(this.netInstance, this.layerIndex, ni)\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=(neuron.weights).length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\ntypeof window==\"undefined\" && (exports.FCLayer = exports.Layer = FCLayer)\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n    static softmax (values) {\r\n        let total = 0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            total += values[i]\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            if (total) {\r\n                values[i] /= total\r\n            }\r\n        }\r\n\r\n        return values\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetMath = NetMath)\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static ccallArrays (func, returnType, paramTypes, params, {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", returnArraySize=1}={}) {\r\n\r\n        const heapMap = {}\r\n        heapMap.HEAP8 = Int8Array // int8_t\r\n        heapMap.HEAPU8 = Uint8Array // uint8_t\r\n        heapMap.HEAP16 = Int16Array // int16_t\r\n        heapMap.HEAPU16 = Uint16Array // uint16_t\r\n        heapMap.HEAP32 = Int32Array // int32_t\r\n        heapMap.HEAPU32 = Uint32Array // uint32_t\r\n        heapMap.HEAPF32 = Float32Array // float\r\n        heapMap.HEAPF64 = Float64Array // double\r\n\r\n        let res\r\n        let error\r\n        paramTypes = paramTypes || []\r\n        const returnTypeParam = returnType==\"array\" ? \"number\" : returnType\r\n        const parameters = []\r\n        const parameterTypes = []\r\n        const bufs = []\r\n\r\n        try {\r\n            if (params) {\r\n                for (let p=0; p<params.length; p++) {\r\n\r\n                    if (paramTypes[p] == \"array\" || Array.isArray(params[p])) {\r\n\r\n                        const typedArray = new heapMap[heapIn](params[p].length)\r\n\r\n                        for (let i=0; i<params[p].length; i++) {\r\n                            typedArray[i] = params[p][i]\r\n                        }\r\n\r\n                        const buf = NetUtil.Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT)\r\n\r\n                        switch (heapIn) {\r\n                            case \"HEAP8\": case \"HEAPU8\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf)\r\n                                break\r\n                            case \"HEAP16\": case \"HEAPU16\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 1)\r\n                                break\r\n                            case \"HEAP32\": case \"HEAPU32\": case \"HEAPF32\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 2)\r\n                                break\r\n                            case \"HEAPF64\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 3)\r\n                                break\r\n                        }\r\n\r\n                        bufs.push(buf)\r\n                        parameters.push(buf)\r\n                        parameters.push(params[p].length)\r\n                        parameterTypes.push(\"number\")\r\n                        parameterTypes.push(\"number\")\r\n\r\n                    } else {\r\n                        parameters.push(params[p])\r\n                        parameterTypes.push(paramTypes[p]==undefined ? \"number\" : paramTypes[p])\r\n                    }\r\n                }\r\n            }\r\n\r\n            res = NetUtil.Module.ccall(func, returnTypeParam, parameterTypes, parameters)\r\n        } catch (e) {\r\n            error = e\r\n        } finally {\r\n            for (let b=0; b<bufs.length; b++) {\r\n                NetUtil.Module._free(bufs[b])\r\n            }\r\n        }\r\n\r\n        if (error) throw error\r\n\r\n\r\n        if (returnType==\"array\") {\r\n            const returnData = []\r\n\r\n            for (let v=0; v<returnArraySize; v++) {\r\n                returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v])\r\n            }\r\n\r\n            return returnData\r\n        } else {\r\n            return res\r\n        }\r\n    }\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetUtil = NetUtil)\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({Module, learningRate=0.2, activation=\"sigmoid\", cost=\"meansquarederror\", layers=[]}) {\r\n\r\n        if (!Module) {\r\n            throw new Error(\"WASM module not provided\")\r\n        }\r\n\r\n        if (typeof activation == \"function\" || typeof cost == \"function\") {\r\n            throw new Error(\"Custom functions are not (yet) supported with WASM.\")\r\n        }\r\n\r\n        this.Module = Module\r\n        /*TODO-test*/\r\n        NetUtil.Module = Module\r\n        /**/\r\n        this.netInstance = this.Module.ccall(\"newNetwork\", null, null, null)\r\n        this.state = \"not-defined\"\r\n\r\n        // Learning Rate get / set\r\n        Object.defineProperty(this, \"learningRate\", {\r\n            get: this.Module.cwrap(\"getLearningRate\", null, null).bind(this, this.netInstance),\r\n            set: this.Module.cwrap(\"setLearningRate\", \"number\", null).bind(this, this.netInstance)\r\n        })\r\n        this.learningRate = learningRate\r\n\r\n        // Activation function get / set\r\n        const activationsIndeces = {\r\n            sigmoid: 0,\r\n            relu: 1\r\n        }\r\n        let activationName = NetUtil.format(activation)\r\n        Object.defineProperty(this, \"activation\", {\r\n            get: () => `WASM ${activationName}`,\r\n            set: activation => {\r\n\r\n                if (activationsIndeces[activation] == undefined) {\r\n                    throw new Error(`The ${activation} function does not exist`)\r\n                }\r\n                activationName = activation\r\n                this.Module.ccall(\"setActivation\", null, [\"number\", \"number\"], [this.netInstance, activationsIndeces[activation]])\r\n            }\r\n        })\r\n        this.activation = activationName\r\n\r\n        // Cost function get / set\r\n        const costFunctionsIndeces = {\r\n            meansquarederror: 0,\r\n            crossentropy: 1\r\n        }\r\n        let costFunctionName = NetUtil.format(cost)\r\n        Object.defineProperty(this, \"cost\", {\r\n            get: () => `WASM ${costFunctionName}`,\r\n            set: cost => {\r\n                if (costFunctionsIndeces[cost] == undefined) {\r\n                    throw new Error(`The ${cost} function does not exist`)\r\n                }\r\n                costFunctionName = cost\r\n                this.Module.ccall(\"setCostFunction\", null, [\"number\", \"number\"], [this.netInstance, costFunctionsIndeces[cost]])\r\n            }\r\n        })\r\n        this.cost = costFunctionName\r\n\r\n        this.layers = []\r\n        this.epochs = 0\r\n        this.iterations = 0\r\n\r\n\r\n        if (layers.length) {\r\n\r\n            this.state = \"constructed\"\r\n\r\n            switch (true) {\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        if (this.state == \"initialised\") {\r\n            return\r\n        }\r\n\r\n        if (this.state == \"not-defined\") {\r\n            this.layers[0] = new FCLayer(input)\r\n            this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                      : input + expected))\r\n            this.layers[2] = new FCLayer(Math.ceil(expected))\r\n        }\r\n\r\n        this.state = \"initialised\"\r\n\r\n        for (let l=0; l<this.layers.length; l++) {\r\n\r\n            const layer = this.layers[l]\r\n\r\n            if (layer instanceof FCLayer) {\r\n                this.Module.ccall(\"addFCLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                this.joinLayer(layer, l)\r\n                // layer.init()\r\n            }\r\n\r\n        }\r\n\r\n        this.Module.ccall(\"initLayers\", null, [\"number\"], [this.netInstance])\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.layerIndex = layerIndex\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.netInstance, this.layers[layerIndex-1], layerIndex)\r\n            layer.init()\r\n        }\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        return NetUtil.ccallArrays(\"forward\", \"array\", [\"number\", \"array\"], [this.netInstance, data], {\r\n            heapOut: \"HEAPF64\",\r\n            returnArraySize: this.layers[this.layers.length-1].neurons.length\r\n        })\r\n    }\r\n\r\n    train (data, {epochs=1}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                this.initLayers(data[0].input.length, (data[0].expected || data[0].output).length)\r\n            }\r\n\r\n            const startTime = Date.now()\r\n\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                if (!data[di].hasOwnProperty(\"input\") || (!data[di].hasOwnProperty(\"expected\") && !data[di].hasOwnProperty(\"output\"))) {\r\n                    return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\")\r\n                }\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            for (let e=0; e<epochs; e++) {\r\n                this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                                [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            }\r\n\r\n            this.Module._free(buf)\r\n            const elapsed = Date.now() - startTime\r\n            console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}`)\r\n            resolve()\r\n        })\r\n    }\r\n\r\n    test (data, {log=true}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            const startTime = Date.now()\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n            const avgError = this.Module.ccall(\"test\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            this.Module._free(buf)\r\n\r\n            const elapsed = Date.now() - startTime\r\n\r\n            if (log) {\r\n                console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/data.length, \"time\")}`)\r\n            }\r\n\r\n            resolve(avgError)\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.Module.ccall(\"resetDeltaWeights\", null, [\"number\"], [this.netInstance])\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    static get version () {\r\n        return \"2.1.1\"\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Network = Network)\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, neuronIndex) {\r\n\r\n        Object.defineProperty(this, \"weights\", {\r\n            get: () => NetUtil.ccallArrays(\"getNeuronWeights\", \"array\", [\"number\", \"number\", \"number\"],\r\n                    [netInstance, layerIndex, neuronIndex], {returnArraySize: this.size, heapOut: \"HEAPF64\"}),\r\n            set: weights => NetUtil.ccallArrays(\"setNeuronWeights\", null, [\"number\", \"number\", \"number\", \"array\"],\r\n                    [netInstance, layerIndex, neuronIndex, weights], {heapIn: \"HEAPF64\"})\r\n        })\r\n        Object.defineProperty(this, \"bias\", {\r\n            get: () => NetUtil.ccallArrays(\"getNeuronBias\", \"number\", [\"number\", \"number\", \"number\"],\r\n                [netInstance, layerIndex, neuronIndex]),\r\n            set: value => NetUtil.ccallArrays(\"setNeuronBias\", null, [\"number\", \"number\", \"number\", \"number\"],\r\n                [netInstance, layerIndex, neuronIndex, value])\r\n        })\r\n        Object.defineProperty(this, \"deltaWeights\", {\r\n            get: () => NetUtil.ccallArrays(\"getNeuronDeltaWeights\", \"array\", [\"number\", \"number\", \"number\"],\r\n                [netInstance, layerIndex, neuronIndex], {returnArraySize: this.size, heapOut: \"HEAPF64\"}),\r\n            set: deltaWeights => NetUtil.ccallArrays(\"setNeuronDeltaWeights\", null, [\"number\", \"number\", \"number\", \"array\"],\r\n                    [netInstance, layerIndex, neuronIndex, deltaWeights], {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Neuron = Neuron)\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.PoolLayer = PoolLayer)\r\n\n//# sourceMappingURL=jsNetWebAssembly.concat.js.map"]}