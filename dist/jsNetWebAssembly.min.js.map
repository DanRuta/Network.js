{"version":3,"sources":["jsNetWebAssembly.concat.js"],"names":["ConvLayer","[object Object]","size","filterSize","zeroPadding","stride","activation","this","layerIndex","activationName","undefined","Error","NetUtil","format","layer","nextLayer","netInstance","net","prevLayer","conv","defineProperty","pre","channels","FCLayer","PoolLayer","activations","length","Math","floor","prevLayerOutWidth","max","sqrt","outMapSize","outSize","inMapValuesCount","pow","inZPMapValuesCount","getCallback","_","activationsIndeces","filters","Array","map","f","Filter","forEach","filter","fi","paramTypes","params","defineMapProperty","m","row","v","init","updateFn","weights","bias","data","c","r","push","valI","newFilterWeights","slice","window","exports","global","jsNetWASMPath","neurons","n","Neuron","neuron","ni","w","Layer","filterIndex","defineVolumeProperty","InputLayer","span","super","NetMath","values","total","i","func","returnType","heapIn","heapOut","returnArraySize","heapMap","HEAP8","Int8Array","HEAPU8","Uint8Array","HEAP16","Int16Array","HEAPU16","Uint16Array","HEAP32","Int32Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","res","error","returnTypeParam","parameters","parameterTypes","bufs","p","isArray","typedArray","buf","Module","_malloc","BYTES_PER_ELEMENT","set","ccall","e","b","_free","returnData","depth","rows","columns","totalValues","parameter","isVolume","flat","d","splice","ccallArrays","vol","value","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","arr","j","random","x","training","validation","test","split","minVal","Infinity","maxVal","self","prop","valTypes","setCallback","Object","get","val","concat","returnSize","ccallVolume","originalData","totalCorrect","rowTotal","count","percent","correctPercent","correct","wrong","bottomRow","columnTotal","toFixed","console","table","padNum","num","toString","leftPad","rightPad","repeat","colourText","colourBackground","process","stdout","write","col","noactivation","sigmoid","tanh","lecuntanh","relu","lrelu","rrelu","elu","Network","learningRate","cost","layers","momentum","rmsDecay","rho","lreluSlope","eluAlpha","dropout","l2","l1","maxNorm","weightsConfig","pool","state","cwrap","bind","costIndeces","meansquarederror","crossentropy","costFunctionName","updateFnIndeces","vanillasgd","gain","adagrad","rmsprop","adam","adadelta","index","keys","find","key","name","weightsConfigFns","uniform","gaussian","xavieruniform","xaviernormal","lecununiform","lecunnormal","round","distribution","limit","mean","stdDeviation","epochs","every","item","Number","isInteger","initLayers","input","expected","ceil","abs","l","joinLayer","floorFunc","assignNext","assignPrev","warn","callback","miniBatchSize","log","shuffle","trainingLogging","stoppedEarly","Promise","resolve","reject","startTime","now","dimension","itemSize","itemsCount","loadData","elapsed","validationBuf","validationInterval","interval","earlyStopping","threshold","earlyStoppingThreshold","earlyStoppingType","patience","earlyStoppingBestError","earlyStoppingPatienceCounter","earlyStoppingPatience","earlyStoppingPercent","logAndResolve","epochIndex","iterationIndex","doEpoch","l2Error","l1Error","doIteration","iterations","validations","trainingError","validationError","setTimeout","text","lastValidationError","di","hasOwnProperty","ii","ei","totalError","avgError","toJSON","li","fromJSON","IMGArrays","opts","layerData","toIMG","rawData","fromIMG","dataCount","getDataSize","printConfusionMatrix","makeConfusionMatrix","trainingConfusionMatrix","testConfusionMatrix","validationConfusionMatrix","version","neuronIndex","defineArrayProperty","parseInt","y"],"mappings":"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","file":"jsNetWebAssembly.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n    constructor (size, {filterSize, zeroPadding, stride, activation}={}) {\r\n\r\n        this.size = size\r\n        this.stride = stride\r\n        this.filterSize = filterSize\r\n        this.layerIndex = 0\r\n        this.zeroPadding = zeroPadding\r\n\r\n        this.activation = false\r\n        this.activationName = activation\r\n\r\n        if (activation != undefined) {\r\n            if (typeof activation == \"boolean\" && !activation) {\r\n                activation = \"noactivation\"\r\n            }\r\n            if (typeof activation != \"string\") {\r\n                throw new Error(\"Custom activation functions are not available in the WebAssembly version\")\r\n            }\r\n            this.activationName = NetUtil.format(activation)\r\n        }\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n\r\n        this.netInstance = this.net.netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n        const stride = this.stride || this.net.conv.stride || 1\r\n        const filterSize = this.filterSize || this.net.conv.filterSize || 3\r\n        let zeroPadding = this.zeroPadding\r\n\r\n        NetUtil.defineProperty(this, \"channels\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"filterSize\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"stride\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"zeroPadding\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n\r\n        this.size = this.size || 4\r\n        let channels\r\n\r\n        switch (true) {\r\n            case layer instanceof FCLayer:\r\n                channels = this.net.channels || 1\r\n                break\r\n\r\n            case layer instanceof ConvLayer:\r\n                channels = layer.size\r\n                break\r\n\r\n            case layer instanceof PoolLayer:\r\n                channels = layer.activations.length\r\n                break\r\n        }\r\n\r\n        if (zeroPadding == undefined) {\r\n            zeroPadding = this.net.conv.zeroPadding==undefined ? Math.floor(filterSize/2) : this.net.conv.zeroPadding\r\n        }\r\n\r\n        this.channels = channels\r\n        this.filterSize = filterSize\r\n        this.stride = stride\r\n        this.zeroPadding = zeroPadding\r\n\r\n        // Caching calculations\r\n        const prevLayerOutWidth = layer instanceof FCLayer ? Math.max(Math.floor(Math.sqrt(layer.size/channels)), 1)\r\n                                                           : layer.outMapSize\r\n\r\n        NetUtil.defineProperty(this, \"inMapValuesCount\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"inZPMapValuesCount\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"outMapSize\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n\r\n        const outSize = (prevLayerOutWidth - filterSize + 2*zeroPadding) / stride + 1\r\n        this.inMapValuesCount = Math.pow(prevLayerOutWidth, 2)\r\n        this.inZPMapValuesCount = Math.pow(prevLayerOutWidth + zeroPadding*2, 2)\r\n        this.outMapSize = outSize\r\n\r\n        if (outSize%1!=0) {\r\n            throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${outSize} in conv layer at index ${layerIndex}`)\r\n        }\r\n\r\n        if (this.activationName !== false && this.net.activationName !== false) {\r\n            NetUtil.defineProperty(this, \"activation\", [\"number\", \"number\"], [this.netInstance, layerIndex], {\r\n                pre: \"conv_\",\r\n                getCallback: _ => `WASM ${this.activationName||this.net.activationName}`\r\n            })\r\n            this.activation = NetUtil.activationsIndeces[this.activationName||this.net.activationName]\r\n        }\r\n\r\n        this.filters = [...new Array(this.size)].map(f => new Filter())\r\n    }\r\n\r\n    init () {\r\n        this.filters.forEach((filter, fi) => {\r\n\r\n            const paramTypes = [\"number\", \"number\", \"number\"]\r\n            const params = [this.netInstance, this.layerIndex, fi]\r\n\r\n            NetUtil.defineMapProperty(filter, \"activationMap\", paramTypes, params, this.outMapSize, this.outMapSize, {pre: \"filter_\"})\r\n            NetUtil.defineMapProperty(filter, \"errorMap\", paramTypes, params, this.outMapSize, this.outMapSize, {pre: \"filter_\"})\r\n            NetUtil.defineMapProperty(filter, \"sumMap\", paramTypes, params, this.outMapSize, this.outMapSize, {pre: \"filter_\"})\r\n            NetUtil.defineMapProperty(filter, \"dropoutMap\", paramTypes, params, this.outMapSize, this.outMapSize, {\r\n                pre: \"filter_\",\r\n                getCallback: m => m.map(row => row.map(v => v==1))\r\n            })\r\n\r\n            filter.init(this.netInstance, this.layerIndex, fi, {\r\n                updateFn: this.net.updateFn,\r\n                filterSize: this.filterSize,\r\n                channels: this.channels\r\n            })\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.filters.map(filter => {\r\n                return {\r\n                    bias: filter.bias,\r\n                    weights: filter.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n        this.filters.forEach((filter, fi) => {\r\n\r\n            if (data.weights[fi].weights.length != filter.weights.length) {\r\n                throw new Error(`Mismatched weights depth. Given: ${data.weights[fi].weights.length} Existing: ${filter.weights.length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            if (data.weights[fi].weights[0].length != filter.weights[0].length) {\r\n                throw new Error(`Mismatched weights size. Given: ${data.weights[fi].weights[0].length} Existing: ${filter.weights[0].length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            filter.bias = data.weights[fi].bias\r\n            filter.weights = data.weights[fi].weights\r\n        })\r\n    }\r\n\r\n    // Used for importing data\r\n    getDataSize () {\r\n\r\n        let size = 0\r\n\r\n        for (let f=0; f<this.filters.length; f++) {\r\n\r\n            const filter = this.filters[f]\r\n\r\n            for (let c=0; c<filter.weights.length; c++) {\r\n                for (let r=0; r<filter.weights[c].length; r++) {\r\n                    size += filter.weights[c][r].length\r\n                }\r\n            }\r\n\r\n            size += 1\r\n        }\r\n\r\n        return size\r\n    }\r\n\r\n    toIMG () {\r\n        const data = []\r\n\r\n        for (let f=0; f<this.filters.length; f++) {\r\n            const filter = this.filters[f]\r\n\r\n            data.push(filter.bias)\r\n\r\n            for (let c=0; c<filter.weights.length; c++) {\r\n                for (let r=0; r<filter.weights[c].length; r++) {\r\n                    for (let v=0; v<filter.weights[c][r].length; v++) {\r\n                        data.push(filter.weights[c][r][v])\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return data\r\n    }\r\n\r\n    fromIMG (data) {\r\n        let valI = 0\r\n\r\n        for (let f=0; f<this.filters.length; f++) {\r\n\r\n            const filter = this.filters[f]\r\n            filter.bias = data[valI]\r\n            valI++\r\n\r\n            let newFilterWeights = filter.weights.slice(0)\r\n\r\n            for (let c=0; c<filter.weights.length; c++) {\r\n                for (let r=0; r<filter.weights[c].length; r++) {\r\n                    for (let v=0; v<filter.weights[c][r].length; v++) {\r\n                        // filter.weights[c][r][v] = data[valI]\r\n                        newFilterWeights[c][r][v] = data[valI]\r\n                        valI++\r\n                    }\r\n                }\r\n            }\r\n\r\n            filter.weights = newFilterWeights\r\n        }\r\n    }\r\n}\r\n\r\n// https://github.com/DanRuta/jsNet/issues/33\r\n/* istanbul ignore next */\r\nif (typeof window!=\"undefined\") {\r\n    window.exports = window.exports || {}\r\n    window.global = window.global || {}\r\n    window.global.jsNetWASMPath = \"./NetWASM.wasm\"\r\n    window.ConvLayer = ConvLayer\r\n}\r\nexports.ConvLayer = ConvLayer\r\n\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size, {activation}={}) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.layerIndex = 0\r\n\r\n        if (activation != undefined) {\r\n            if (typeof activation == \"boolean\" && !activation) {\r\n                activation = \"noactivation\"\r\n            }\r\n            if (typeof activation != \"string\") {\r\n                throw new Error(\"Custom activation functions are not available in the WebAssembly version\")\r\n            }\r\n            this.activationName = NetUtil.format(activation)\r\n        }\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n        this.netInstance = this.net.netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n        if (this.activationName || this.net.activationName) {\r\n            NetUtil.defineProperty(this, \"activation\", [\"number\", \"number\"], [this.netInstance, layerIndex], {\r\n                pre: \"fc_\",\r\n                getCallback: _ => `WASM ${this.activationName||this.net.activationName}`\r\n            })\r\n            this.activation = NetUtil.activationsIndeces[this.activationName||this.net.activationName]\r\n        }\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            switch (true) {\r\n\r\n                case this.prevLayer instanceof FCLayer:\r\n                    neuron.size = this.prevLayer.size\r\n                    break\r\n\r\n                case this.prevLayer instanceof ConvLayer:\r\n                    neuron.size = this.prevLayer.filters.length * this.prevLayer.outMapSize**2\r\n                    break\r\n\r\n                case this.prevLayer instanceof PoolLayer:\r\n                    neuron.size = this.prevLayer.channels * this.prevLayer.outMapSize**2\r\n                    break\r\n            }\r\n\r\n            neuron.init(this.netInstance, this.layerIndex, ni, {\r\n                updateFn: this.net.updateFn\r\n            })\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=(neuron.weights).length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n\r\n    // Used for importing data\r\n    getDataSize () {\r\n        let size = 0\r\n\r\n        for (let n=0; n<this.neurons.length; n++) {\r\n            size += this.neurons[n].weights.length + 1\r\n        }\r\n\r\n        return size\r\n    }\r\n\r\n    toIMG () {\r\n        const data = []\r\n\r\n        for (let n=0; n<this.neurons.length; n++) {\r\n            data.push(this.neurons[n].bias)\r\n\r\n            for (let w=0; w<this.neurons[n].weights.length; w++) {\r\n                data.push(this.neurons[n].weights[w])\r\n            }\r\n        }\r\n\r\n        return data\r\n    }\r\n\r\n    fromIMG (data) {\r\n\r\n        let valI = 0\r\n\r\n        for (let n=0; n<this.neurons.length; n++) {\r\n\r\n            const neuron = this.neurons[n]\r\n            neuron.bias = data[valI]\r\n            valI++\r\n\r\n            neuron.weights = data.slice(valI, valI+neuron.weights.length)\r\n            valI += neuron.weights.length\r\n        }\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.FCLayer = window.Layer = FCLayer)\r\nexports.FCLayer = exports.Layer = FCLayer\r\n\"use strict\"\r\n\r\nclass Filter {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, filterIndex, {updateFn, channels, filterSize}) {\r\n\r\n        const paramTypes = [\"number\", \"number\", \"number\"]\r\n        const params = [netInstance, layerIndex, filterIndex]\r\n\r\n        NetUtil.defineProperty(this, \"bias\", paramTypes, params, {pre: \"filter_\"})\r\n        NetUtil.defineVolumeProperty(this, \"weights\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n        NetUtil.defineProperty(this, \"deltaBias\", paramTypes, params, {pre: \"filter_\"})\r\n        NetUtil.defineVolumeProperty(this, \"deltaWeights\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n\r\n        switch (updateFn) {\r\n            case \"gain\":\r\n                NetUtil.defineProperty(this, \"biasGain\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineVolumeProperty(this, \"weightGain\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n                break\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"biasCache\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineVolumeProperty(this, \"weightsCache\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n\r\n                if (updateFn == \"adadelta\") {\r\n                    NetUtil.defineProperty(this, \"adadeltaBiasCache\", paramTypes, params, {pre: \"filter_\"})\r\n                    NetUtil.defineVolumeProperty(this, \"adadeltaWeightsCache\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n                }\r\n                break\r\n            case \"adam\":\r\n                NetUtil.defineProperty(this, \"m\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineProperty(this, \"v\", paramTypes, params, {pre: \"filter_\"})\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.Filter = Filter)\r\nexports.Filter = Filter\r\n\"use strict\"\r\n\r\nclass InputLayer extends FCLayer {\r\n    constructor (size, {span=1}={}) {\r\n        super(size * span*span)\r\n    }\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.InputLayer = InputLayer)\r\nexports.InputLayer = InputLayer\r\n\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n    static softmax (values) {\r\n        let total = 0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            total += values[i]\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            if (total) {\r\n                values[i] /= total\r\n            }\r\n        }\r\n\r\n        return values\r\n    }\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.NetMath = NetMath)\r\nexports.NetMath = NetMath\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static ccallArrays (func, returnType, paramTypes, params, {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", returnArraySize=1}={}) {\r\n\r\n        const heapMap = {}\r\n        heapMap.HEAP8 = Int8Array // int8_t\r\n        heapMap.HEAPU8 = Uint8Array // uint8_t\r\n        heapMap.HEAP16 = Int16Array // int16_t\r\n        heapMap.HEAPU16 = Uint16Array // uint16_t\r\n        heapMap.HEAP32 = Int32Array // int32_t\r\n        heapMap.HEAPU32 = Uint32Array // uint32_t\r\n        heapMap.HEAPF32 = Float32Array // float\r\n        heapMap.HEAPF64 = Float64Array // double\r\n\r\n        let res\r\n        let error\r\n        paramTypes = paramTypes || []\r\n        const returnTypeParam = returnType==\"array\" ? \"number\" : returnType\r\n        const parameters = []\r\n        const parameterTypes = []\r\n        const bufs = []\r\n\r\n        try {\r\n            if (params) {\r\n                for (let p=0; p<params.length; p++) {\r\n\r\n                    if (paramTypes[p] == \"array\" || Array.isArray(params[p])) {\r\n\r\n                        const typedArray = new heapMap[heapIn](params[p])\r\n                        const buf = NetUtil.Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT)\r\n\r\n                        switch (heapIn) {\r\n                            case \"HEAP8\": case \"HEAPU8\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf)\r\n                                break\r\n                            case \"HEAP16\": case \"HEAPU16\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 1)\r\n                                break\r\n                            case \"HEAP32\": case \"HEAPU32\": case \"HEAPF32\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 2)\r\n                                break\r\n                            case \"HEAPF64\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 3)\r\n                                break\r\n                        }\r\n\r\n                        bufs.push(buf)\r\n                        parameters.push(buf)\r\n                        parameters.push(params[p].length)\r\n                        parameterTypes.push(\"number\")\r\n                        parameterTypes.push(\"number\")\r\n\r\n                    } else {\r\n                        parameters.push(params[p])\r\n                        parameterTypes.push(paramTypes[p]==undefined ? \"number\" : paramTypes[p])\r\n                    }\r\n                }\r\n            }\r\n\r\n            res = NetUtil.Module.ccall(func, returnTypeParam, parameterTypes, parameters)\r\n        } catch (e) {\r\n            error = e\r\n        } finally {\r\n            for (let b=0; b<bufs.length; b++) {\r\n                NetUtil.Module._free(bufs[b])\r\n            }\r\n        }\r\n\r\n        if (error) throw error\r\n\r\n\r\n        if (returnType==\"array\") {\r\n            const returnData = []\r\n\r\n            for (let v=0; v<returnArraySize; v++) {\r\n                returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v])\r\n            }\r\n\r\n            return returnData\r\n        } else {\r\n            return res\r\n        }\r\n    }\r\n\r\n    static ccallVolume (func, returnType, paramTypes=[], params=[], {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", depth=1, rows=1, columns=rows}={}) {\r\n\r\n        const totalValues = depth * rows * columns\r\n        const parameters = []\r\n        const parameterTypes = []\r\n\r\n        // Loop through parameters, check if they are volumes, flatten them, and send them along with their dimensions\r\n        for (let p=0; p<params.length; p++) {\r\n\r\n            let parameter = params[p]\r\n            const isVolume = Array.isArray(parameter) && Array.isArray(parameter[0]) && Array.isArray(parameter[0][0])\r\n\r\n            if (paramTypes[p] == \"volume\" || isVolume) {\r\n                const flat = []\r\n\r\n                for (let d=0; d<parameter.length; d++) {\r\n                    for (let r=0; r<parameter[d].length; r++) {\r\n                        for (let c=0; c<parameter[d][r].length; c++) {\r\n                            flat.push(parameter[d][r][c])\r\n                        }\r\n                    }\r\n                }\r\n\r\n                parameters.splice(parameters.length, 0, flat, parameter.length, parameter[0].length, parameter[0][0].length)\r\n                parameterTypes.splice(parameterTypes.length, 0, \"array\", \"number\", \"number\", \"number\")\r\n\r\n            } else {\r\n                parameters.push(parameter)\r\n                parameterTypes.push(paramTypes[p])\r\n            }\r\n        }\r\n\r\n        const res = NetUtil.ccallArrays(func, returnType==\"volume\" ? \"array\" : returnType, parameterTypes, parameters, {heapIn, heapOut, returnArraySize: totalValues})\r\n        const vol = []\r\n\r\n        if (returnType == \"volume\") {\r\n            for (let d=0; d<depth; d++) {\r\n                const map = []\r\n\r\n                for (let r=0; r<rows; r++) {\r\n                    const row = []\r\n\r\n                    for (let c=0; c<columns; c++) {\r\n                        row.push(res[d * rows * columns + r * columns + c])\r\n                    }\r\n                    map.push(row)\r\n                }\r\n                vol.push(map)\r\n            }\r\n            return vol\r\n        }\r\n\r\n        return res\r\n    }\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static shuffle (arr) {\r\n        for (let i=arr.length; i; i--) {\r\n            const j = Math.floor(Math.random() * i)\r\n            const x = arr[i-1]\r\n            arr[i-1] = arr[j]\r\n            arr[j] = x\r\n        }\r\n    }\r\n\r\n    static splitData (data, {training=0.7, validation=0.15, test=0.15}={}) {\r\n\r\n        const split = {\r\n            training: [],\r\n            validation: [],\r\n            test: []\r\n        }\r\n\r\n        // Define here splits, for returning at the end\r\n        for (let i=0; i<data.length; i++) {\r\n            let x = Math.random()\r\n\r\n            if (x > 1-training) {\r\n                split.training.push(data[i])\r\n            } else {\r\n\r\n                if (x<validation) {\r\n                    split.validation.push(data[i])\r\n                } else {\r\n                    split.test.push(data[i])\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return split\r\n    }\r\n\r\n    static normalize (data) {\r\n        let minVal = Infinity\r\n        let maxVal = -Infinity\r\n\r\n        for (let i=0; i<data.length; i++) {\r\n            if (data[i] < minVal) {\r\n                minVal = data[i]\r\n            }\r\n            if (data[i] > maxVal) {\r\n                maxVal = data[i]\r\n            }\r\n        }\r\n\r\n        if ((-1*minVal + maxVal) != 0) {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = (data[i] + -1*minVal) / (-1*minVal + maxVal)\r\n            }\r\n        } else {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = 0.5\r\n            }\r\n        }\r\n\r\n        return {minVal, maxVal}\r\n    }\r\n\r\n    static defineProperty (self, prop, valTypes=[], values=[], {getCallback=x=>x, setCallback=x=>x, pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(this.Module.ccall(`get_${pre}${prop}`, \"number\", valTypes, values)),\r\n            set: val => this.Module.ccall(`set_${pre}${prop}`, null, valTypes.concat(\"number\"), values.concat(setCallback(val)))\r\n        })\r\n    }\r\n\r\n    static defineArrayProperty (self, prop, valTypes, values, returnSize, {pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => NetUtil.ccallArrays(`get_${pre}${prop}`, \"array\", valTypes, values, {returnArraySize: returnSize, heapOut: \"HEAPF64\"}),\r\n            set: value => NetUtil.ccallArrays(`set_${pre}${prop}`, null, valTypes.concat(\"array\"), values.concat([value]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n    static defineMapProperty (self, prop, valTypes, values, rows, columns, {getCallback=x=>x, setCallback=x=>x, pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(NetUtil.ccallVolume(`get_${pre}${prop}`, \"volume\", valTypes, values, {depth: 1, rows, columns, heapOut: \"HEAPF64\"})[0]),\r\n            set: value => NetUtil.ccallVolume(`set_${pre}${prop}`, null, valTypes.concat(\"array\"), values.concat([setCallback(value)]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n    static defineVolumeProperty (self, prop, valTypes, values, depth, rows, columns, {getCallback=x=>x, setCallback=x=>x, pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(NetUtil.ccallVolume(`get_${pre}${prop}`, \"volume\", valTypes, values, {depth, rows, columns, heapOut: \"HEAPF64\"})),\r\n            set: value => NetUtil.ccallVolume(`set_${pre}${prop}`, null, valTypes.concat(\"array\"), values.concat([setCallback(value)]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n    static makeConfusionMatrix (originalData) {\r\n        let total = 0\r\n        let totalCorrect = 0\r\n        const data = []\r\n\r\n        for (let r=0; r<originalData.length; r++) {\r\n            const row = []\r\n            for (let c=0; c<originalData[r].length; c++) {\r\n                row.push(originalData[r][c])\r\n            }\r\n            data.push(row)\r\n        }\r\n\r\n\r\n        for (let r=0; r<data.length; r++) {\r\n            for (let c=0; c<data[r].length; c++) {\r\n                total += data[r][c]\r\n            }\r\n        }\r\n\r\n        for (let r=0; r<data.length; r++) {\r\n\r\n            let rowTotal = 0\r\n            totalCorrect += data[r][r]\r\n\r\n            for (let c=0; c<data[r].length; c++) {\r\n                rowTotal += data[r][c]\r\n                data[r][c] = {count: data[r][c], percent: (data[r][c] / total * 100)||0}\r\n            }\r\n\r\n            const correctPercent = data[r][r].count / rowTotal * 100\r\n\r\n            data[r].total = {\r\n                correct: (correctPercent||0),\r\n                wrong: (100 - correctPercent)||0\r\n            }\r\n        }\r\n\r\n        // Collect bottom row percentages\r\n        const bottomRow = []\r\n\r\n        for (let c=0; c<data[0].length; c++) {\r\n\r\n            let columnTotal = 0\r\n\r\n            for (let r=0; r<data.length; r++) {\r\n                columnTotal += data[r][c].count\r\n            }\r\n\r\n            const correctPercent = data[c][c].count / columnTotal * 100\r\n\r\n            bottomRow.push({\r\n                correct: (correctPercent)||0,\r\n                wrong: (100 - correctPercent)||0\r\n            })\r\n        }\r\n\r\n        data.total = bottomRow\r\n\r\n        // Calculate final matrix percentage\r\n        data.total.total = {\r\n            correct: (totalCorrect / total * 100)||0,\r\n            wrong: (100 - (totalCorrect / total * 100))||0\r\n        }\r\n\r\n        return data\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    static printConfusionMatrix (data) {\r\n        if (typeof window!=\"undefined\") {\r\n\r\n            for (let r=0; r<data.length; r++) {\r\n                for (let c=0; c<data[r].length; c++) {\r\n                    data[r][c] = `${data[r][c].count} (${data[r][c].percent.toFixed(1)}%)`\r\n                }\r\n                data[r].total = `${data[r].total.correct.toFixed(1)}% / ${data[r].total.wrong.toFixed(1)}%`\r\n                data.total[r] = `${data.total[r].correct.toFixed(1)}% / ${data.total[r].wrong.toFixed(1)}%`\r\n            }\r\n\r\n            data.total.total = `${data.total.total.correct.toFixed(1)}% / ${data.total.total.wrong.toFixed(1)}%`\r\n\r\n            console.table(data)\r\n            return\r\n        }\r\n\r\n\r\n        const padNum = (num, percent) => {\r\n            num = percent ? num.toFixed(1) + \"%\" : num.toString()\r\n            const leftPad = Math.max(Math.floor((3*2+1 - num.length) / 2), 0)\r\n            const rightPad = Math.max(3*2+1 - (num.length + leftPad), 0)\r\n            return \" \".repeat(leftPad)+num+\" \".repeat(rightPad)\r\n        }\r\n\r\n        let colourText\r\n        let colourBackground\r\n\r\n        // Bright\r\n        process.stdout.write(\"\\n\\x1b[1m\")\r\n\r\n        for (let r=0; r<data.length; r++) {\r\n\r\n            // Bright white text\r\n            colourText = \"\\x1b[2m\\x1b[37m\"\r\n\r\n            // Count\r\n            for (let c=0; c<data[r].length; c++) {\r\n                colourBackground =  r==c ? \"\\x1b[42m\" : \"\\x1b[41m\"\r\n                process.stdout.write(`${colourText}${colourBackground}\\x1b[1m${padNum(data[r][c].count)}\\x1b[22m`)\r\n            }\r\n\r\n            // Dim green text on white background\r\n            colourText = \"\\x1b[2m\\x1b[32m\"\r\n            colourBackground = \"\\x1b[47m\"\r\n            process.stdout.write(`${colourText}${colourBackground}${padNum(data[r].total.correct, true)}`)\r\n\r\n            // Bright white text\r\n            colourText = \"\\x1b[2m\\x1b[37m\"\r\n            process.stdout.write(`${colourText}\\n`)\r\n\r\n            // Percent\r\n            for (let c=0; c<data[r].length; c++) {\r\n                colourBackground =  r==c ? \"\\x1b[42m\" : \"\\x1b[41m\"\r\n                process.stdout.write(`${colourText}${colourBackground}${padNum(data[r][c].percent, true)}`)\r\n            }\r\n\r\n            // Dim red\r\n            colourText = \"\\x1b[2m\\x1b[31m\"\r\n            colourBackground = \"\\x1b[47m\"\r\n            process.stdout.write(`${colourText}${colourBackground}${padNum(data[r].total.wrong, true)}`)\r\n\r\n            // Bright\r\n            process.stdout.write(\"\\x1b[1m\\x1b[30m\\n\")\r\n        }\r\n\r\n        // Dim green text\r\n        colourText = \"\\x1b[22m\\x1b[32m\"\r\n\r\n        // Bottom row correct percentages\r\n        for (const col of data.total) {\r\n            process.stdout.write(`${colourText}${colourBackground}${padNum(col.correct, true)}`)\r\n        }\r\n        // Total correct percentages\r\n        // Blue background\r\n        colourBackground = \"\\x1b[1m\\x1b[44m\"\r\n        process.stdout.write(`${colourText}${colourBackground}${padNum(data.total.total.correct, true)}\\n`)\r\n\r\n        // Dim red on white background\r\n        colourText = \"\\x1b[22m\\x1b[31m\"\r\n        colourBackground = \"\\x1b[47m\"\r\n\r\n        // Bottom row wrong percentages\r\n        for (const col of data.total) {\r\n            process.stdout.write(`${colourText}${colourBackground}${padNum(col.wrong, true)}`)\r\n        }\r\n\r\n        // Bright red on blue background\r\n        colourText = \"\\x1b[1m\\x1b[31m\"\r\n        colourBackground = \"\\x1b[44m\"\r\n        process.stdout.write(`${colourText}${colourBackground}${padNum(data.total.total.wrong, true)}\\n`)\r\n\r\n        // Reset\r\n        process.stdout.write(\"\\x1b[0m\\n\")\r\n    }\r\n}\r\n\r\nNetUtil.activationsIndeces = {\r\n    noactivation: -1,\r\n    sigmoid: 0,\r\n    tanh: 1,\r\n    lecuntanh: 2,\r\n    relu: 3,\r\n    lrelu: 4,\r\n    rrelu: 5,\r\n    elu: 6\r\n};\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.NetUtil = NetUtil)\r\nexports.NetUtil = NetUtil\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({Module, learningRate, activation=\"sigmoid\", updateFn=\"vanillasgd\", cost=\"meansquarederror\", layers=[],\r\n        momentum=0.9, rmsDecay, rho, lreluSlope, eluAlpha, dropout=1, l2, l1, maxNorm, weightsConfig, channels, conv, pool}) {\r\n\r\n        if (!Module) {\r\n            throw new Error(\"WASM module not provided\")\r\n        }\r\n\r\n        if (typeof activation == \"function\" || typeof cost == \"function\") {\r\n            throw new Error(\"Custom functions are not (yet) supported with WASM.\")\r\n        }\r\n\r\n        NetUtil.Module = Module\r\n        this.Module = Module\r\n        this.conv = {}\r\n        this.pool = {}\r\n        this.netInstance = this.Module.ccall(\"newNetwork\", null, null, null)\r\n        this.state = \"not-defined\"\r\n\r\n        // Learning Rate get / set\r\n        Object.defineProperty(this, \"learningRate\", {\r\n            get: this.Module.cwrap(\"getLearningRate\", null, null).bind(this, this.netInstance),\r\n            set: this.Module.cwrap(\"setLearningRate\", \"number\", null).bind(this, this.netInstance)\r\n        })\r\n\r\n        if (learningRate) this.learningRate = learningRate\r\n\r\n        NetUtil.defineProperty(this, \"dropout\", [\"number\"], [this.netInstance])\r\n        this.dropout = dropout==false ? 1 : dropout\r\n\r\n        if (l2) {\r\n            NetUtil.defineProperty(this, \"l2\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"l2Error\", [\"number\"], [this.netInstance])\r\n            this.l2 = typeof l2==\"boolean\" ? 0.001 : l2\r\n        }\r\n\r\n        if (l1) {\r\n            NetUtil.defineProperty(this, \"l1\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"l1Error\", [\"number\"], [this.netInstance])\r\n            this.l1 = typeof l1==\"boolean\" ? 0.005 : l1\r\n        }\r\n\r\n        if (maxNorm) {\r\n            NetUtil.defineProperty(this, \"maxNorm\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"maxNormTotal\", [\"number\"], [this.netInstance])\r\n            this.maxNorm = typeof maxNorm==\"boolean\" && maxNorm ? 1000 : maxNorm\r\n        }\r\n\r\n        if (channels) {\r\n            NetUtil.defineProperty(this, \"channels\", [\"number\"], [this.netInstance])\r\n            this.channels = channels\r\n        }\r\n\r\n        if (conv) {\r\n            if (conv.filterSize!=undefined)     this.conv.filterSize = conv.filterSize\r\n            if (conv.zeroPadding!=undefined)    this.conv.zeroPadding = conv.zeroPadding\r\n            if (conv.stride!=undefined)         this.conv.stride = conv.stride\r\n        }\r\n\r\n        if (pool) {\r\n            if (pool.size)      this.pool.size = pool.size\r\n            if (pool.stride)    this.pool.stride = pool.stride\r\n        }\r\n\r\n        Object.defineProperty(this, \"error\", {\r\n            get: () => Module.ccall(\"getError\", \"number\", [\"number\"], [this.netInstance])\r\n        })\r\n        Object.defineProperty(this, \"validationError\", {\r\n            get: () => Module.ccall(\"getValidationError\", \"number\", [\"number\"], [this.netInstance])\r\n        })\r\n        Object.defineProperty(this, \"lastValidationError\", {\r\n            get: () => Module.ccall(\"getLastValidationError\", \"number\", [\"number\"], [this.netInstance])\r\n        })\r\n\r\n        // Activation function get / set\r\n        this.activationName = NetUtil.format(activation)\r\n        Object.defineProperty(this, \"activation\", {\r\n            get: () => `WASM ${this.activationName}`,\r\n            set: activation => {\r\n\r\n                if (NetUtil.activationsIndeces[activation] == undefined) {\r\n                    throw new Error(`The ${activation} activation function does not exist`)\r\n                }\r\n                this.activationName = activation\r\n                this.Module.ccall(\"setActivation\", null, [\"number\", \"number\"], [this.netInstance, NetUtil.activationsIndeces[activation]])\r\n            }\r\n        })\r\n        this.activation = this.activationName\r\n\r\n        // Cost function get / set\r\n        const costIndeces = {\r\n            meansquarederror: 0,\r\n            crossentropy: 1\r\n        }\r\n        let costFunctionName = NetUtil.format(cost)\r\n        Object.defineProperty(this, \"cost\", {\r\n            get: () => `WASM ${costFunctionName}`,\r\n            set: cost => {\r\n                if (costIndeces[cost] == undefined) {\r\n                    throw new Error(`The ${cost} function does not exist`)\r\n                }\r\n                costFunctionName = cost\r\n                this.Module.ccall(\"setCostFunction\", null, [\"number\", \"number\"], [this.netInstance, costIndeces[cost]])\r\n            }\r\n        })\r\n        this.cost = costFunctionName\r\n\r\n        const updateFnIndeces = {\r\n            vanillasgd: 0,\r\n            gain: 1,\r\n            adagrad: 2,\r\n            rmsprop: 3,\r\n            adam: 4,\r\n            adadelta: 5,\r\n            momentum: 6\r\n        }\r\n        NetUtil.defineProperty(this, \"updateFn\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(updateFnIndeces).find(key => updateFnIndeces[key]==index),\r\n            setCallback: name => updateFnIndeces[name]\r\n        })\r\n        this.updateFn = NetUtil.format(updateFn)\r\n\r\n\r\n        // Weights init configs\r\n        const weightsConfigFns = {\r\n            uniform: 0,\r\n            gaussian: 1,\r\n            xavieruniform: 2,\r\n            xaviernormal: 3,\r\n            lecununiform: 4,\r\n            lecunnormal: 5\r\n        }\r\n        this.weightsConfig = {}\r\n\r\n        NetUtil.defineProperty(this.weightsConfig, \"distribution\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(weightsConfigFns).find(key => weightsConfigFns[key]==Math.round(index)),\r\n            setCallback: name => weightsConfigFns[name]\r\n        })\r\n        NetUtil.defineProperty(this.weightsConfig, \"limit\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this.weightsConfig, \"mean\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this.weightsConfig, \"stdDeviation\", [\"number\"], [this.netInstance])\r\n\r\n        this.weightsConfig.distribution = \"xavieruniform\"\r\n\r\n        if (weightsConfig!=undefined && weightsConfig.distribution) {\r\n\r\n            if (typeof weightsConfig.distribution == \"function\") {\r\n                throw new Error(\"Custom weights init functions are not (yet) supported with WASM.\")\r\n            }\r\n\r\n            this.weightsConfig.distribution = NetUtil.format(weightsConfig.distribution)\r\n        }\r\n\r\n        this.weightsConfig.limit = weightsConfig && weightsConfig.limit!=undefined ? weightsConfig.limit : 0.1\r\n        this.weightsConfig.mean = weightsConfig && weightsConfig.mean!=undefined ? weightsConfig.mean : 0\r\n        this.weightsConfig.stdDeviation = weightsConfig && weightsConfig.stdDeviation!=undefined ? weightsConfig.stdDeviation : 0.05\r\n\r\n        switch (NetUtil.format(updateFn)) {\r\n\r\n            case \"rmsprop\":\r\n                this.learningRate = this.learningRate==undefined ? 0.001 : this.learningRate\r\n                break\r\n\r\n            case \"adam\":\r\n                this.learningRate = this.learningRate==undefined ? 0.01 : this.learningRate\r\n                break\r\n\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"rho\", [\"number\"], [this.netInstance])\r\n                this.rho = rho==null ? 0.95 : rho\r\n                break\r\n\r\n            case \"momentum\":\r\n                NetUtil.defineProperty(this, \"momentum\", [\"number\"], [this.netInstance])\r\n                this.momentum = momentum\r\n                break\r\n\r\n            default:\r\n\r\n                if (learningRate==undefined) {\r\n\r\n                    switch (this.activationName) {\r\n                        case \"relu\":\r\n                        case \"lrelu\":\r\n                        case \"rrelu\":\r\n                        case \"elu\":\r\n                            this.learningRate = 0.01\r\n                            break\r\n\r\n                        case \"tanh\":\r\n                        case \"lecuntanh\":\r\n                            this.learningRate = 0.001\r\n                            break\r\n\r\n                        default:\r\n                            this.learningRate = 0.2\r\n                    }\r\n                }\r\n        }\r\n\r\n        if (this.updateFn==\"rmsprop\") {\r\n            NetUtil.defineProperty(this, \"rmsDecay\", [\"number\"], [this.netInstance])\r\n            this.rmsDecay = rmsDecay===undefined ? 0.99 : rmsDecay\r\n        }\r\n\r\n        if (this.activationName==\"lrelu\") {\r\n            NetUtil.defineProperty(this, \"lreluSlope\", [\"number\"], [this.netInstance])\r\n            this.lreluSlope = lreluSlope==undefined ? -0.0005 : lreluSlope\r\n        } else if (this.activationName==\"elu\") {\r\n            NetUtil.defineProperty(this, \"eluAlpha\", [\"number\"], [this.netInstance])\r\n            this.eluAlpha = eluAlpha==undefined ? 1 : eluAlpha\r\n        }\r\n\r\n        this.layers = []\r\n        this.epochs = 0\r\n\r\n        NetUtil.defineProperty(this, \"iterations\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"validations\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"validationInterval\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"trainingLogging\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"stoppedEarly\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingType\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingThreshold\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingBestError\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingPatienceCounter\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingPatience\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this, \"earlyStoppingPercent\", [\"number\"], [this.netInstance])\r\n\r\n        if (layers.length) {\r\n\r\n            this.state = \"constructed\"\r\n\r\n            switch (true) {\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        if (this.state == \"initialised\") {\r\n            return\r\n        }\r\n\r\n        if (this.state == \"not-defined\") {\r\n            this.layers[0] = new FCLayer(input)\r\n            this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                      : input + expected))\r\n            this.layers[2] = new FCLayer(Math.ceil(expected))\r\n        }\r\n\r\n        this.state = \"initialised\"\r\n\r\n        for (let l=0; l<this.layers.length; l++) {\r\n\r\n            const layer = this.layers[l]\r\n\r\n            switch (true) {\r\n                case layer instanceof FCLayer:\r\n                    this.Module.ccall(\"addFCLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                    break\r\n\r\n                case layer instanceof ConvLayer:\r\n                    this.Module.ccall(\"addConvLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                    break\r\n\r\n                case layer instanceof PoolLayer:\r\n                    this.Module.ccall(\"addPoolLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                    break\r\n            }\r\n\r\n            this.joinLayer(layer, l)\r\n        }\r\n\r\n        this.Module.ccall(\"initLayers\", null, [\"number\"], [this.netInstance])\r\n        const outSize = this.layers[this.layers.length-1].size\r\n        const floorFunc = map => map.map(row => row.map(v => Math.floor(v)))\r\n\r\n        NetUtil.defineMapProperty(this, \"trainingConfusionMatrix\", [\"number\"], [this.netInstance], outSize, outSize, {getCallback: floorFunc})\r\n        NetUtil.defineMapProperty(this, \"testConfusionMatrix\", [\"number\"], [this.netInstance], outSize, outSize, {getCallback: floorFunc})\r\n        NetUtil.defineMapProperty(this, \"validationConfusionMatrix\", [\"number\"], [this.netInstance], outSize, outSize, {getCallback: floorFunc})\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.net = this\r\n        layer.layerIndex = layerIndex\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.layers[layerIndex-1], layerIndex)\r\n        }\r\n        layer.init()\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        // Flatten volume inputs\r\n        if (Array.isArray(data[0])) {\r\n            const flat = []\r\n\r\n            for (let c=0; c<data.length; c++) {\r\n                for (let r=0; r<data[0].length; r++) {\r\n                    for (let v=0; v<data[0].length; v++) {\r\n                        flat.push(data[c][r][v])\r\n                    }\r\n                }\r\n            }\r\n            data = flat\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        return NetUtil.ccallArrays(\"forward\", \"array\", [\"number\", \"array\"], [this.netInstance, data], {\r\n            heapOut: \"HEAPF64\",\r\n            returnArraySize: this.layers[this.layers.length-1].neurons.length\r\n        })\r\n    }\r\n\r\n    train (data, {epochs=1, callback, miniBatchSize=1, log=true, shuffle=false, validation}={}) {\r\n\r\n        miniBatchSize = typeof miniBatchSize==\"boolean\" && miniBatchSize ? data[0].expected.length : miniBatchSize\r\n        this.Module.ccall(\"set_miniBatchSize\", null, [\"number\", \"number\"], [this.netInstance, miniBatchSize])\r\n        this.validation = validation\r\n        this.trainingLogging = log\r\n        this.stoppedEarly = false\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                this.initLayers(data[0].input.length, data[0].expected.length)\r\n            }\r\n\r\n            const startTime = Date.now()\r\n\r\n            const dimension = this.layers[0].size// data[0].input.length\r\n            const itemSize = dimension + data[0].expected.length\r\n            const itemsCount = itemSize * data.length\r\n\r\n            if (log) {\r\n                console.log(`Training started. Epochs: ${epochs} Batch size: ${miniBatchSize}`)\r\n            }\r\n\r\n            // Load training data\r\n            const typedArray = new Float32Array(itemsCount)\r\n            this.loadData(data, typedArray, itemSize, reject)\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            let elapsed\r\n\r\n            this.Module.ccall(\"loadTrainingData\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                                      [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n\r\n            if (shuffle) {\r\n                this.Module.ccall(\"shuffleTrainingData\", null, [\"number\"], [this.netInstance])\r\n            }\r\n\r\n            let validationBuf\r\n\r\n            if (this.validation) {\r\n\r\n                this.validationInterval = this.validation.interval || data.length // Default to 1 epoch\r\n\r\n                if (this.validation.earlyStopping) {\r\n                    switch (this.validation.earlyStopping.type) {\r\n                        case \"threshold\":\r\n                            this.validation.earlyStopping.threshold = this.validation.earlyStopping.threshold || 0.01\r\n                            this.earlyStoppingThreshold = this.validation.earlyStopping.threshold\r\n                            this.earlyStoppingType = 1\r\n                            break\r\n                        case \"patience\":\r\n                            this.validation.earlyStopping.patience = this.validation.earlyStopping.patience || 20\r\n                            this.earlyStoppingBestError = Infinity\r\n                            this.earlyStoppingPatienceCounter = 0\r\n                            this.earlyStoppingPatience = this.validation.earlyStopping.patience\r\n                            this.earlyStoppingType = 2\r\n                            break\r\n                        case \"divergence\":\r\n                            this.validation.earlyStopping.percent = this.validation.earlyStopping.percent || 30\r\n                            this.earlyStoppingBestError = Infinity\r\n                            this.earlyStoppingPercent = this.validation.earlyStopping.percent\r\n                            this.earlyStoppingType = 3\r\n                            break\r\n                    }\r\n                }\r\n\r\n\r\n                // Load validation data\r\n                if (this.validation.data) {\r\n                    const typedArray = new Float32Array(this.validation.data.length)\r\n                    this.loadData(this.validation.data, typedArray, itemSize , reject)\r\n                    validationBuf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n                    this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n                    this.Module.ccall(\"loadValidationData\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                                    [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n                }\r\n            }\r\n\r\n            const logAndResolve = () => {\r\n                this.Module._free(buf)\r\n                this.Module._free(validationBuf)\r\n\r\n                if (this.validation && this.validation.earlyStopping && (this.validation.earlyStopping.type == \"patience\" || this.validation.earlyStopping.type == \"divergence\")) {\r\n                    this.Module.ccall(\"restoreValidation\", null, [\"number\"], [this.netInstance])\r\n                }\r\n\r\n                if (log) {\r\n                    console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}`)\r\n                }\r\n                resolve()\r\n            }\r\n\r\n            if (callback) {\r\n\r\n                let epochIndex = 0\r\n                let iterationIndex = 0\r\n\r\n                const doEpoch = () => {\r\n\r\n                    if (this.l2) this.l2Error = 0\r\n                    if (this.l1) this.l1Error = 0\r\n\r\n                    iterationIndex = 0\r\n                    doIteration()\r\n                }\r\n\r\n                const doIteration = () => {\r\n\r\n                    this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, miniBatchSize, iterationIndex])\r\n\r\n                    callback({\r\n                        iterations: (this.iterations),\r\n                        validations: (this.validations),\r\n                        trainingError: this.error,\r\n                        validationError: this.validationError,\r\n                        elapsed: Date.now() - startTime,\r\n                        input: data[iterationIndex].input\r\n                    })\r\n\r\n                    iterationIndex += miniBatchSize\r\n\r\n                    if (iterationIndex < data.length && !this.stoppedEarly) {\r\n                        setTimeout(doIteration.bind(this), 0)\r\n                    } else {\r\n                        epochIndex++\r\n\r\n                        elapsed = Date.now() - startTime\r\n\r\n                        if (log) {\r\n                            let text = `Epoch: ${epochIndex}\\nTraining Error: ${this.error}`\r\n\r\n                            if (this.validation) {\r\n                                text += `\\nValidation Error: ${this.lastValidationError}`\r\n                            }\r\n\r\n                            if (this.l2Error!=undefined) {\r\n                                text += `\\nL2 Error: ${this.l2Error/iterationIndex}`\r\n                            }\r\n\r\n                            text += `\\nElapsed: ${NetUtil.format(elapsed, \"time\")} Average Duration: ${NetUtil.format(elapsed/epochIndex, \"time\")}`\r\n                            console.log(text)\r\n                        }\r\n\r\n                        if (epochIndex < epochs && !this.stoppedEarly) {\r\n                            doEpoch()\r\n                        } else {\r\n                            logAndResolve()\r\n                        }\r\n                    }\r\n                }\r\n                doEpoch()\r\n\r\n            } else {\r\n                for (let e=0; e<epochs; e++) {\r\n\r\n                    if (this.l2) this.l2Error = 0\r\n                    if (this.l1) this.l1Error = 0\r\n\r\n                    this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, -1, 0])\r\n                    elapsed = Date.now() - startTime\r\n\r\n                    if (log) {\r\n                        let text = `Epoch: ${e+1}\\nTraining Error: ${this.error}`\r\n\r\n                        if (validation) {\r\n                            text += `\\nValidation Error: ${this.lastValidationError}`\r\n                        }\r\n\r\n                        if (this.l2Error!=undefined) {\r\n                            text += `\\nL2 Error: ${this.l2Error/data.length}`\r\n                        }\r\n\r\n                        text += `\\nElapsed: ${NetUtil.format(elapsed, \"time\")} Average Duration: ${NetUtil.format(elapsed/(e+1), \"time\")}`\r\n                        console.log(text)\r\n                    }\r\n\r\n                    if (this.stoppedEarly) {\r\n                        break\r\n                    }\r\n                }\r\n                logAndResolve()\r\n            }\r\n        })\r\n    }\r\n\r\n    loadData (data, typedArray, itemSize, reject) {\r\n        for (let di=0; di<data.length; di++) {\r\n\r\n            if (!data[di].hasOwnProperty(\"input\") || !data[di].hasOwnProperty(\"expected\")) {\r\n                return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected'\")\r\n            }\r\n\r\n            let index = itemSize * di\r\n\r\n            // Volume input\r\n            if (Array.isArray(data[di].input[0])) {\r\n                for (let c=0; c<data[di].input.length; c++) {\r\n                    for (let r=0; r<data[di].input[0].length; r++) {\r\n                        for (let v=0; v<data[di].input[0].length; v++) {\r\n                            typedArray[index] = data[di].input[c][r][v]\r\n                            index++\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Flat input\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            for (let ei=0; ei<data[di].expected.length; ei++) {\r\n                typedArray[index] = data[di].expected[ei]\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    test (data, {log=true, callback}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            const startTime = Date.now()\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + data[0].expected.length\r\n            const itemsCount = itemSize * data.length\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            this.loadData(data, typedArray, itemSize, reject)\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            this.Module.ccall(\"loadTestingData\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n\r\n            if (callback) {\r\n\r\n                let iterationIndex = 0\r\n                let totalError = 0\r\n\r\n                const doIteration = () => {\r\n\r\n                    totalError += this.Module.ccall(\"test\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, 1, iterationIndex])\r\n\r\n                    callback({\r\n                        iterations: (iterationIndex+1),\r\n                        error: totalError/(iterationIndex+1),\r\n                        elapsed: Date.now() - startTime,\r\n                        input: data[iterationIndex].input\r\n                    })\r\n\r\n                    if (++iterationIndex < data.length) {\r\n                        setTimeout(doIteration.bind(this), 0)\r\n                    } else {\r\n                        iterationIndex\r\n\r\n                        const elapsed = Date.now() - startTime\r\n                        log && console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex, \"time\")}`)\r\n\r\n                        this.Module._free(buf)\r\n                        resolve(totalError/data.length)\r\n                    }\r\n                }\r\n\r\n                doIteration()\r\n\r\n            } else {\r\n\r\n                const avgError = this.Module.ccall(\"test\", \"number\", [\"number\", \"number\"], [this.netInstance, -1, 0])\r\n                this.Module._free(buf)\r\n\r\n                const elapsed = Date.now() - startTime\r\n\r\n                if (log) {\r\n                    console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/data.length, \"time\")}`)\r\n                }\r\n\r\n                resolve(avgError)\r\n            }\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.Module.ccall(\"resetDeltaWeights\", null, [\"number\"], [this.netInstance])\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    toIMG (IMGArrays, opts={}) {\r\n\r\n        if (!IMGArrays) {\r\n            throw new Error(\"The IMGArrays library must be provided. See the documentation for instructions.\")\r\n        }\r\n\r\n        const data = []\r\n\r\n        for (let l=1; l<this.layers.length; l++) {\r\n\r\n            const layerData = this.layers[l].toIMG()\r\n            for (let v=0; v<layerData.length; v++) {\r\n                data.push(layerData[v])\r\n            }\r\n        }\r\n\r\n        return IMGArrays.toIMG(data, opts)\r\n    }\r\n\r\n    fromIMG (rawData, IMGArrays, opts={}) {\r\n\r\n        if (!IMGArrays) {\r\n            throw new Error(\"The IMGArrays library must be provided. See the documentation for instructions.\")\r\n        }\r\n\r\n        let valI = 0\r\n        const data = IMGArrays.fromIMG(rawData, opts)\r\n\r\n        for (let l=1; l<this.layers.length; l++) {\r\n\r\n            const dataCount = this.layers[l].getDataSize()\r\n            this.layers[l].fromIMG(data.splice(0, dataCount))\r\n        }\r\n    }\r\n\r\n    printConfusionMatrix (type) {\r\n        if (type) {\r\n            NetUtil.printConfusionMatrix(NetUtil.makeConfusionMatrix(this[`${type}ConfusionMatrix`]))\r\n        } else {\r\n            // Total all data\r\n            const data = []\r\n\r\n            for (let r=0; r<this.trainingConfusionMatrix.length; r++) {\r\n                const row = []\r\n                for (let c=0; c<this.trainingConfusionMatrix.length; c++) {\r\n                    row.push(this.trainingConfusionMatrix[r][c] + this.testConfusionMatrix[r][c] + this.validationConfusionMatrix[r][c])\r\n                }\r\n                data.push(row)\r\n            }\r\n            NetUtil.printConfusionMatrix(NetUtil.makeConfusionMatrix(data))\r\n        }\r\n    }\r\n\r\n    static get version () {\r\n        return \"3.2.0\"\r\n    }\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.Network = Network)\r\nexports.Network = Network\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, neuronIndex, {updateFn}) {\r\n\r\n        const paramTypes = [\"number\", \"number\", \"number\"]\r\n        const params = [netInstance, layerIndex, neuronIndex]\r\n\r\n        NetUtil.defineProperty(this, \"sum\", paramTypes, params, {pre: \"neuron_\"})\r\n        NetUtil.defineProperty(this, \"dropped\", paramTypes, params, {\r\n            pre: \"neuron_\",\r\n            getCallback: v => v==1,\r\n            setCallback: v => v ? 1 : 0\r\n        })\r\n        NetUtil.defineProperty(this, \"activation\", paramTypes, params, {pre: \"neuron_\"})\r\n        NetUtil.defineProperty(this, \"error\", paramTypes, params, {pre: \"neuron_\"})\r\n        NetUtil.defineProperty(this, \"derivative\", paramTypes, params, {pre: \"neuron_\"})\r\n\r\n        NetUtil.defineProperty(this, \"bias\", paramTypes, params, {pre: \"neuron_\"})\r\n\r\n        if (layerIndex) {\r\n            NetUtil.defineArrayProperty(this, \"weights\", paramTypes, params, this.size, {pre: \"neuron_\"})\r\n        }\r\n\r\n        NetUtil.defineProperty(this, \"deltaBias\", paramTypes, params, {pre: \"neuron_\"})\r\n        NetUtil.defineArrayProperty(this, \"deltaWeights\", paramTypes, params, this.size, {pre: \"neuron_\"})\r\n\r\n        switch (updateFn) {\r\n            case \"gain\":\r\n                NetUtil.defineProperty(this, \"biasGain\", paramTypes, params, {pre: \"neuron_\"})\r\n                NetUtil.defineArrayProperty(this, \"weightGain\", paramTypes, params, this.size, {pre: \"neuron_\"})\r\n                break\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"biasCache\", paramTypes, params, {pre: \"neuron_\"})\r\n                NetUtil.defineArrayProperty(this, \"weightsCache\", paramTypes, params, this.size, {pre: \"neuron_\"})\r\n\r\n                if (updateFn==\"adadelta\") {\r\n                    NetUtil.defineProperty(this, \"adadeltaBiasCache\", paramTypes, params, {pre: \"neuron_\"})\r\n                    NetUtil.defineArrayProperty(this, \"adadeltaCache\", paramTypes, params, this.size, {pre: \"neuron_\"})\r\n                }\r\n                break\r\n\r\n            case \"adam\":\r\n                NetUtil.defineProperty(this, \"m\", paramTypes, params, {pre: \"neuron_\"})\r\n                NetUtil.defineProperty(this, \"v\", paramTypes, params, {pre: \"neuron_\"})\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.Neuron = Neuron)\r\nexports.Neuron = Neuron\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n    constructor (size, {stride, activation}={}) {\r\n\r\n        if (size)   this.size = size\r\n        if (stride) this.stride = stride\r\n\r\n        this.activation = false\r\n        this.activationName = activation\r\n\r\n        if (activation != undefined) {\r\n            if (typeof activation == \"boolean\" && !activation) {\r\n                activation = \"noactivation\"\r\n            }\r\n            if (typeof activation != \"string\") {\r\n                throw new Error(\"Custom activation functions are not available in the WebAssembly version\")\r\n            }\r\n            this.activationName = NetUtil.format(activation)\r\n        }\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n\r\n        this.netInstance = this.net.netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n        let channels\r\n        let prevLayerOutWidth = layer.outMapSize\r\n        const size = this.size || this.net.pool.size || 2\r\n        const stride = this.stride || this.net.pool.stride || this.size\r\n\r\n        NetUtil.defineProperty(this, \"channels\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"pool_\"})\r\n        NetUtil.defineProperty(this, \"stride\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"pool_\"})\r\n        this.size = size\r\n        this.stride = stride\r\n\r\n        switch (true) {\r\n\r\n            case layer instanceof FCLayer:\r\n                channels = this.net.channels\r\n                prevLayerOutWidth = Math.max(Math.floor(Math.sqrt(layer.size/channels)), 1)\r\n                break\r\n\r\n            case layer instanceof ConvLayer:\r\n                channels = layer.size\r\n                break\r\n\r\n            case layer instanceof PoolLayer:\r\n                channels = layer.channels\r\n                break\r\n        }\r\n\r\n        this.channels = channels\r\n\r\n        NetUtil.defineProperty(this, \"prevLayerOutWidth\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"pool_\"})\r\n        NetUtil.defineProperty(this, \"inMapValuesCount\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"pool_\"})\r\n        NetUtil.defineProperty(this, \"outMapSize\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"pool_\"})\r\n        NetUtil.defineVolumeProperty(this, \"errors\", [\"number\", \"number\"], [this.netInstance, layerIndex], channels, prevLayerOutWidth, prevLayerOutWidth, {pre: \"pool_\"})\r\n\r\n        const outMapSize = (prevLayerOutWidth - size) / stride + 1\r\n        this.outMapSize = outMapSize\r\n        this.inMapValuesCount = prevLayerOutWidth ** 2\r\n\r\n        NetUtil.defineVolumeProperty(this, \"activations\", [\"number\", \"number\"], [this.netInstance, layerIndex], channels, outMapSize, outMapSize, {pre: \"pool_\"})\r\n        NetUtil.defineVolumeProperty(this, \"indeces\", [\"number\", \"number\"], [this.netInstance, layerIndex], channels, outMapSize, outMapSize, {\r\n            pre: \"pool_\",\r\n            getCallback: vol => vol.map(map => map.map(row => row.map(val => [parseInt(val/2), val%2]))),\r\n            setCallback: vol => vol.map(map => map.map(row => row.map(([x,y]) => 2*x+y)))\r\n        })\r\n\r\n        if (outMapSize%1 != 0) {\r\n            throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${outMapSize} in pool layer at index ${layerIndex}`)\r\n        }\r\n\r\n        if (this.activationName) {\r\n            NetUtil.defineProperty(this, \"activation\", [\"number\", \"number\"], [this.netInstance, layerIndex], {\r\n                pre: \"pool_\",\r\n                getCallback: _ => `WASM ${this.activationName}`\r\n            })\r\n            this.activation = NetUtil.activationsIndeces[this.activationName]\r\n        }\r\n    }\r\n\r\n    init () {}\r\n\r\n    toJSON () {return {}}\r\n\r\n    fromJSON() {}\r\n\r\n    getDataSize () {return 0}\r\n\r\n    toIMG () {return []}\r\n\r\n    fromIMG () {}\r\n\r\n}\r\n\r\n/* istanbul ignore next */\r\ntypeof window!=\"undefined\" && (window.PoolLayer = PoolLayer)\r\nexports.PoolLayer = PoolLayer\n//# sourceMappingURL=jsNetWebAssembly.concat.js.map"]}