{"version":3,"sources":["jsNetWebAssembly.concat.js"],"names":["ConvLayer","window","exports","FCLayer","[object Object]","size","this","neurons","Array","map","n","Neuron","layerIndex","layer","nextLayer","netInstance","prevLayer","forEach","neuron","ni","init","updateFn","net","weights","bias","data","length","Error","Layer","NetMath","values","total","i","NetUtil","func","returnType","paramTypes","params","heapIn","heapOut","returnArraySize","heapMap","HEAP8","Int8Array","HEAPU8","Uint8Array","HEAP16","Int16Array","HEAPU16","Uint16Array","HEAP32","Int32Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","res","error","returnTypeParam","parameters","parameterTypes","bufs","p","isArray","typedArray","buf","Module","_malloc","BYTES_PER_ELEMENT","set","push","undefined","ccall","e","b","_free","returnData","v","value","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","self","prop","valTypes","getCallback","x","setCallback","Object","defineProperty","get","val","concat","returnSize","ccallArrays","Network","learningRate","activation","cost","layers","rmsDecay","rho","state","cwrap","bind","activationsIndeces","sigmoid","tanh","relu","activationName","format","costIndeces","meansquarederror","crossentropy","costFunctionName","updateFnIndeces","vanillaupdatefn","gain","adagrad","rmsprop","adam","adadelta","index","keys","find","key","name","epochs","iterations","every","item","Number","isInteger","initLayers","PoolLayer","input","expected","Math","ceil","abs","l","joinLayer","assignNext","assignPrev","console","warn","Promise","resolve","reject","output","startTime","now","dimension","itemSize","itemsCount","di","hasOwnProperty","ii","ei","elapsed","log","avgError","toJSON","li","fromJSON","version","neuronIndex","defineArrayProperty"],"mappings":"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","file":"jsNetWebAssembly.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.ConvLayer = ConvLayer)\r\n\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.layerIndex = 0\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (netInstance, layer, layerIndex) {\r\n        this.netInstance = netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            switch (true) {\r\n                case this.prevLayer instanceof FCLayer:\r\n                    neuron.size = this.prevLayer.size\r\n                    break\r\n            }\r\n\r\n            neuron.init(this.netInstance, this.layerIndex, ni, {\r\n                updateFn: this.net.updateFn\r\n            })\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=(neuron.weights).length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\ntypeof window==\"undefined\" && (exports.FCLayer = exports.Layer = FCLayer)\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n    static softmax (values) {\r\n        let total = 0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            total += values[i]\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            if (total) {\r\n                values[i] /= total\r\n            }\r\n        }\r\n\r\n        return values\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetMath = NetMath)\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static ccallArrays (func, returnType, paramTypes, params, {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", returnArraySize=1}={}) {\r\n\r\n        const heapMap = {}\r\n        heapMap.HEAP8 = Int8Array // int8_t\r\n        heapMap.HEAPU8 = Uint8Array // uint8_t\r\n        heapMap.HEAP16 = Int16Array // int16_t\r\n        heapMap.HEAPU16 = Uint16Array // uint16_t\r\n        heapMap.HEAP32 = Int32Array // int32_t\r\n        heapMap.HEAPU32 = Uint32Array // uint32_t\r\n        heapMap.HEAPF32 = Float32Array // float\r\n        heapMap.HEAPF64 = Float64Array // double\r\n\r\n        let res\r\n        let error\r\n        paramTypes = paramTypes || []\r\n        const returnTypeParam = returnType==\"array\" ? \"number\" : returnType\r\n        const parameters = []\r\n        const parameterTypes = []\r\n        const bufs = []\r\n\r\n        try {\r\n            if (params) {\r\n                for (let p=0; p<params.length; p++) {\r\n\r\n                    if (paramTypes[p] == \"array\" || Array.isArray(params[p])) {\r\n\r\n                        const typedArray = new heapMap[heapIn](params[p].length)\r\n\r\n                        for (let i=0; i<params[p].length; i++) {\r\n                            typedArray[i] = params[p][i]\r\n                        }\r\n\r\n                        const buf = NetUtil.Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT)\r\n\r\n                        switch (heapIn) {\r\n                            case \"HEAP8\": case \"HEAPU8\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf)\r\n                                break\r\n                            case \"HEAP16\": case \"HEAPU16\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 1)\r\n                                break\r\n                            case \"HEAP32\": case \"HEAPU32\": case \"HEAPF32\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 2)\r\n                                break\r\n                            case \"HEAPF64\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 3)\r\n                                break\r\n                        }\r\n\r\n                        bufs.push(buf)\r\n                        parameters.push(buf)\r\n                        parameters.push(params[p].length)\r\n                        parameterTypes.push(\"number\")\r\n                        parameterTypes.push(\"number\")\r\n\r\n                    } else {\r\n                        parameters.push(params[p])\r\n                        parameterTypes.push(paramTypes[p]==undefined ? \"number\" : paramTypes[p])\r\n                    }\r\n                }\r\n            }\r\n\r\n            res = NetUtil.Module.ccall(func, returnTypeParam, parameterTypes, parameters)\r\n        } catch (e) {\r\n            error = e\r\n        } finally {\r\n            for (let b=0; b<bufs.length; b++) {\r\n                NetUtil.Module._free(bufs[b])\r\n            }\r\n        }\r\n\r\n        if (error) throw error\r\n\r\n\r\n        if (returnType==\"array\") {\r\n            const returnData = []\r\n\r\n            for (let v=0; v<returnArraySize; v++) {\r\n                returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v])\r\n            }\r\n\r\n            return returnData\r\n        } else {\r\n            return res\r\n        }\r\n    }\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static defineProperty (self, prop, valTypes=[], values=[], {getCallback=x=>x, setCallback=x=>x}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(this.Module.ccall(`get_${prop}`, \"number\", valTypes, values)),\r\n            set: val => this.Module.ccall(`set_${prop}`, null, valTypes.concat(\"number\"), values.concat(setCallback(val)))\r\n        })\r\n    }\r\n\r\n    static defineArrayProperty (self, prop, valTypes, values, returnSize) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => NetUtil.ccallArrays(`get_${prop}`, \"array\", valTypes, values, {returnArraySize: returnSize, heapOut: \"HEAPF64\"}),\r\n            set: (value) => NetUtil.ccallArrays(`set_${prop}`, null, valTypes.concat(\"array\"), values.concat([value]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetUtil = NetUtil)\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({Module, learningRate, activation=\"sigmoid\", updateFn=\"vanillaupdatefn\", cost=\"meansquarederror\", layers=[],\r\n        rmsDecay, rho}) {\r\n\r\n        if (!Module) {\r\n            throw new Error(\"WASM module not provided\")\r\n        }\r\n\r\n        if (typeof activation == \"function\" || typeof cost == \"function\") {\r\n            throw new Error(\"Custom functions are not (yet) supported with WASM.\")\r\n        }\r\n\r\n        NetUtil.Module = Module\r\n        this.Module = Module\r\n        this.netInstance = this.Module.ccall(\"newNetwork\", null, null, null)\r\n        this.state = \"not-defined\"\r\n\r\n        // Learning Rate get / set\r\n        Object.defineProperty(this, \"learningRate\", {\r\n            get: this.Module.cwrap(\"getLearningRate\", null, null).bind(this, this.netInstance),\r\n            set: this.Module.cwrap(\"setLearningRate\", \"number\", null).bind(this, this.netInstance)\r\n        })\r\n\r\n        if (learningRate) this.learningRate = learningRate\r\n\r\n        // Activation function get / set\r\n        const activationsIndeces = {\r\n            sigmoid: 0,\r\n            tanh: 1,\r\n            relu: 2\r\n        }\r\n        let activationName = NetUtil.format(activation)\r\n        Object.defineProperty(this, \"activation\", {\r\n            get: () => `WASM ${activationName}`,\r\n            set: activation => {\r\n\r\n                if (activationsIndeces[activation] == undefined) {\r\n                    throw new Error(`The ${activation} function does not exist`)\r\n                }\r\n                activationName = activation\r\n                this.Module.ccall(\"setActivation\", null, [\"number\", \"number\"], [this.netInstance, activationsIndeces[activation]])\r\n            }\r\n        })\r\n        this.activation = activationName\r\n\r\n        // Cost function get / set\r\n        const costIndeces = {\r\n            meansquarederror: 0,\r\n            crossentropy: 1\r\n        }\r\n        let costFunctionName = NetUtil.format(cost)\r\n        Object.defineProperty(this, \"cost\", {\r\n            get: () => `WASM ${costFunctionName}`,\r\n            set: cost => {\r\n                if (costIndeces[cost] == undefined) {\r\n                    throw new Error(`The ${cost} function does not exist`)\r\n                }\r\n                costFunctionName = cost\r\n                this.Module.ccall(\"setCostFunction\", null, [\"number\", \"number\"], [this.netInstance, costIndeces[cost]])\r\n            }\r\n        })\r\n        this.cost = costFunctionName\r\n\r\n        const updateFnIndeces = {\r\n            vanillaupdatefn: 0,\r\n            gain: 1,\r\n            adagrad: 2,\r\n            rmsprop: 3,\r\n            adam: 4,\r\n            adadelta: 5\r\n        }\r\n        NetUtil.defineProperty(this, \"updateFn\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(updateFnIndeces).find(key => updateFnIndeces[key]==index),\r\n            setCallback: name => updateFnIndeces[name]\r\n        })\r\n        this.updateFn = NetUtil.format(updateFn)\r\n\r\n        switch (NetUtil.format(updateFn)) {\r\n\r\n            case \"rmsprop\":\r\n                this.learningRate = this.learningRate==undefined ? 0.001 : this.learningRate\r\n                break\r\n\r\n            case \"adam\":\r\n                this.learningRate = this.learningRate==undefined ? 0.01 : this.learningRate\r\n                break\r\n\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"rho\", [\"number\"], [this.netInstance])\r\n                this.rho = rho==null ? 0.95 : rho\r\n                break\r\n\r\n            default:\r\n\r\n                if (learningRate==undefined) {\r\n\r\n                    switch (activationName) {\r\n                        case \"tanh\":\r\n                            this.learningRate = 0.01\r\n                            break\r\n\r\n                        default:\r\n                            this.learningRate = 0.2\r\n                    }\r\n                }\r\n        }\r\n\r\n        if (this.updateFn==\"rmsprop\") {\r\n            NetUtil.defineProperty(this, \"rmsDecay\", [\"number\"], [this.netInstance])\r\n            this.rmsDecay = rmsDecay===undefined ? 0.99 : rmsDecay\r\n        }\r\n\r\n        this.layers = []\r\n        this.epochs = 0\r\n        this.iterations = 0\r\n\r\n\r\n        if (layers.length) {\r\n\r\n            this.state = \"constructed\"\r\n\r\n            switch (true) {\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        if (this.state == \"initialised\") {\r\n            return\r\n        }\r\n\r\n        if (this.state == \"not-defined\") {\r\n            this.layers[0] = new FCLayer(input)\r\n            this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                      : input + expected))\r\n            this.layers[2] = new FCLayer(Math.ceil(expected))\r\n        }\r\n\r\n        this.state = \"initialised\"\r\n\r\n        for (let l=0; l<this.layers.length; l++) {\r\n\r\n            const layer = this.layers[l]\r\n\r\n            if (layer instanceof FCLayer) {\r\n                this.Module.ccall(\"addFCLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                this.joinLayer(layer, l)\r\n            }\r\n        }\r\n\r\n        this.Module.ccall(\"initLayers\", null, [\"number\"], [this.netInstance])\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.net = this\r\n        layer.layerIndex = layerIndex\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.netInstance, this.layers[layerIndex-1], layerIndex)\r\n            layer.init()\r\n        }\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        return NetUtil.ccallArrays(\"forward\", \"array\", [\"number\", \"array\"], [this.netInstance, data], {\r\n            heapOut: \"HEAPF64\",\r\n            returnArraySize: this.layers[this.layers.length-1].neurons.length\r\n        })\r\n    }\r\n\r\n    train (data, {epochs=1}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                this.initLayers(data[0].input.length, (data[0].expected || data[0].output).length)\r\n            }\r\n\r\n            const startTime = Date.now()\r\n\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                if (!data[di].hasOwnProperty(\"input\") || (!data[di].hasOwnProperty(\"expected\") && !data[di].hasOwnProperty(\"output\"))) {\r\n                    return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\")\r\n                }\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            for (let e=0; e<epochs; e++) {\r\n                this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                                [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            }\r\n\r\n            this.Module._free(buf)\r\n            const elapsed = Date.now() - startTime\r\n            console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}`)\r\n            resolve()\r\n        })\r\n    }\r\n\r\n    test (data, {log=true}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            const startTime = Date.now()\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n            const avgError = this.Module.ccall(\"test\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n            this.Module._free(buf)\r\n\r\n            const elapsed = Date.now() - startTime\r\n\r\n            if (log) {\r\n                console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/data.length, \"time\")}`)\r\n            }\r\n\r\n            resolve(avgError)\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.Module.ccall(\"resetDeltaWeights\", null, [\"number\"], [this.netInstance])\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    static get version () {\r\n        return \"2.1.1\"\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Network = Network)\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, neuronIndex, {updateFn}) {\r\n\r\n        NetUtil.defineArrayProperty(this, \"weights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n        NetUtil.defineProperty(this, \"bias\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n        NetUtil.defineArrayProperty(this, \"deltaWeights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n        switch (updateFn) {\r\n            case \"gain\":\r\n                NetUtil.defineProperty(this, \"biasGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineArrayProperty(this, \"weightGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n                break\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"biasCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineArrayProperty(this, \"weightsCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n                if (updateFn==\"adadelta\") {\r\n                    NetUtil.defineProperty(this, \"adadeltaBiasCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                    NetUtil.defineArrayProperty(this, \"adadeltaCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n                }\r\n                break\r\n\r\n            case \"adam\":\r\n                NetUtil.defineProperty(this, \"m\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineProperty(this, \"v\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                break\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Neuron = Neuron)\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.PoolLayer = PoolLayer)\r\n\n//# sourceMappingURL=jsNetWebAssembly.concat.js.map"]}