{"version":3,"sources":["jsNetWebAssembly.concat.js"],"names":["ConvLayer","[object Object]","size","filterSize","zeroPadding","stride","activation","this","layerIndex","undefined","Error","NetUtil","format","layer","nextLayer","netInstance","net","prevLayer","defineProperty","pre","conv","channels","FCLayer","Math","floor","prevLayerOutWidth","max","sqrt","outMapSize","outSize","inMapValuesCount","pow","inZPMapValuesCount","Module","ccall","activationsIndeces","activationName","filters","Array","map","f","Filter","forEach","filter","fi","init","updateFn","weights","bias","data","length","window","exports","neurons","n","Neuron","neuron","ni","Layer","filterIndex","paramTypes","params","defineVolumeProperty","NetMath","values","total","i","func","returnType","heapIn","heapOut","returnArraySize","heapMap","HEAP8","Int8Array","HEAPU8","Uint8Array","HEAP16","Int16Array","HEAPU16","Uint16Array","HEAP32","Int32Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","res","error","returnTypeParam","parameters","parameterTypes","bufs","p","isArray","typedArray","buf","_malloc","BYTES_PER_ELEMENT","set","push","e","b","_free","returnData","v","depth","rows","columns","totalValues","parameter","isVolume","flat","d","r","c","splice","ccallArrays","vol","row","value","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getSeconds","getHours","getMinutes","join","self","prop","valTypes","getCallback","x","setCallback","Object","get","val","concat","returnSize","ccallVolume","sigmoid","tanh","lecuntanh","relu","lrelu","rrelu","elu","Network","learningRate","cost","layers","rmsDecay","rho","lreluSlope","eluAlpha","dropout","l2","l1","maxNorm","weightsConfig","state","cwrap","bind","costIndeces","meansquarederror","crossentropy","costFunctionName","updateFnIndeces","vanillaupdatefn","gain","adagrad","rmsprop","adam","adadelta","index","keys","find","key","name","weightsConfigFns","uniform","gaussian","xavieruniform","xaviernormal","lecununiform","lecunnormal","round","distribution","limit","mean","stdDeviation","epochs","iterations","every","item","Number","isInteger","initLayers","PoolLayer","input","expected","ceil","abs","l","joinLayer","assignNext","assignPrev","console","warn","callback","miniBatchSize","log","shuffle","Promise","resolve","reject","output","startTime","now","dimension","itemSize","itemsCount","di","hasOwnProperty","ii","ei","elapsed","epochIndex","iterationIndex","doEpoch","l2Error","l1Error","doIteration","setTimeout","totalError","avgError","toJSON","li","fromJSON","version","neuronIndex","defineArrayProperty"],"mappings":"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","file":"jsNetWebAssembly.min.js","sourcesContent":["\"use strict\"\r\n\r\nclass ConvLayer {\r\n\r\n    constructor (size, {filterSize, zeroPadding, stride, activation}={}) {\r\n\r\n        this.size = size\r\n        this.stride = stride\r\n        this.filterSize = filterSize\r\n        this.layerIndex = 0\r\n        this.zeroPadding = zeroPadding\r\n\r\n        if (activation != undefined) {\r\n            if (typeof activation != \"string\") {\r\n                throw new Error(\"Only string activation functions available in the WebAssembly version\")\r\n            }\r\n            this.activation = NetUtil.format(activation)\r\n        }\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n\r\n        this.netInstance = this.net.netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n\r\n        NetUtil.defineProperty(this, \"channels\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"filterSize\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"stride\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"zeroPadding\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n\r\n        const stride = this.stride || this.net.conv.stride || 1\r\n        const filterSize = this.filterSize || this.net.conv.filterSize || 3\r\n        let zeroPadding = this.zeroPadding\r\n\r\n        this.size = this.size || 4\r\n        let channels\r\n\r\n        switch (true) {\r\n            case layer instanceof FCLayer:\r\n                channels = this.net.channels || 1\r\n                break\r\n\r\n            case layer instanceof ConvLayer:\r\n                channels = layer.size\r\n                break\r\n        }\r\n\r\n        if (zeroPadding == undefined) {\r\n            zeroPadding = this.net.conv.zeroPadding==undefined ? Math.floor(filterSize/2) : this.net.conv.zeroPadding\r\n        }\r\n\r\n        this.channels = channels\r\n        this.filterSize = filterSize\r\n        this.stride = stride\r\n        this.zeroPadding = zeroPadding\r\n\r\n        // Caching calculations\r\n        const prevLayerOutWidth = layer instanceof FCLayer ? Math.max(Math.floor(Math.sqrt(layer.size/channels)), 1)\r\n                                                           : layer.outMapSize\r\n\r\n        NetUtil.defineProperty(this, \"inMapValuesCount\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"inZPMapValuesCount\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n        NetUtil.defineProperty(this, \"outMapSize\", [\"number\", \"number\"], [this.netInstance, layerIndex], {pre: \"conv_\"})\r\n\r\n        const outSize = (prevLayerOutWidth - filterSize + 2*zeroPadding) / stride + 1\r\n        this.inMapValuesCount = Math.pow(prevLayerOutWidth, 2)\r\n        this.inZPMapValuesCount = Math.pow(prevLayerOutWidth + zeroPadding*2, 2)\r\n        this.outMapSize = outSize\r\n\r\n        if (outSize%1!=0) {\r\n            throw new Error(`Misconfigured hyperparameters. Activation volume dimensions would be ${outSize} in conv layer at index ${layerIndex}`)\r\n        }\r\n\r\n        if (this.activation != false) {\r\n            this.net.Module.ccall(\"setConvActivation\", null, [\"number\", \"number\", \"number\"],\r\n                [this.netInstance, NetUtil.activationsIndeces[this.activation||this.net.activationName], layerIndex])\r\n        }\r\n\r\n        this.filters = [...new Array(this.size)].map(f => new Filter())\r\n    }\r\n\r\n    init () {\r\n        this.filters.forEach((filter, fi) => {\r\n            filter.init(this.netInstance, this.layerIndex, fi, {\r\n                updateFn: this.net.updateFn,\r\n                filterSize: this.filterSize,\r\n                channels: this.channels\r\n            })\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.filters.map(filter => {\r\n                return {\r\n                    bias: filter.bias,\r\n                    weights: filter.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n        this.filters.forEach((filter, fi) => {\r\n\r\n            if (data.weights[fi].weights.length != filter.weights.length) {\r\n                throw new Error(`Mismatched weights depth. Given: ${data.weights[fi].weights.length} Existing: ${filter.weights.length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            if (data.weights[fi].weights[0].length != filter.weights[0].length) {\r\n                throw new Error(`Mismatched weights size. Given: ${data.weights[fi].weights[0].length} Existing: ${filter.weights[0].length}. At: layers[${layerIndex}], filters[${fi}]`)\r\n            }\r\n\r\n            filter.bias = data.weights[fi].bias\r\n            filter.weights = data.weights[fi].weights\r\n        })\r\n    }\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.ConvLayer = ConvLayer)\r\n\r\n\"use strict\"\r\n\r\nclass FCLayer {\r\n\r\n    constructor (size) {\r\n        this.size = size\r\n        this.neurons = [...new Array(size)].map(n => new Neuron())\r\n        this.layerIndex = 0\r\n    }\r\n\r\n    assignNext (layer) {\r\n        this.nextLayer = layer\r\n    }\r\n\r\n    assignPrev (layer, layerIndex) {\r\n        this.netInstance = this.net.netInstance\r\n        this.prevLayer = layer\r\n        this.layerIndex = layerIndex\r\n    }\r\n\r\n    init () {\r\n        this.neurons.forEach((neuron, ni) => {\r\n            switch (true) {\r\n\r\n                case this.prevLayer instanceof FCLayer:\r\n                    neuron.size = this.prevLayer.size\r\n                    break\r\n\r\n                case this.prevLayer instanceof ConvLayer:\r\n                    neuron.size = this.prevLayer.filters.length * this.prevLayer.outMapSize**2\r\n                    break\r\n            }\r\n\r\n            neuron.init(this.netInstance, this.layerIndex, ni, {\r\n                updateFn: this.net.updateFn\r\n            })\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            weights: this.neurons.map(neuron => {\r\n                return {\r\n                    bias: neuron.bias,\r\n                    weights: neuron.weights\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    fromJSON (data, layerIndex) {\r\n\r\n        this.neurons.forEach((neuron, ni) => {\r\n\r\n            if (data.weights[ni].weights.length!=(neuron.weights).length) {\r\n                throw new Error(`Mismatched weights count. Given: ${data.weights[ni].weights.length} Existing: ${neuron.weights.length}. At layers[${layerIndex}], neurons[${ni}]`)\r\n            }\r\n\r\n            neuron.bias = data.weights[ni].bias\r\n            neuron.weights = data.weights[ni].weights\r\n        })\r\n    }\r\n}\r\n\r\nconst Layer = FCLayer\r\n\r\ntypeof window==\"undefined\" && (exports.FCLayer = exports.Layer = FCLayer)\r\n\"use strict\"\r\n\r\nclass Filter {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, filterIndex, {updateFn, channels, filterSize}) {\r\n\r\n        const paramTypes = [\"number\", \"number\", \"number\"]\r\n        const params = [netInstance, layerIndex, filterIndex]\r\n\r\n        NetUtil.defineProperty(this, \"bias\", paramTypes, params, {pre: \"filter_\"})\r\n        NetUtil.defineVolumeProperty(this, \"weights\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n        NetUtil.defineProperty(this, \"deltaBias\", paramTypes, params, {pre: \"filter_\"})\r\n        NetUtil.defineVolumeProperty(this, \"deltaWeights\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n\r\n        switch (updateFn) {\r\n            case \"gain\":\r\n                NetUtil.defineProperty(this, \"biasGain\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineVolumeProperty(this, \"weightGain\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n                break\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"biasCache\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineVolumeProperty(this, \"weightsCache\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n\r\n                if (updateFn == \"adadelta\") {\r\n                    NetUtil.defineProperty(this, \"adadeltaBiasCache\", paramTypes, params, {pre: \"filter_\"})\r\n                    NetUtil.defineVolumeProperty(this, \"adadeltaWeightsCache\", paramTypes, params, channels, filterSize, filterSize, {pre: \"filter_\"})\r\n                }\r\n                break\r\n            case \"adam\":\r\n                NetUtil.defineProperty(this, \"m\", paramTypes, params, {pre: \"filter_\"})\r\n                NetUtil.defineProperty(this, \"v\", paramTypes, params, {pre: \"filter_\"})\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Filter = Filter)\r\n\"use strict\"\r\n\r\nclass NetMath {\r\n    static softmax (values) {\r\n        let total = 0\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            total += values[i]\r\n        }\r\n\r\n        for (let i=0; i<values.length; i++) {\r\n            if (total) {\r\n                values[i] /= total\r\n            }\r\n        }\r\n\r\n        return values\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetMath = NetMath)\r\n\"use strict\"\r\n\r\nclass NetUtil {\r\n\r\n    static ccallArrays (func, returnType, paramTypes, params, {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", returnArraySize=1}={}) {\r\n\r\n        const heapMap = {}\r\n        heapMap.HEAP8 = Int8Array // int8_t\r\n        heapMap.HEAPU8 = Uint8Array // uint8_t\r\n        heapMap.HEAP16 = Int16Array // int16_t\r\n        heapMap.HEAPU16 = Uint16Array // uint16_t\r\n        heapMap.HEAP32 = Int32Array // int32_t\r\n        heapMap.HEAPU32 = Uint32Array // uint32_t\r\n        heapMap.HEAPF32 = Float32Array // float\r\n        heapMap.HEAPF64 = Float64Array // double\r\n\r\n        let res\r\n        let error\r\n        paramTypes = paramTypes || []\r\n        const returnTypeParam = returnType==\"array\" ? \"number\" : returnType\r\n        const parameters = []\r\n        const parameterTypes = []\r\n        const bufs = []\r\n\r\n        try {\r\n            if (params) {\r\n                for (let p=0; p<params.length; p++) {\r\n\r\n                    if (paramTypes[p] == \"array\" || Array.isArray(params[p])) {\r\n\r\n                        const typedArray = new heapMap[heapIn](params[p].length)\r\n\r\n                        for (let i=0; i<params[p].length; i++) {\r\n                            typedArray[i] = params[p][i]\r\n                        }\r\n\r\n                        const buf = NetUtil.Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT)\r\n\r\n                        switch (heapIn) {\r\n                            case \"HEAP8\": case \"HEAPU8\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf)\r\n                                break\r\n                            case \"HEAP16\": case \"HEAPU16\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 1)\r\n                                break\r\n                            case \"HEAP32\": case \"HEAPU32\": case \"HEAPF32\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 2)\r\n                                break\r\n                            case \"HEAPF64\":\r\n                                NetUtil.Module[heapIn].set(typedArray, buf >> 3)\r\n                                break\r\n                        }\r\n\r\n                        bufs.push(buf)\r\n                        parameters.push(buf)\r\n                        parameters.push(params[p].length)\r\n                        parameterTypes.push(\"number\")\r\n                        parameterTypes.push(\"number\")\r\n\r\n                    } else {\r\n                        parameters.push(params[p])\r\n                        parameterTypes.push(paramTypes[p]==undefined ? \"number\" : paramTypes[p])\r\n                    }\r\n                }\r\n            }\r\n\r\n            res = NetUtil.Module.ccall(func, returnTypeParam, parameterTypes, parameters)\r\n        } catch (e) {\r\n            error = e\r\n        } finally {\r\n            for (let b=0; b<bufs.length; b++) {\r\n                NetUtil.Module._free(bufs[b])\r\n            }\r\n        }\r\n\r\n        if (error) throw error\r\n\r\n\r\n        if (returnType==\"array\") {\r\n            const returnData = []\r\n\r\n            for (let v=0; v<returnArraySize; v++) {\r\n                returnData.push(NetUtil.Module[heapOut][res/heapMap[heapOut].BYTES_PER_ELEMENT+v])\r\n            }\r\n\r\n            return returnData\r\n        } else {\r\n            return res\r\n        }\r\n    }\r\n\r\n    static ccallVolume (func, returnType, paramTypes=[], params=[], {heapIn=\"HEAPF32\", heapOut=\"HEAPF32\", depth=1, rows=1, columns=rows}={}) {\r\n\r\n        const totalValues = depth * rows * columns\r\n        const parameters = []\r\n        const parameterTypes = []\r\n\r\n        // Loop through parameters, check if they are volumes, flatten them, and send them along with their dimensions\r\n        for (let p=0; p<params.length; p++) {\r\n\r\n            let parameter = params[p]\r\n            const isVolume = Array.isArray(parameter) && Array.isArray(parameter[0]) && Array.isArray(parameter[0][0])\r\n\r\n            if (paramTypes[p] == \"volume\" || isVolume) {\r\n                const flat = []\r\n\r\n                for (let d=0; d<parameter.length; d++) {\r\n                    for (let r=0; r<parameter[d].length; r++) {\r\n                        for (let c=0; c<parameter[d][r].length; c++) {\r\n                            flat.push(parameter[d][r][c])\r\n                        }\r\n                    }\r\n                }\r\n\r\n                parameters.splice(parameters.length, 0, flat, parameter.length, parameter[0].length, parameter[0][0].length)\r\n                parameterTypes.splice(parameterTypes.length, 0, \"array\", \"number\", \"number\", \"number\")\r\n\r\n            } else {\r\n                parameters.push(parameter)\r\n                parameterTypes.push(paramTypes[p])\r\n            }\r\n        }\r\n\r\n        const res = NetUtil.ccallArrays(func, returnType==\"volume\" ? \"array\" : returnType, parameterTypes, parameters, {heapIn, heapOut, returnArraySize: totalValues})\r\n        const vol = []\r\n\r\n        if (returnType == \"volume\") {\r\n            for (let d=0; d<depth; d++) {\r\n                const map = []\r\n\r\n                for (let r=0; r<rows; r++) {\r\n                    const row = []\r\n\r\n                    for (let c=0; c<columns; c++) {\r\n                        row.push(res[d * rows * columns + r * columns + c])\r\n                    }\r\n                    map.push(row)\r\n                }\r\n                vol.push(map)\r\n            }\r\n            return vol\r\n        }\r\n\r\n        return res\r\n    }\r\n\r\n    static format (value, type=\"string\") {\r\n        switch (true) {\r\n\r\n            case type==\"string\" && typeof value==\"string\":\r\n                value = value.replace(/(_|\\s)/g, \"\").toLowerCase()\r\n                break\r\n\r\n            case type==\"time\" && typeof value==\"number\":\r\n                const date = new Date(value)\r\n                const formatted = []\r\n\r\n                if (value < 1000) {\r\n                    formatted.push(`${date.getMilliseconds()}ms`)\r\n\r\n                } else if (value < 60000) {\r\n                    formatted.push(`${date.getSeconds()}.${date.getMilliseconds()}s`)\r\n\r\n                } else {\r\n\r\n                    if (value >= 3600000) formatted.push(`${date.getHours()}h`)\r\n\r\n                    formatted.push(`${date.getMinutes()}m`)\r\n                    formatted.push(`${date.getSeconds()}s`)\r\n                }\r\n\r\n                value = formatted.join(\" \")\r\n                break\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static defineProperty (self, prop, valTypes=[], values=[], {getCallback=x=>x, setCallback=x=>x, pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => getCallback(this.Module.ccall(`get_${pre}${prop}`, \"number\", valTypes, values)),\r\n            set: val => this.Module.ccall(`set_${pre}${prop}`, null, valTypes.concat(\"number\"), values.concat(setCallback(val)))\r\n        })\r\n    }\r\n\r\n    static defineArrayProperty (self, prop, valTypes, values, returnSize) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => NetUtil.ccallArrays(`get_${prop}`, \"array\", valTypes, values, {returnArraySize: returnSize, heapOut: \"HEAPF64\"}),\r\n            set: (value) => NetUtil.ccallArrays(`set_${prop}`, null, valTypes.concat(\"array\"), values.concat([value]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n\r\n    static defineVolumeProperty (self, prop, valTypes, values, depth, rows, columns, {pre=\"\"}={}) {\r\n        Object.defineProperty(self, prop, {\r\n            get: () => NetUtil.ccallVolume(`get_${pre}${prop}`, \"volume\", valTypes, values, {depth, rows, columns, heapOut: \"HEAPF64\"}),\r\n            set: (value) => NetUtil.ccallVolume(`set_${pre}${prop}`, null, valTypes.concat(\"array\"), values.concat([value]), {heapIn: \"HEAPF64\"})\r\n        })\r\n    }\r\n}\r\n\r\nNetUtil.activationsIndeces = {\r\n    sigmoid: 0,\r\n    tanh: 1,\r\n    lecuntanh: 2,\r\n    relu: 3,\r\n    lrelu: 4,\r\n    rrelu: 5,\r\n    elu: 6\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.NetUtil = NetUtil)\r\n\"use strict\"\r\n\r\nclass Network {\r\n\r\n    constructor ({Module, learningRate, activation=\"sigmoid\", updateFn=\"vanillaupdatefn\", cost=\"meansquarederror\", layers=[],\r\n        rmsDecay, rho, lreluSlope, eluAlpha, dropout=1, l2=true, l1=true, maxNorm, weightsConfig, channels, conv}) {\r\n\r\n        if (!Module) {\r\n            throw new Error(\"WASM module not provided\")\r\n        }\r\n\r\n        if (typeof activation == \"function\" || typeof cost == \"function\") {\r\n            throw new Error(\"Custom functions are not (yet) supported with WASM.\")\r\n        }\r\n\r\n        NetUtil.Module = Module\r\n        this.Module = Module\r\n        this.conv = {}\r\n        this.netInstance = this.Module.ccall(\"newNetwork\", null, null, null)\r\n        this.state = \"not-defined\"\r\n\r\n        // Learning Rate get / set\r\n        Object.defineProperty(this, \"learningRate\", {\r\n            get: this.Module.cwrap(\"getLearningRate\", null, null).bind(this, this.netInstance),\r\n            set: this.Module.cwrap(\"setLearningRate\", \"number\", null).bind(this, this.netInstance)\r\n        })\r\n\r\n        if (learningRate) this.learningRate = learningRate\r\n\r\n        NetUtil.defineProperty(this, \"dropout\", [\"number\"], [this.netInstance])\r\n        this.dropout = dropout==false ? 1 : dropout\r\n\r\n        if (l2) {\r\n            NetUtil.defineProperty(this, \"l2\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"l2Error\", [\"number\"], [this.netInstance])\r\n            this.l2 = typeof l2==\"boolean\" ? 0.001 : l2\r\n        }\r\n\r\n        if (l1) {\r\n            NetUtil.defineProperty(this, \"l1\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"l1Error\", [\"number\"], [this.netInstance])\r\n            this.l1 = typeof l1==\"boolean\" ? 0.005 : l1\r\n        }\r\n\r\n        if (maxNorm) {\r\n            NetUtil.defineProperty(this, \"maxNorm\", [\"number\"], [this.netInstance])\r\n            NetUtil.defineProperty(this, \"maxNormTotal\", [\"number\"], [this.netInstance])\r\n            this.maxNorm = typeof maxNorm==\"boolean\" && maxNorm ? 1000 : maxNorm\r\n        }\r\n\r\n        if (channels) {\r\n            NetUtil.defineProperty(this, \"channels\", [\"number\"], [this.netInstance])\r\n            this.channels = channels\r\n        }\r\n\r\n        if (conv) {\r\n\r\n            if (conv.filterSize != undefined) {\r\n                NetUtil.defineProperty(this.conv, \"filterSize\", [\"number\"], [this.netInstance])\r\n                this.conv.filterSize = conv.filterSize\r\n            }\r\n\r\n            if (conv.zeroPadding != undefined) {\r\n                NetUtil.defineProperty(this.conv, \"zeroPadding\", [\"number\"], [this.netInstance])\r\n                this.conv.zeroPadding = conv.zeroPadding\r\n            }\r\n\r\n            if (conv.stride != undefined) {\r\n                NetUtil.defineProperty(this.conv, \"stride\", [\"number\"], [this.netInstance])\r\n                this.conv.stride = conv.stride\r\n            }\r\n        }\r\n\r\n        Object.defineProperty(this, \"error\", {\r\n            get: () => Module.ccall(\"getError\", \"number\", [\"number\"], [this.netInstance])\r\n        })\r\n\r\n        // Activation function get / set\r\n        this.activationName = NetUtil.format(activation)\r\n        Object.defineProperty(this, \"activation\", {\r\n            get: () => `WASM ${this.activationName}`,\r\n            set: activation => {\r\n\r\n                if (NetUtil.activationsIndeces[activation] == undefined) {\r\n                    throw new Error(`The ${activation} activation function does not exist`)\r\n                }\r\n                this.activationName = activation\r\n                this.Module.ccall(\"setActivation\", null, [\"number\", \"number\"], [this.netInstance, NetUtil.activationsIndeces[activation]])\r\n            }\r\n        })\r\n        this.activation = this.activationName\r\n\r\n        // Cost function get / set\r\n        const costIndeces = {\r\n            meansquarederror: 0,\r\n            crossentropy: 1\r\n        }\r\n        let costFunctionName = NetUtil.format(cost)\r\n        Object.defineProperty(this, \"cost\", {\r\n            get: () => `WASM ${costFunctionName}`,\r\n            set: cost => {\r\n                if (costIndeces[cost] == undefined) {\r\n                    throw new Error(`The ${cost} function does not exist`)\r\n                }\r\n                costFunctionName = cost\r\n                this.Module.ccall(\"setCostFunction\", null, [\"number\", \"number\"], [this.netInstance, costIndeces[cost]])\r\n            }\r\n        })\r\n        this.cost = costFunctionName\r\n\r\n        const updateFnIndeces = {\r\n            vanillaupdatefn: 0,\r\n            gain: 1,\r\n            adagrad: 2,\r\n            rmsprop: 3,\r\n            adam: 4,\r\n            adadelta: 5\r\n        }\r\n        NetUtil.defineProperty(this, \"updateFn\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(updateFnIndeces).find(key => updateFnIndeces[key]==index),\r\n            setCallback: name => updateFnIndeces[name]\r\n        })\r\n        this.updateFn = NetUtil.format(updateFn)\r\n\r\n\r\n        // Weights init configs\r\n        const weightsConfigFns = {\r\n            uniform: 0,\r\n            gaussian: 1,\r\n            xavieruniform: 2,\r\n            xaviernormal: 3,\r\n            lecununiform: 4,\r\n            lecunnormal: 5\r\n        }\r\n        this.weightsConfig = {}\r\n\r\n        NetUtil.defineProperty(this.weightsConfig, \"distribution\", [\"number\"], [this.netInstance], {\r\n            getCallback: index => Object.keys(weightsConfigFns).find(key => weightsConfigFns[key]==Math.round(index)),\r\n            setCallback: name => weightsConfigFns[name]\r\n        })\r\n        NetUtil.defineProperty(this.weightsConfig, \"limit\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this.weightsConfig, \"mean\", [\"number\"], [this.netInstance])\r\n        NetUtil.defineProperty(this.weightsConfig, \"stdDeviation\", [\"number\"], [this.netInstance])\r\n\r\n        this.weightsConfig.distribution = \"xavieruniform\"\r\n\r\n        if (weightsConfig!=undefined && weightsConfig.distribution) {\r\n\r\n            if (typeof weightsConfig.distribution == \"function\") {\r\n                throw new Error(\"Custom weights init functions are not (yet) supported with WASM.\")\r\n            }\r\n\r\n            this.weightsConfig.distribution = NetUtil.format(weightsConfig.distribution)\r\n        }\r\n\r\n        this.weightsConfig.limit = weightsConfig && weightsConfig.limit!=undefined ? weightsConfig.limit : 0.1\r\n        this.weightsConfig.mean = weightsConfig && weightsConfig.mean!=undefined ? weightsConfig.mean : 0\r\n        this.weightsConfig.stdDeviation = weightsConfig && weightsConfig.stdDeviation!=undefined ? weightsConfig.stdDeviation : 0.05\r\n\r\n        switch (NetUtil.format(updateFn)) {\r\n\r\n            case \"rmsprop\":\r\n                this.learningRate = this.learningRate==undefined ? 0.001 : this.learningRate\r\n                break\r\n\r\n            case \"adam\":\r\n                this.learningRate = this.learningRate==undefined ? 0.01 : this.learningRate\r\n                break\r\n\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"rho\", [\"number\"], [this.netInstance])\r\n                this.rho = rho==null ? 0.95 : rho\r\n                break\r\n\r\n            default:\r\n\r\n                if (learningRate==undefined) {\r\n\r\n                    switch (this.activationName) {\r\n                        case \"relu\":\r\n                        case \"lrelu\":\r\n                        case \"rrelu\":\r\n                        case \"elu\":\r\n                            this.learningRate = 0.01\r\n                            break\r\n\r\n                        case \"tanh\":\r\n                        case \"lecuntanh\":\r\n                            this.learningRate = 0.001\r\n                            break\r\n\r\n                        default:\r\n                            this.learningRate = 0.2\r\n                    }\r\n                }\r\n        }\r\n\r\n        if (this.updateFn==\"rmsprop\") {\r\n            NetUtil.defineProperty(this, \"rmsDecay\", [\"number\"], [this.netInstance])\r\n            this.rmsDecay = rmsDecay===undefined ? 0.99 : rmsDecay\r\n        }\r\n\r\n        if (this.activationName==\"lrelu\") {\r\n            NetUtil.defineProperty(this, \"lreluSlope\", [\"number\"], [this.netInstance])\r\n            this.lreluSlope = lreluSlope==undefined ? -0.0005 : lreluSlope\r\n        } else if (this.activationName==\"elu\") {\r\n            NetUtil.defineProperty(this, \"eluAlpha\", [\"number\"], [this.netInstance])\r\n            this.eluAlpha = eluAlpha==undefined ? 1 : eluAlpha\r\n        }\r\n\r\n        this.layers = []\r\n        this.epochs = 0\r\n        this.iterations = 0\r\n\r\n\r\n        if (layers.length) {\r\n\r\n            this.state = \"constructed\"\r\n\r\n            switch (true) {\r\n                case layers.every(item => Number.isInteger(item)):\r\n                    this.layers = layers.map(size => new FCLayer(size))\r\n                    this.initLayers()\r\n                    break\r\n\r\n                case layers.every(layer => layer instanceof FCLayer || layer instanceof ConvLayer || layer instanceof PoolLayer):\r\n                    this.layers = layers\r\n                    this.initLayers()\r\n                    break\r\n\r\n                default:\r\n                    throw new Error(\"There was an error constructing from the layers given.\")\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    initLayers (input, expected) {\r\n\r\n        if (this.state == \"initialised\") {\r\n            return\r\n        }\r\n\r\n        if (this.state == \"not-defined\") {\r\n            this.layers[0] = new FCLayer(input)\r\n            this.layers[1] = new FCLayer(Math.ceil(input/expected > 5 ? expected + (Math.abs(input-expected))/4\r\n                                                                      : input + expected))\r\n            this.layers[2] = new FCLayer(Math.ceil(expected))\r\n        }\r\n\r\n        this.state = \"initialised\"\r\n\r\n        for (let l=0; l<this.layers.length; l++) {\r\n\r\n            const layer = this.layers[l]\r\n\r\n            switch (true) {\r\n                case layer instanceof FCLayer:\r\n                    this.Module.ccall(\"addFCLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                    break\r\n\r\n                case layer instanceof ConvLayer:\r\n                    this.Module.ccall(\"addConvLayer\", null, [\"number\", \"number\"], [this.netInstance, layer.size])\r\n                    break\r\n            }\r\n\r\n            this.joinLayer(layer, l)\r\n        }\r\n\r\n        this.Module.ccall(\"initLayers\", null, [\"number\"], [this.netInstance])\r\n    }\r\n\r\n    joinLayer (layer, layerIndex) {\r\n\r\n        layer.net = this\r\n        layer.layerIndex = layerIndex\r\n\r\n        if (layerIndex) {\r\n            this.layers[layerIndex-1].assignNext(layer)\r\n            layer.assignPrev(this.layers[layerIndex-1], layerIndex)\r\n            layer.init()\r\n        }\r\n    }\r\n\r\n    forward (data) {\r\n\r\n        if (this.state!=\"initialised\") {\r\n            throw new Error(\"The network layers have not been initialised.\")\r\n        }\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No data passed to Network.forward()\")\r\n        }\r\n\r\n        if (data.length != this.layers[0].neurons.length) {\r\n            console.warn(\"Input data length did not match input layer neurons count.\")\r\n        }\r\n\r\n        return NetUtil.ccallArrays(\"forward\", \"array\", [\"number\", \"array\"], [this.netInstance, data], {\r\n            heapOut: \"HEAPF64\",\r\n            returnArraySize: this.layers[this.layers.length-1].neurons.length\r\n        })\r\n    }\r\n\r\n    train (data, {epochs=1, callback, miniBatchSize=1, log=true, shuffle=false}={}) {\r\n\r\n        miniBatchSize = typeof miniBatchSize==\"boolean\" && miniBatchSize ? data[0].expected.length : miniBatchSize\r\n        this.Module.ccall(\"set_miniBatchSize\", null, [\"number\", \"number\"], [this.netInstance, miniBatchSize])\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                return void reject(\"No data provided\")\r\n            }\r\n\r\n            if (this.state != \"initialised\") {\r\n                this.initLayers(data[0].input.length, (data[0].expected || data[0].output).length)\r\n            }\r\n\r\n            const startTime = Date.now()\r\n\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            if (log) {\r\n                console.log(`Training started. Epochs: ${epochs} Batch size: ${miniBatchSize}`)\r\n            }\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                if (!data[di].hasOwnProperty(\"input\") || (!data[di].hasOwnProperty(\"expected\") && !data[di].hasOwnProperty(\"output\"))) {\r\n                    return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\")\r\n                }\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            let elapsed\r\n\r\n            this.Module.ccall(\"loadTrainingData\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n\r\n            this.Module.ccall(\"shuffleTrainingData\", null, [\"number\"], [this.netInstance])\r\n\r\n            if (callback) {\r\n\r\n                let epochIndex = 0\r\n                let iterationIndex = 0\r\n\r\n                const doEpoch = () => {\r\n\r\n                    if (this.l2) this.l2Error = 0\r\n                    if (this.l1) this.l1Error = 0\r\n\r\n                    iterationIndex = 0\r\n                    doIteration()\r\n                }\r\n\r\n                const doIteration = () => {\r\n\r\n                    this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, miniBatchSize, iterationIndex])\r\n\r\n                    callback({\r\n                        iterations: (iterationIndex+1),\r\n                        error: this.error,\r\n                        elapsed: Date.now() - startTime,\r\n                        input: data[this.iterations].input\r\n                    })\r\n\r\n                    iterationIndex += miniBatchSize\r\n\r\n                    if (iterationIndex < data.length) {\r\n                        setTimeout(doIteration.bind(this), 0)\r\n                    } else {\r\n                        epochIndex++\r\n\r\n                        elapsed = Date.now() - startTime\r\n\r\n                        log && console.log(`Epoch ${epochIndex} Error: ${this.error}${this.l2==undefined ? \"\": ` L2 Error: ${this.l2Error/iterationIndex}`}`,\r\n                                    `\\nElapsed: ${NetUtil.format(elapsed, \"time\")} Average Duration: ${NetUtil.format(elapsed/epochIndex, \"time\")}`)\r\n\r\n                        if (epochIndex < epochs) {\r\n                            doEpoch()\r\n                        } else {\r\n                            this.Module._free(buf)\r\n                            resolve()\r\n                        }\r\n                    }\r\n                }\r\n                doEpoch()\r\n\r\n            } else {\r\n                for (let e=0; e<epochs; e++) {\r\n\r\n                    if (this.l2) this.l2Error = 0\r\n                    if (this.l1) this.l1Error = 0\r\n\r\n                    this.Module.ccall(\"train\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, -1, 0])\r\n                    elapsed = Date.now() - startTime\r\n                    if (log) {\r\n                        console.log(`Epoch ${e+1} Error: ${this.error}${this.l2==undefined ? \"\": ` L2 Error: ${this.l2Error/data.length}`}`,\r\n                                    `\\nElapsed: ${NetUtil.format(elapsed, \"time\")} Average Duration: ${NetUtil.format(elapsed/(e+1), \"time\")}`)\r\n                    }\r\n                }\r\n                this.Module._free(buf)\r\n                if (log) {\r\n                    console.log(`Training finished. Total time: ${NetUtil.format(elapsed, \"time\")}`)\r\n                }\r\n                resolve()\r\n            }\r\n        })\r\n    }\r\n\r\n    test (data, {log=true, callback}={}) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (data === undefined || data === null) {\r\n                reject(\"No data provided\")\r\n            }\r\n\r\n            if (log) {\r\n                console.log(\"Testing started\")\r\n            }\r\n\r\n            const startTime = Date.now()\r\n            const dimension = data[0].input.length\r\n            const itemSize = dimension + (data[0].expected || data[0].output).length\r\n            const itemsCount = itemSize * data.length\r\n            const typedArray = new Float32Array(itemsCount)\r\n\r\n            for (let di=0; di<data.length; di++) {\r\n\r\n                let index = itemSize*di\r\n\r\n                for (let ii=0; ii<data[di].input.length; ii++) {\r\n                    typedArray[index] = data[di].input[ii]\r\n                    index++\r\n                }\r\n\r\n                for (let ei=0; ei<(data[di].expected || data[di].output).length; ei++) {\r\n                    typedArray[index] = (data[di].expected || data[di].output)[ei]\r\n                    index++\r\n                }\r\n            }\r\n\r\n            const buf = this.Module._malloc(typedArray.length*typedArray.BYTES_PER_ELEMENT)\r\n            this.Module.HEAPF32.set(typedArray, buf >> 2)\r\n\r\n            this.Module.ccall(\"loadTestingData\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"],\r\n                                            [this.netInstance, buf, itemsCount, itemSize, dimension])\r\n\r\n            if (callback) {\r\n\r\n                let iterationIndex = 0\r\n                let totalError = 0\r\n\r\n                const doIteration = () => {\r\n\r\n                    totalError += this.Module.ccall(\"test\", \"number\", [\"number\", \"number\", \"number\"], [this.netInstance, 1, iterationIndex])\r\n\r\n                    callback({\r\n                        iterations: (iterationIndex+1),\r\n                        error: totalError/(iterationIndex+1),\r\n                        elapsed: Date.now() - startTime,\r\n                        input: data[iterationIndex].input\r\n                    })\r\n\r\n                    if (++iterationIndex < data.length) {\r\n                        setTimeout(doIteration.bind(this), 0)\r\n                    } else {\r\n                        iterationIndex\r\n\r\n                        const elapsed = Date.now() - startTime\r\n                        log && console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/iterationIndex, \"time\")}`)\r\n\r\n                        this.Module._free(buf)\r\n                        resolve(totalError/data.length)\r\n                    }\r\n                }\r\n\r\n                doIteration()\r\n\r\n            } else {\r\n\r\n                const avgError = this.Module.ccall(\"test\", \"number\", [\"number\", \"number\"], [this.netInstance, -1, 0])\r\n                this.Module._free(buf)\r\n\r\n                const elapsed = Date.now() - startTime\r\n\r\n                if (log) {\r\n                    console.log(`Testing finished. Total time: ${NetUtil.format(elapsed, \"time\")}  Average iteration time: ${NetUtil.format(elapsed/data.length, \"time\")}`)\r\n                }\r\n\r\n                resolve(avgError)\r\n            }\r\n        })\r\n    }\r\n\r\n    toJSON () {\r\n        return {\r\n            layers: this.layers.map(layer => layer.toJSON())\r\n        }\r\n    }\r\n\r\n    fromJSON (data) {\r\n\r\n        if (data === undefined || data === null) {\r\n            throw new Error(\"No JSON data given to import.\")\r\n        }\r\n\r\n        if (data.layers.length != this.layers.length) {\r\n            throw new Error(`Mismatched layers (${data.layers.length} layers in import data, but ${this.layers.length} configured)`)\r\n        }\r\n\r\n        this.Module.ccall(\"resetDeltaWeights\", null, [\"number\"], [this.netInstance])\r\n        this.layers.forEach((layer, li) => li && layer.fromJSON(data.layers[li], li))\r\n    }\r\n\r\n    static get version () {\r\n        return \"2.1.1\"\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Network = Network)\r\n\"use strict\"\r\n\r\nclass Neuron {\r\n\r\n    constructor () {}\r\n\r\n    init (netInstance, layerIndex, neuronIndex, {updateFn}) {\r\n\r\n        NetUtil.defineProperty(this, \"bias\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n        NetUtil.defineArrayProperty(this, \"weights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n        NetUtil.defineProperty(this, \"deltaBias\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n        NetUtil.defineArrayProperty(this, \"deltaWeights\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n        switch (updateFn) {\r\n            case \"gain\":\r\n                NetUtil.defineProperty(this, \"biasGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineArrayProperty(this, \"weightGain\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n                break\r\n            case \"adagrad\":\r\n            case \"rmsprop\":\r\n            case \"adadelta\":\r\n                NetUtil.defineProperty(this, \"biasCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineArrayProperty(this, \"weightsCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n\r\n                if (updateFn==\"adadelta\") {\r\n                    NetUtil.defineProperty(this, \"adadeltaBiasCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                    NetUtil.defineArrayProperty(this, \"adadeltaCache\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex], this.size)\r\n                }\r\n                break\r\n\r\n            case \"adam\":\r\n                NetUtil.defineProperty(this, \"m\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                NetUtil.defineProperty(this, \"v\", [\"number\", \"number\", \"number\"], [netInstance, layerIndex, neuronIndex])\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.Neuron = Neuron)\r\n\"use strict\"\r\n\r\nclass PoolLayer {\r\n\r\n}\r\n\r\ntypeof window==\"undefined\" && (exports.PoolLayer = PoolLayer)\r\n\n//# sourceMappingURL=jsNetWebAssembly.concat.js.map"]}