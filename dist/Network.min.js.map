{"version":3,"sources":["Network.min.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Layer","size","importedData","this","neurons","concat","map","n","ni","Neuron","undefined","value","layer","nextLayer","_this","prevLayer","forEach","neuron","init","adaptiveLR","rho","data","_this2","sum","bias","pNeuron","pni","activation","weights","expected","_this3","error","derivative","reduce","p","c","weight","wi","deltaWeights","deltaBias","window","global","NetMath","prime","val","Math","exp","pow","max","lreluSlope","abs","output","vi","log","calculated","desired","index","prev","curr","deltaValue","learningRate","weightI","newVal","biasGain","weightGains","min","weightsCache","biasCache","sqrt","rmsDecay","m","mt","iterations","v","vt","adadeltaCache","_newVal","adadeltaBiasCache","values","total","Network","_ref","arguments","_ref$layers","layers","_ref$adaptiveLR","_ref$activation","_ref$cost","cost","state","epochs","includes","weightUpdateFn","bind","every","item","Number","isInteger","initLayers","definedLayers","Error","input","_this4","li","hidden","round","ceil","joinLayer","layerIndex","assignNext","assignPrev","console","warn","forward","backward","dataSet","_this5","_ref2","_ref2$epochs","callback","Promise","resolve","reject","iterationIndex","epochsCounter","doEpoch","doIteration","hasOwnProperty","resetDeltaWeights","applyDeltaWeights","iterationError","setTimeout","testSet","_this6","totalError","testIteration","testInput","dw","_this7","dwi","imported","random"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Layer = function () {\n    function Layer(size, importedData) {\n        _classCallCheck(this, Layer);\n\n        this.size = size;\n        this.neurons = [].concat(_toConsumableArray(new Array(size))).map(function (n, ni) {\n            return new Neuron(importedData ? importedData[ni] : undefined);\n        });\n    }\n\n    _createClass(Layer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer) {\n            var _this = this;\n\n            this.prevLayer = layer;\n            this.neurons.forEach(function (neuron) {\n                return neuron.init(layer.size, _this.adaptiveLR, _this.rho);\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n            var _this2 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                neuron.sum = neuron.bias;\n                _this2.prevLayer.neurons.forEach(function (pNeuron, pni) {\n                    return neuron.sum += pNeuron.activation * neuron.weights[pni];\n                });\n                neuron.activation = _this2.activation(neuron.sum);\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            var _this3 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (typeof expected !== \"undefined\") {\n                    neuron.error = expected[ni] - neuron.activation;\n                } else {\n                    neuron.derivative = _this3.activation(neuron.sum, true);\n                    neuron.error = neuron.derivative * _this3.nextLayer.neurons.map(function (n) {\n                        return n.error * n.weights[ni];\n                    }).reduce(function (p, c) {\n                        return p + c;\n                    }, 0);\n                }\n\n                neuron.weights.forEach(function (weight, wi) {\n                    neuron.deltaWeights[wi] += neuron.error * _this3.prevLayer.neurons[wi].activation;\n                });\n\n                neuron.deltaBias = neuron.error;\n            });\n        }\n    }]);\n\n    return Layer;\n}();\n\ntypeof window == \"undefined\" && (global.Layer = Layer);\n\"use strict\";\n\nvar NetMath = function () {\n    function NetMath() {\n        _classCallCheck(this, NetMath);\n    }\n\n    _createClass(NetMath, null, [{\n        key: \"sigmoid\",\n\n\n        // Activation functions\n        value: function sigmoid(value, prime) {\n            var val = 1 / (1 + Math.exp(-value));\n            return prime ? val * (1 - val) : val;\n        }\n    }, {\n        key: \"tanh\",\n        value: function tanh(value, prime) {\n            var exp = Math.exp(2 * value);\n            return prime ? 4 / Math.pow(Math.exp(value) + Math.exp(-value), 2) || 1e-18 : (exp - 1) / (exp + 1) || 1e-18;\n        }\n    }, {\n        key: \"relu\",\n        value: function relu(value, prime) {\n            return prime ? value > 0 ? 1 : 0 : Math.max(value, 0);\n        }\n    }, {\n        key: \"lrelu\",\n        value: function lrelu(value, prime) {\n            return prime ? value > 0 ? 1 : this.lreluSlope : Math.max(this.lreluSlope * Math.abs(value), value);\n        }\n\n        // Cost functions\n\n    }, {\n        key: \"crossEntropy\",\n        value: function crossEntropy(target, output) {\n            return output.map(function (value, vi) {\n                return target[vi] * Math.log(value + 1e-15) + (1 - target[vi]) * Math.log(1 + 1e-15 - value);\n            }).reduce(function (p, c) {\n                return p - c;\n            }, 0);\n        }\n    }, {\n        key: \"meanSquaredError\",\n        value: function meanSquaredError(calculated, desired) {\n            return calculated.map(function (output, index) {\n                return Math.pow(output - desired[index], 2);\n            }).reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0) / calculated.length;\n        }\n\n        // Weight updating functions\n\n    }, {\n        key: \"noAdaptiveLR\",\n        value: function noAdaptiveLR(value, deltaValue) {\n            return value + this.learningRate * deltaValue;\n        }\n    }, {\n        key: \"gain\",\n        value: function gain(value, deltaValue, neuron, weightI) {\n\n            var newVal = value + this.learningRate * deltaValue * (weightI == null ? neuron.biasGain : neuron.weightGains[weightI]);\n\n            if (newVal <= 0 && value > 0 || newVal >= 0 && value < 0) {\n                if (weightI != null) neuron.weightGains[weightI] = Math.max(neuron.weightGains[weightI] * 0.95, 0.5);else neuron.biasGain = Math.max(neuron.biasGain * 0.95, 0.5);\n            } else {\n                if (weightI != null) neuron.weightGains[weightI] = Math.min(neuron.weightGains[weightI] + 0.05, 5);else neuron.biasGain = Math.min(neuron.biasGain + 0.05, 5);\n            }\n\n            return newVal;\n        }\n    }, {\n        key: \"adagrad\",\n        value: function adagrad(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) neuron.weightsCache[weightI] += Math.pow(deltaValue, 2);else neuron.biasCache += Math.pow(deltaValue, 2);\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.weightsCache[weightI] : neuron.biasCache));\n        }\n    }, {\n        key: \"RMSProp\",\n        value: function RMSProp(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) neuron.weightsCache[weightI] = this.rmsDecay * neuron.weightsCache[weightI] + (1 - this.rmsDecay) * Math.pow(deltaValue, 2);else neuron.biasCache = this.rmsDecay * neuron.biasCache + (1 - this.rmsDecay) * Math.pow(deltaValue, 2);\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.weightsCache[weightI] : neuron.biasCache));\n        }\n    }, {\n        key: \"adam\",\n        value: function adam(value, deltaValue, neuron) {\n\n            neuron.m = 0.9 * neuron.m + (1 - 0.9) * deltaValue;\n            var mt = neuron.m / (1 - Math.pow(0.9, this.iterations + 1));\n\n            neuron.v = 0.999 * neuron.v + (1 - 0.999) * Math.pow(deltaValue, 2);\n            var vt = neuron.v / (1 - Math.pow(0.999, this.iterations + 1));\n\n            return value + this.learningRate * mt / (Math.sqrt(vt) + 1e-8);\n        }\n    }, {\n        key: \"adadelta\",\n        value: function adadelta(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.weightsCache[weightI] = this.rho * neuron.weightsCache[weightI] + (1 - this.rho) * Math.pow(deltaValue, 2);\n                var newVal = value + Math.sqrt((neuron.adadeltaCache[weightI] + 1e-6) / (neuron.weightsCache[weightI] + 1e-6)) * deltaValue;\n                neuron.adadeltaCache[weightI] = this.rho * neuron.adadeltaCache[weightI] + (1 - this.rho) * Math.pow(deltaValue, 2);\n                return newVal;\n            } else {\n                neuron.biasCache = this.rho * neuron.biasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                var _newVal = value + Math.sqrt((neuron.adadeltaBiasCache + 1e-6) / (neuron.biasCache + 1e-6)) * deltaValue;\n                neuron.adadeltaBiasCache = this.rho * neuron.adadeltaBiasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                return _newVal;\n            }\n        }\n\n        // Other\n\n    }, {\n        key: \"softmax\",\n        value: function softmax(values) {\n            var total = values.reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0);\n            return values.map(function (value) {\n                return value / total;\n            });\n        }\n    }]);\n\n    return NetMath;\n}();\n\ntypeof window == \"undefined\" && (global.NetMath = NetMath);\n\"use strict\";\n\nvar Network = function () {\n    function Network() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            learningRate = _ref.learningRate,\n            _ref$layers = _ref.layers,\n            layers = _ref$layers === undefined ? [] : _ref$layers,\n            _ref$adaptiveLR = _ref.adaptiveLR,\n            adaptiveLR = _ref$adaptiveLR === undefined ? \"noAdaptiveLR\" : _ref$adaptiveLR,\n            _ref$activation = _ref.activation,\n            activation = _ref$activation === undefined ? \"sigmoid\" : _ref$activation,\n            _ref$cost = _ref.cost,\n            cost = _ref$cost === undefined ? \"crossEntropy\" : _ref$cost,\n            rmsDecay = _ref.rmsDecay,\n            rho = _ref.rho,\n            lreluSlope = _ref.lreluSlope;\n\n        _classCallCheck(this, Network);\n\n        this.state = \"not-defined\";\n        this.layers = [];\n        this.epochs = 0;\n        this.iterations = 0;\n\n        if (learningRate != null) {\n            this.learningRate = learningRate;\n        }\n\n        switch (true) {\n\n            case adaptiveLR == \"RMSProp\":\n                this.learningRate = this.learningRate == undefined ? 0.001 : this.learningRate;\n                break;\n\n            case adaptiveLR == \"adam\":\n                this.learningRate = this.learningRate == undefined ? 0.01 : this.learningRate;\n                break;\n\n            case adaptiveLR == \"adadelta\":\n                this.rho = rho == null ? 0.95 : rho;\n                break;\n\n            default:\n\n                if (this.learningRate == undefined) {\n                    switch (activation) {\n                        case \"relu\":\n                        case \"lrelu\":\n                            this.learningRate = 0.01;\n                            break;\n                        case \"tanh\":\n                            this.learningRate = 0.001;\n                            break;\n                        default:\n                            this.learningRate = 0.2;\n                    }\n                }\n        }\n\n        this.adaptiveLR = [false, null, undefined].includes(adaptiveLR) ? \"noAdaptiveLR\" : adaptiveLR;\n        this.weightUpdateFn = NetMath[this.adaptiveLR];\n        this.activation = NetMath[activation].bind(this);\n        this.cost = NetMath[cost];\n\n        if (this.adaptiveLR == \"RMSProp\") {\n            this.rmsDecay = rmsDecay == undefined ? 0.99 : rmsDecay;\n        }\n\n        if (activation == \"lrelu\") {\n            this.lreluSlope = lreluSlope == undefined ? -0.0005 : lreluSlope;\n        }\n\n        if (layers.length) {\n\n            switch (true) {\n\n                case layers.every(function (item) {\n                    return Number.isInteger(item);\n                }):\n                    this.layers = layers.map(function (size) {\n                        return new Layer(size);\n                    });\n                    this.state = \"constructed\";\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (item) {\n                    return item instanceof Layer;\n                }):\n                    this.state = \"constructed\";\n                    this.layers = layers;\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (item) {\n                    return item === Layer;\n                }):\n                    this.state = \"defined\";\n                    this.definedLayers = layers;\n                    break;\n\n                default:\n                    throw new Error(\"There was an error constructing from the layers given.\");\n            }\n        }\n    }\n\n    _createClass(Network, [{\n        key: \"initLayers\",\n        value: function initLayers(input, expected) {\n            var _this4 = this;\n\n            switch (this.state) {\n\n                case \"initialised\":\n                    return;\n\n                case \"defined\":\n                    this.layers = this.definedLayers.map(function (layer, li) {\n                        if (!li) return new layer(input);\n\n                        if (li == _this4.definedLayers.length - 1) return new layer(expected);\n\n                        var hidden = _this4.definedLayers.length - 2;\n                        var size = input / expected > 5 ? expected + (expected + Math.abs(input - expected) / 4) * (hidden - li + 1) / (hidden / 2) : input >= expected ? input + expected * (hidden - li) / (hidden / 2) : expected + input * (hidden - li) / (hidden / 2);\n\n                        return new layer(Math.max(Math.round(size), 0));\n                    });\n                    break;\n\n                case \"not-defined\":\n                    this.layers[0] = new Layer(input);\n                    this.layers[1] = new Layer(Math.ceil(input / expected > 5 ? expected + Math.abs(input - expected) / 4 : input + expected));\n                    this.layers[2] = new Layer(Math.ceil(expected));\n                    break;\n            }\n\n            this.layers.forEach(this.joinLayer.bind(this));\n            this.state = \"initialised\";\n        }\n    }, {\n        key: \"joinLayer\",\n        value: function joinLayer(layer, layerIndex) {\n\n            layer.activation = this.activation;\n            layer.adaptiveLR = this.adaptiveLR;\n\n            if (this.rho != undefined) {\n                layer.rho = this.rho;\n            }\n\n            if (layerIndex) {\n                this.layers[layerIndex - 1].assignNext(layer);\n                layer.assignPrev(this.layers[layerIndex - 1]);\n            }\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n\n            if (this.state != \"initialised\") {\n                throw new Error(\"The network layers have not been initialised.\");\n            }\n\n            if (data === undefined) {\n                throw new Error(\"No data passed to Network.forward()\");\n            }\n\n            if (data.length != this.layers[0].neurons.length) {\n                console.warn(\"Input data length did not match input layer neurons count.\");\n            }\n\n            this.layers[0].neurons.forEach(function (neuron, ni) {\n                return neuron.activation = data[ni];\n            });\n            this.layers.forEach(function (layer, li) {\n                return li && layer.forward(data);\n            });\n            return this.layers[this.layers.length - 1].neurons.map(function (n) {\n                return n.activation;\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            if (expected === undefined) {\n                throw new Error(\"No data passed to Network.backward()\");\n            }\n\n            if (expected.length != this.layers[this.layers.length - 1].neurons.length) {\n                console.warn(\"Expected data length did not match output layer neurons count.\");\n            }\n\n            this.layers[this.layers.length - 1].backward(expected);\n\n            for (var layerIndex = this.layers.length - 2; layerIndex > 0; layerIndex--) {\n                this.layers[layerIndex].backward();\n            }\n        }\n    }, {\n        key: \"train\",\n        value: function train(dataSet) {\n            var _this5 = this;\n\n            var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref2$epochs = _ref2.epochs,\n                epochs = _ref2$epochs === undefined ? 1 : _ref2$epochs,\n                callback = _ref2.callback;\n\n            return new Promise(function (resolve, reject) {\n\n                if (dataSet === undefined || dataSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                if (_this5.state != \"initialised\") {\n                    _this5.initLayers(dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length);\n                }\n\n                var iterationIndex = 0;\n                var epochsCounter = 0;\n                var error = 0;\n\n                var doEpoch = function doEpoch() {\n                    _this5.epochs++;\n                    iterationIndex = 0;\n\n                    doIteration();\n                };\n\n                var doIteration = function doIteration() {\n\n                    if (!dataSet[iterationIndex].hasOwnProperty(\"input\") || !dataSet[iterationIndex].hasOwnProperty(\"expected\") && !dataSet[iterationIndex].hasOwnProperty(\"output\")) {\n                        return reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\");\n                    }\n\n                    _this5.resetDeltaWeights();\n\n                    var input = dataSet[iterationIndex].input;\n                    var output = _this5.forward(input);\n                    var target = dataSet[iterationIndex].expected || dataSet[iterationIndex].output;\n\n                    _this5.backward(target);\n                    _this5.applyDeltaWeights();\n\n                    var iterationError = _this5.cost(target, output);\n                    error += iterationError;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: _this5.iterations,\n                            error: iterationError,\n                            input: input\n                        });\n                    }\n\n                    _this5.iterations++;\n                    iterationIndex++;\n\n                    if (iterationIndex < dataSet.length) {\n                        setTimeout(doIteration.bind(_this5), 0);\n                    } else {\n\n                        epochsCounter++;\n                        console.log(\"Epoch: \" + epochsCounter + \" Error: \" + error / 100);\n\n                        if (epochsCounter < epochs) {\n                            doEpoch();\n                        } else resolve();\n                    }\n                };\n\n                doEpoch();\n            });\n        }\n    }, {\n        key: \"test\",\n        value: function test(testSet) {\n            var _this6 = this;\n\n            return new Promise(function (resolve, reject) {\n\n                if (testSet === undefined || testSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                var totalError = 0;\n                var testIteration = 0;\n\n                var testInput = function testInput() {\n\n                    console.log(\"Testing iteration\", testIteration + 1, totalError / (testIteration + 1));\n\n                    var output = _this6.forward(testSet[testIteration].input);\n                    var target = testSet[testIteration].expected || testSet[testIteration].output;\n\n                    totalError += _this6.cost(target, output);\n\n                    testIteration++;\n\n                    if (testIteration < testSet.length) setTimeout(testInput.bind(_this6), 0);else resolve(totalError / testSet.length);\n                };\n                testInput();\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            this.layers.forEach(function (layer, li) {\n                li && layer.neurons.forEach(function (neuron) {\n                    neuron.deltaWeights = neuron.weights.map(function (dw) {\n                        return 0;\n                    });\n                });\n            });\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            var _this7 = this;\n\n            this.layers.forEach(function (layer, li) {\n                li && layer.neurons.forEach(function (neuron) {\n                    neuron.deltaWeights.forEach(function (dw, dwi) {\n                        neuron.weights[dwi] = _this7.weightUpdateFn.bind(_this7, neuron.weights[dwi], dw, neuron, dwi)();\n                    });\n                    neuron.bias = _this7.weightUpdateFn.bind(_this7, neuron.bias, neuron.deltaBias, neuron)();\n                });\n            });\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                layers: this.layers.map(function (layer) {\n                    return {\n                        neurons: layer.neurons.map(function (neuron) {\n                            return {\n                                bias: neuron.bias,\n                                weights: neuron.weights\n                            };\n                        })\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data) {\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No JSON data given to import.\");\n            }\n\n            this.layers = data.layers.map(function (layer) {\n                return new Layer(layer.neurons.length, layer.neurons);\n            });\n            this.state = \"constructed\";\n            this.initLayers();\n        }\n    }]);\n\n    return Network;\n}();\n\ntypeof window == \"undefined\" && (global.Network = Network);\n\"use strict\";\n\nvar Neuron = function () {\n    function Neuron(importedData) {\n        _classCallCheck(this, Neuron);\n\n        if (importedData) {\n            this.imported = true;\n            this.weights = importedData.weights || [];\n            this.bias = importedData.bias;\n        }\n    }\n\n    _createClass(Neuron, [{\n        key: \"init\",\n        value: function init(size, adaptiveLR) {\n            if (!this.imported) {\n                this.weights = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                    return Math.random() * 0.2 - 0.1;\n                });\n                this.bias = Math.random() * 0.2 - 0.1;\n            }\n\n            this.deltaWeights = this.weights.map(function (v) {\n                return 0;\n            });\n\n            switch (adaptiveLR) {\n                case \"gain\":\n                    this.weightGains = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 1;\n                    });\n                    this.biasGain = 1;\n                    break;\n\n                case \"adagrad\":\n                case \"RMSProp\":\n                case \"adadelta\":\n                    this.biasCache = 0;\n                    this.weightsCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 0;\n                    });\n\n                    if (adaptiveLR == \"adadelta\") {\n                        this.adadeltaCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                            return 0;\n                        });\n                        this.adadeltaBiasCache = 0;\n                    }\n                    break;\n\n                case \"adam\":\n                    this.m = 0;\n                    this.v = 0;\n                    break;\n            }\n        }\n    }]);\n\n    return Neuron;\n}();\n\ntypeof window == \"undefined\" && (global.Neuron = Neuron);\n//# sourceMappingURL=Network.concat.js.map\n//# sourceMappingURL=Network.min.js.map\n"]}