{"version":3,"sources":["Network.min.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","ConvLayer","size","_ref","arguments","filterSize","zeroPadding","stride","activation","this","NetMath","NetUtil","format","bind","noactivation","state","layer","nextLayer","prevLayer","net","filterCount","channels","Math","floor","prevLayerMapWidth","outMapSize","max","sqrt","inMapValuesCount","pow","inZPMapValuesCount","filters","concat","map","f","Filter","_this","forEach","filter","weights","channelWeights","weightsRow","weightsInitFn","weightsConfig","activationMap","row","v","errorMap","dropoutMap","bias","random","init","updateFn","activationConfig","eluAlpha","activations","getActivations","filterI","sumMap","convolve","input","sumY","sumX","dropout","FCLayer","emY","emX","weightIndex","neuronI","neurons","neuron","error","_filterI","buildConvErrorMap","_filterI2","_filter","col","buildConvDWeights","channel","deltaWeights","_row","_col","l2","l2Error","l1","l1Error","abs","weightUpdateFn","maxNorm","maxNormTotal","deltaBias","data","layerIndex","fi","Error","window","exports","n","Neuron","_this2","weightsCount","_this3","ni","dropped","sum","ai","expected","_this4","derivative","reduce","p","c","wi","miniBatchSize","dw","_this5","dwi","Layer","_this6","_ref2","wRow","w","biasGain","weightGains","getWeightGain","_ref3","_ref4","column","setWeightGain","_ref5","_ref6","biasCache","weightsCache","getWeightsCache","_ref7","_ref8","setWeightsCache","_ref9","_ref10","adadeltaBiasCache","adadeltaCache","getAdadeltaCache","_ref11","_ref12","setAdadeltaCache","_ref13","_ref14","m","rreluSlope","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_ref22","prime","val","exp","lreluSlope","sech","tanh","elu","output","vi","log","calculated","desired","index","prev","curr","deltaValue","learningRate","weightI","newVal","min","rmsDecay","mt","iterations","vt","rho","_newVal","_ref23","limit","_ref24","mean","stdDeviation","x1","x2","r","_ref25","fanIn","fanOut","gaussian","lecunnormal","_ref26","uniform","lecununiform","_ref27","_ref28","values","total","avg","diffs","multiplier","layers","li","setWeight","getWeight","type","replace","toLowerCase","date","Date","formatted","getMilliseconds","getHours","getMinutes","getSeconds","join","j","x","zP","extraColumns","extraRows","slice","vol","mapValues","d","_ref29","inputVol","arrayToVolume","outputMap","paddedLength","fSSpread","di","addZeroPadding","inputY","inputX","weightsY","weightsX","outY","outX","nlFilterI","splice","emXI","channelsCount","deltaDeltaWeights","channelI","inputValues","inputMap","arrayToMap","_weightsY","_weightsX","_weightsY2","_weightsX2","eY","eX","mapStartI","mapSize","returnArr","rowI","colI","_returnArr","Network","_ref30","_ref30$layers","_ref30$updateFn","_ref30$activation","_ref30$cost","cost","_ref30$dropout","_ref30$l","_ref30$l2","epochs","includes","distribution","every","item","Number","isInteger","initLayers","ceil","joinLayer","assign","assignNext","assignPrev","console","warn","forward","backward","dataSet","_this7","_ref31","_ref31$epochs","callback","_ref31$log","_ref31$miniBatchSize","_ref31$shuffle","shuffle","Promise","resolve","reject","iterationIndex","epochsCounter","startTime","now","doEpoch","doIteration","hasOwnProperty","applyDeltaWeights","resetDeltaWeights","iterationError","elapsed","setTimeout","testSet","_this8","_ref32","_ref32$log","totalError","testInput","toJSON","fromJSON","get","_this9","_ref33"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ConvLayer = function () {\n    function ConvLayer(size) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            filterSize = _ref.filterSize,\n            zeroPadding = _ref.zeroPadding,\n            stride = _ref.stride,\n            activation = _ref.activation;\n\n        _classCallCheck(this, ConvLayer);\n\n        if (filterSize) this.filterSize = filterSize;\n        if (stride) this.stride = stride;\n        if (size) this.size = size;\n\n        this.zeroPadding = zeroPadding;\n\n        if (activation != undefined) {\n\n            if (typeof activation == \"boolean\" && !activation) {\n                this.activation = NetMath.noactivation;\n            } else {\n                this.activation = typeof activation == \"function\" ? activation : NetMath[NetUtil.format(activation)].bind(this);\n            }\n        }\n\n        this.state = \"not-initialised\";\n    }\n\n    _createClass(ConvLayer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer) {\n\n            this.prevLayer = layer;\n\n            this.filterSize = this.filterSize || this.net.filterSize || 3;\n            this.stride = this.stride || this.net.stride || 1;\n            this.size = this.size || this.net.filterCount || 4;\n            this.channels = layer instanceof ConvLayer ? layer.size : this.net.channels || 1;\n\n            if (this.zeroPadding == undefined) {\n                this.zeroPadding = this.net.zeroPadding == undefined ? Math.floor(this.filterSize / 2) : this.net.zeroPadding;\n            }\n\n            // Caching calculations\n            var prevLayerMapWidth = layer instanceof ConvLayer ? layer.outMapSize : Math.max(Math.floor(Math.sqrt(layer.size / this.channels)), 1);\n\n            this.inMapValuesCount = Math.pow(prevLayerMapWidth, 2);\n            this.inZPMapValuesCount = Math.pow(prevLayerMapWidth + this.zeroPadding * 2, 2);\n            this.outMapSize = (prevLayerMapWidth - this.filterSize + 2 * this.zeroPadding) / this.stride + 1;\n\n            this.filters = [].concat(_toConsumableArray(new Array(this.size))).map(function (f) {\n                return new Filter();\n            });\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var _this = this;\n\n            this.filters.forEach(function (filter) {\n\n                filter.weights = [].concat(_toConsumableArray(new Array(_this.channels))).map(function (channelWeights) {\n                    return [].concat(_toConsumableArray(new Array(_this.filterSize))).map(function (weightsRow) {\n                        return _this.net.weightsInitFn(_this.filterSize * (_this.prevLayer.channels || 1), _this.weightsConfig);\n                    });\n                });\n\n                filter.activationMap = [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (v) {\n                        return 0;\n                    });\n                });\n                filter.errorMap = [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (row) {\n                    return [].concat(_toConsumableArray(new Array(_this.outMapSize))).map(function (v) {\n                        return 0;\n                    });\n                });\n                filter.dropoutMap = filter.activationMap.map(function (row) {\n                    return row.map(function (v) {\n                        return false;\n                    });\n                });\n                filter.bias = Math.random() * 0.2 - 0.1;\n\n                filter.init({\n                    updateFn: _this.net.updateFn,\n                    activation: _this.net.activationConfig,\n                    eluAlpha: _this.net.eluAlpha\n                });\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward() {\n\n            var activations = NetUtil.getActivations(this.prevLayer);\n\n            for (var filterI = 0; filterI < this.size; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                filter.sumMap = NetUtil.convolve({\n                    input: activations,\n                    zeroPadding: this.zeroPadding,\n                    weights: filter.weights,\n                    channels: this.channels,\n                    stride: this.stride,\n                    bias: filter.bias\n                });\n\n                for (var sumY = 0; sumY < filter.sumMap.length; sumY++) {\n                    for (var sumX = 0; sumX < filter.sumMap.length; sumX++) {\n                        if (this.state == \"training\" && (filter.dropoutMap[sumY][sumX] = Math.random() > this.net.dropout)) {\n                            filter.activationMap[sumY][sumX] = 0;\n                        } else {\n                            filter.activationMap[sumY][sumX] = this.activation(filter.sumMap[sumY][sumX], false, filter) / (this.net.dropout || 1);\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"backward\",\n        value: function backward() {\n\n            // First, get the filters' error maps\n            if (this.nextLayer instanceof FCLayer) {\n\n                // For each filter, build the errorMap from the weighted neuron errors in the next FCLayer corresponding to each value in the activation map\n                for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                    var filter = this.filters[filterI];\n\n                    for (var emY = 0; emY < filter.errorMap.length; emY++) {\n                        for (var emX = 0; emX < filter.errorMap.length; emX++) {\n\n                            var weightIndex = filterI * Math.pow(this.outMapSize, 2) + emY * filter.errorMap.length + emX;\n\n                            for (var neuronI = 0; neuronI < this.nextLayer.neurons.length; neuronI++) {\n\n                                var neuron = this.nextLayer.neurons[neuronI];\n                                filter.errorMap[emY][emX] += neuron.error * neuron.weights[weightIndex];\n                            }\n                        }\n                    }\n                }\n            } else {\n                for (var _filterI = 0; _filterI < this.filters.length; _filterI++) {\n                    NetUtil.buildConvErrorMap(this, this.filters[_filterI], _filterI);\n                }\n            }\n\n            // Apply derivative to each error value\n            for (var _filterI2 = 0; _filterI2 < this.filters.length; _filterI2++) {\n\n                var _filter = this.filters[_filterI2];\n\n                for (var row = 0; row < _filter.errorMap.length; row++) {\n                    for (var col = 0; col < _filter.errorMap[0].length; col++) {\n\n                        if (_filter.dropoutMap[row][col]) {\n                            _filter.errorMap[row][col] = 0;\n                        } else {\n                            _filter.errorMap[row][col] *= this.activation(_filter.sumMap[row][col], true, _filter);\n                        }\n                    }\n                }\n            }\n\n            // Then use the error map values to build the delta weights\n            NetUtil.buildConvDWeights(this);\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                for (var channel = 0; channel < filter.deltaWeights.length; channel++) {\n                    for (var row = 0; row < filter.deltaWeights[0].length; row++) {\n                        for (var col = 0; col < filter.deltaWeights[0][0].length; col++) {\n                            filter.deltaWeights[channel][row][col] = 0;\n                        }\n                    }\n                }\n\n                for (var _row = 0; _row < filter.dropoutMap.length; _row++) {\n                    for (var _col = 0; _col < filter.dropoutMap[0].length; _col++) {\n                        filter.dropoutMap[_row][_col] = false;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            for (var filterI = 0; filterI < this.filters.length; filterI++) {\n\n                var filter = this.filters[filterI];\n\n                for (var channel = 0; channel < filter.deltaWeights.length; channel++) {\n                    for (var row = 0; row < filter.deltaWeights[0].length; row++) {\n                        for (var col = 0; col < filter.deltaWeights[0][0].length; col++) {\n\n                            if (this.net.l2 != undefined) this.net.l2Error += 0.5 * this.net.l2 * Math.pow(filter.weights[channel][row][col], 2);\n                            if (this.net.l1 != undefined) this.net.l1Error += this.net.l1 * Math.abs(filter.weights[channel][row][col]);\n\n                            filter.weights[channel][row][col] = this.net.weightUpdateFn.bind(this.net, filter.weights[channel][row][col], filter.deltaWeights[channel][row][col], filter, [channel, row, col])();\n\n                            if (this.net.maxNorm != undefined) this.net.maxNormTotal += Math.pow(filter.weights[channel][row][col], 2);\n                        }\n                    }\n                }\n\n                filter.bias = this.net.weightUpdateFn.bind(this.net, filter.bias, filter.deltaBias, filter)();\n            }\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                weights: this.filters.map(function (filter) {\n                    return {\n                        bias: filter.bias,\n                        weights: filter.weights\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data, layerIndex) {\n            this.filters.forEach(function (filter, fi) {\n\n                if (data.weights[fi].weights.length != filter.weights.length) {\n                    throw new Error(\"Mismatched weights depth. Given: \" + data.weights[fi].weights.length + \" Existing: \" + filter.weights.length + \". At: layers[\" + layerIndex + \"], filters[\" + fi + \"]\");\n                }\n\n                if (data.weights[fi].weights[0].length != filter.weights[0].length) {\n                    throw new Error(\"Mismatched weights size. Given: \" + data.weights[fi].weights[0].length + \" Existing: \" + filter.weights[0].length + \". At: layers[\" + layerIndex + \"], filters[\" + fi + \"]\");\n                }\n\n                filter.bias = data.weights[fi].bias;\n                filter.weights = data.weights[fi].weights;\n            });\n        }\n    }]);\n\n    return ConvLayer;\n}();\n\ntypeof window == \"undefined\" && (exports.ConvLayer = ConvLayer);\n\"use strict\";\n\nvar FCLayer = function () {\n    function FCLayer(size) {\n        _classCallCheck(this, FCLayer);\n\n        this.size = size;\n        this.neurons = [].concat(_toConsumableArray(new Array(size))).map(function (n) {\n            return new Neuron();\n        });\n        this.state = \"not-initialised\";\n    }\n\n    _createClass(FCLayer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer) {\n            this.prevLayer = layer;\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var _this2 = this;\n\n            this.neurons.forEach(function (neuron) {\n\n                var weightsCount = _this2.prevLayer instanceof FCLayer ? _this2.prevLayer.size : _this2.prevLayer.filters.length * Math.pow(_this2.prevLayer.outMapSize, 2);\n\n                neuron.weights = _this2.net.weightsInitFn(weightsCount, _this2.weightsConfig);\n                neuron.bias = Math.random() * 0.2 - 0.1;\n\n                neuron.init({\n                    updateFn: _this2.net.updateFn,\n                    activationConfig: _this2.net.activationConfig,\n                    eluAlpha: _this2.net.eluAlpha\n                });\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward() {\n            var _this3 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n                if (_this3.state == \"training\" && (neuron.dropped = Math.random() > _this3.net.dropout)) {\n                    neuron.activation = 0;\n                } else {\n                    neuron.sum = neuron.bias;\n\n                    var activations = NetUtil.getActivations(_this3.prevLayer);\n\n                    for (var ai = 0; ai < activations.length; ai++) {\n                        neuron.sum += activations[ai] * neuron.weights[ai];\n                    }\n\n                    neuron.activation = _this3.activation(neuron.sum, false, neuron) / (_this3.net.dropout || 1);\n                }\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            var _this4 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (neuron.dropped) {\n                    neuron.error = 0;\n                    neuron.deltaBias = 0;\n                } else {\n                    if (typeof expected !== \"undefined\") {\n                        neuron.error = expected[ni] - neuron.activation;\n                    } else {\n                        neuron.derivative = _this4.activation(neuron.sum, true, neuron);\n                        neuron.error = neuron.derivative * _this4.nextLayer.neurons.map(function (n) {\n                            return n.error * (n.weights[ni] | 0);\n                        }).reduce(function (p, c) {\n                            return p + c;\n                        }, 0);\n                    }\n\n                    var activations = NetUtil.getActivations(_this4.prevLayer);\n\n                    for (var wi = 0; wi < neuron.weights.length; wi++) {\n                        neuron.deltaWeights[wi] += neuron.error * activations[wi] * (1 + ((_this4.net.l2 || 0) + (_this4.net.l1 || 0)) / _this4.net.miniBatchSize * neuron.deltaWeights[wi]);\n                    }\n\n                    neuron.deltaBias = neuron.error;\n                }\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            this.neurons.forEach(function (neuron) {\n                return neuron.deltaWeights = neuron.weights.map(function (dw) {\n                    return 0;\n                });\n            });\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            var _this5 = this;\n\n            this.neurons.forEach(function (neuron) {\n                neuron.deltaWeights.forEach(function (dw, dwi) {\n\n                    if (_this5.net.l2 != undefined) _this5.net.l2Error += 0.5 * _this5.net.l2 * Math.pow(neuron.weights[dwi], 2);\n                    if (_this5.net.l1 != undefined) _this5.net.l1Error += _this5.net.l1 * Math.abs(neuron.weights[dwi]);\n\n                    neuron.weights[dwi] = _this5.net.weightUpdateFn.bind(_this5.net, neuron.weights[dwi], dw, neuron, dwi)();\n\n                    if (_this5.net.maxNorm != undefined) _this5.net.maxNormTotal += Math.pow(neuron.weights[dwi], 2);\n                });\n\n                neuron.bias = _this5.net.weightUpdateFn.bind(_this5.net, neuron.bias, neuron.deltaBias, neuron)();\n            });\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                weights: this.neurons.map(function (neuron) {\n                    return {\n                        bias: neuron.bias,\n                        weights: neuron.weights\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data, layerIndex) {\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (data.weights[ni].weights.length != neuron.weights.length) {\n                    throw new Error(\"Mismatched weights count. Given: \" + data.weights[ni].weights.length + \" Existing: \" + neuron.weights.length + \". At layers[\" + layerIndex + \"], neurons[\" + ni + \"]\");\n                }\n\n                neuron.bias = data.weights[ni].bias;\n                neuron.weights = data.weights[ni].weights;\n            });\n        }\n    }]);\n\n    return FCLayer;\n}();\n\nvar Layer = FCLayer;\n\ntypeof window == \"undefined\" && (exports.FCLayer = exports.Layer = FCLayer);\n\"use strict\";\n\nvar Filter = function () {\n    function Filter() {\n        _classCallCheck(this, Filter);\n    }\n\n    _createClass(Filter, [{\n        key: \"init\",\n        value: function init() {\n            var _this6 = this;\n\n            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                updateFn = _ref2.updateFn,\n                activation = _ref2.activation,\n                eluAlpha = _ref2.eluAlpha;\n\n            var size = this.weights.length;\n\n            this.deltaWeights = this.weights.map(function (channel) {\n                return channel.map(function (wRow) {\n                    return wRow.map(function (w) {\n                        return 0;\n                    });\n                });\n            });\n            this.deltaBias = 0;\n\n            switch (updateFn) {\n\n                case \"gain\":\n                    this.biasGain = 1;\n                    this.weightGains = this.weights.map(function (channel) {\n                        return channel.map(function (wRow) {\n                            return wRow.map(function (w) {\n                                return 1;\n                            });\n                        });\n                    });\n                    this.getWeightGain = function (_ref3) {\n                        var _ref4 = _slicedToArray(_ref3, 3),\n                            channel = _ref4[0],\n                            row = _ref4[1],\n                            column = _ref4[2];\n\n                        return _this6.weightGains[channel][row][column];\n                    };\n                    this.setWeightGain = function (_ref5, v) {\n                        var _ref6 = _slicedToArray(_ref5, 3),\n                            channel = _ref6[0],\n                            row = _ref6[1],\n                            column = _ref6[2];\n\n                        return _this6.weightGains[channel][row][column] = v;\n                    };\n                    break;\n\n                case \"adagrad\":\n                case \"rmsprop\":\n                case \"adadelta\":\n                    this.biasCache = 0;\n                    this.weightsCache = this.weights.map(function (channel) {\n                        return channel.map(function (wRow) {\n                            return wRow.map(function (w) {\n                                return 0;\n                            });\n                        });\n                    });\n                    this.getWeightsCache = function (_ref7) {\n                        var _ref8 = _slicedToArray(_ref7, 3),\n                            channel = _ref8[0],\n                            row = _ref8[1],\n                            column = _ref8[2];\n\n                        return _this6.weightsCache[channel][row][column];\n                    };\n                    this.setWeightsCache = function (_ref9, v) {\n                        var _ref10 = _slicedToArray(_ref9, 3),\n                            channel = _ref10[0],\n                            row = _ref10[1],\n                            column = _ref10[2];\n\n                        return _this6.weightsCache[channel][row][column] = v;\n                    };\n\n                    if (updateFn == \"adadelta\") {\n                        this.adadeltaBiasCache = 0;\n                        this.adadeltaCache = this.weights.map(function (channel) {\n                            return channel.map(function (wRow) {\n                                return wRow.map(function (w) {\n                                    return 0;\n                                });\n                            });\n                        });\n                        this.getAdadeltaCache = function (_ref11) {\n                            var _ref12 = _slicedToArray(_ref11, 3),\n                                channel = _ref12[0],\n                                row = _ref12[1],\n                                column = _ref12[2];\n\n                            return _this6.adadeltaCache[channel][row][column];\n                        };\n                        this.setAdadeltaCache = function (_ref13, v) {\n                            var _ref14 = _slicedToArray(_ref13, 3),\n                                channel = _ref14[0],\n                                row = _ref14[1],\n                                column = _ref14[2];\n\n                            return _this6.adadeltaCache[channel][row][column] = v;\n                        };\n                    }\n                    break;\n\n                case \"adam\":\n                    this.m = 0;\n                    this.v = 0;\n            }\n\n            if (activation == \"rrelu\") {\n                this.rreluSlope = Math.random() * 0.001;\n            } else if (activation == \"elu\") {\n                this.eluAlpha = eluAlpha;\n            }\n        }\n    }, {\n        key: \"getWeight\",\n        value: function getWeight(_ref15) {\n            var _ref16 = _slicedToArray(_ref15, 3),\n                channel = _ref16[0],\n                row = _ref16[1],\n                column = _ref16[2];\n\n            return this.weights[channel][row][column];\n        }\n    }, {\n        key: \"setWeight\",\n        value: function setWeight(_ref17, v) {\n            var _ref18 = _slicedToArray(_ref17, 3),\n                channel = _ref18[0],\n                row = _ref18[1],\n                column = _ref18[2];\n\n            this.weights[channel][row][column] = v;\n        }\n    }, {\n        key: \"getDeltaWeight\",\n        value: function getDeltaWeight(_ref19) {\n            var _ref20 = _slicedToArray(_ref19, 3),\n                channel = _ref20[0],\n                row = _ref20[1],\n                column = _ref20[2];\n\n            return this.deltaWeights[channel][row][column];\n        }\n    }, {\n        key: \"setDeltaWeight\",\n        value: function setDeltaWeight(_ref21, v) {\n            var _ref22 = _slicedToArray(_ref21, 3),\n                channel = _ref22[0],\n                row = _ref22[1],\n                column = _ref22[2];\n\n            this.deltaWeights[channel][row][column] = v;\n        }\n    }]);\n\n    return Filter;\n}();\n\ntypeof window == \"undefined\" && (exports.Filter = Filter);\n\n\"use strict\";\n\nvar NetMath = function () {\n    function NetMath() {\n        _classCallCheck(this, NetMath);\n    }\n\n    _createClass(NetMath, null, [{\n        key: \"noactivation\",\n\n\n        // Activation functions\n        value: function noactivation(value, prime) {\n            return prime ? 1 : value;\n        }\n    }, {\n        key: \"sigmoid\",\n        value: function sigmoid(value, prime) {\n            var val = 1 / (1 + Math.exp(-value));\n            return prime ? val * (1 - val) : val;\n        }\n    }, {\n        key: \"tanh\",\n        value: function tanh(value, prime) {\n            var exp = Math.exp(2 * value);\n            return prime ? 4 / Math.pow(Math.exp(value) + Math.exp(-value), 2) || 1e-18 : (exp - 1) / (exp + 1) || 1e-18;\n        }\n    }, {\n        key: \"relu\",\n        value: function relu(value, prime) {\n            return prime ? value > 0 ? 1 : 0 : Math.max(value, 0);\n        }\n    }, {\n        key: \"lrelu\",\n        value: function lrelu(value, prime) {\n            return prime ? value > 0 ? 1 : this.lreluSlope : Math.max(this.lreluSlope * Math.abs(value), value);\n        }\n    }, {\n        key: \"rrelu\",\n        value: function rrelu(value, prime, neuron) {\n            return prime ? value > 0 ? 1 : neuron.rreluSlope : Math.max(neuron.rreluSlope, value);\n        }\n    }, {\n        key: \"lecuntanh\",\n        value: function lecuntanh(value, prime) {\n            return prime ? 1.15333 * Math.pow(NetMath.sech(2 / 3 * value), 2) : 1.7159 * NetMath.tanh(2 / 3 * value);\n        }\n    }, {\n        key: \"elu\",\n        value: function elu(value, prime, neuron) {\n            return prime ? value >= 0 ? 1 : NetMath.elu(value, false, neuron) + neuron.eluAlpha : value >= 0 ? value : neuron.eluAlpha * (Math.exp(value) - 1);\n        }\n\n        // Cost functions\n\n    }, {\n        key: \"crossentropy\",\n        value: function crossentropy(target, output) {\n            return output.map(function (value, vi) {\n                return target[vi] * Math.log(value + 1e-15) + (1 - target[vi]) * Math.log(1 + 1e-15 - value);\n            }).reduce(function (p, c) {\n                return p - c;\n            }, 0);\n        }\n    }, {\n        key: \"meansquarederror\",\n        value: function meansquarederror(calculated, desired) {\n            return calculated.map(function (output, index) {\n                return Math.pow(output - desired[index], 2);\n            }).reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0) / calculated.length;\n        }\n\n        // Weight updating functions\n\n    }, {\n        key: \"vanillaupdatefn\",\n        value: function vanillaupdatefn(value, deltaValue) {\n            return value + this.learningRate * deltaValue;\n        }\n    }, {\n        key: \"gain\",\n        value: function gain(value, deltaValue, neuron, weightI) {\n\n            var newVal = value + this.learningRate * deltaValue * (weightI == null ? neuron.biasGain : neuron.getWeightGain(weightI));\n\n            if (newVal <= 0 && value > 0 || newVal >= 0 && value < 0) {\n                if (weightI != null) {\n                    neuron.setWeightGain(weightI, Math.max(neuron.getWeightGain(weightI) * 0.95, 0.5));\n                } else {\n                    neuron.biasGain = Math.max(neuron.biasGain * 0.95, 0.5);\n                }\n            } else {\n                if (weightI != null) {\n                    neuron.setWeightGain(weightI, Math.min(neuron.getWeightGain(weightI) + 0.05, 5));\n                } else {\n                    neuron.biasGain = Math.min(neuron.biasGain + 0.05, 5);\n                }\n            }\n\n            return newVal;\n        }\n    }, {\n        key: \"adagrad\",\n        value: function adagrad(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, neuron.getWeightsCache(weightI) + Math.pow(deltaValue, 2));\n            } else {\n                neuron.biasCache += Math.pow(deltaValue, 2);\n            }\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.getWeightsCache(weightI) : neuron.biasCache));\n        }\n    }, {\n        key: \"rmsprop\",\n        value: function rmsprop(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, this.rmsDecay * neuron.getWeightsCache(weightI) + (1 - this.rmsDecay) * Math.pow(deltaValue, 2));\n            } else {\n                neuron.biasCache = this.rmsDecay * neuron.biasCache + (1 - this.rmsDecay) * Math.pow(deltaValue, 2);\n            }\n\n            return value + this.learningRate * deltaValue / (1e-6 + Math.sqrt(weightI != null ? neuron.getWeightsCache(weightI) : neuron.biasCache));\n        }\n    }, {\n        key: \"adam\",\n        value: function adam(value, deltaValue, neuron) {\n\n            neuron.m = 0.9 * neuron.m + (1 - 0.9) * deltaValue;\n            var mt = neuron.m / (1 - Math.pow(0.9, this.iterations + 1));\n\n            neuron.v = 0.999 * neuron.v + (1 - 0.999) * Math.pow(deltaValue, 2);\n            var vt = neuron.v / (1 - Math.pow(0.999, this.iterations + 1));\n\n            return value + this.learningRate * mt / (Math.sqrt(vt) + 1e-8);\n        }\n    }, {\n        key: \"adadelta\",\n        value: function adadelta(value, deltaValue, neuron, weightI) {\n\n            if (weightI != null) {\n                neuron.setWeightsCache(weightI, this.rho * neuron.getWeightsCache(weightI) + (1 - this.rho) * Math.pow(deltaValue, 2));\n                var newVal = value + Math.sqrt((neuron.getAdadeltaCache(weightI) + 1e-6) / (neuron.getWeightsCache(weightI) + 1e-6)) * deltaValue;\n                neuron.setAdadeltaCache(weightI, this.rho * neuron.getAdadeltaCache(weightI) + (1 - this.rho) * Math.pow(deltaValue, 2));\n                return newVal;\n            } else {\n                neuron.biasCache = this.rho * neuron.biasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                var _newVal = value + Math.sqrt((neuron.adadeltaBiasCache + 1e-6) / (neuron.biasCache + 1e-6)) * deltaValue;\n                neuron.adadeltaBiasCache = this.rho * neuron.adadeltaBiasCache + (1 - this.rho) * Math.pow(deltaValue, 2);\n                return _newVal;\n            }\n        }\n\n        // Weights init\n\n    }, {\n        key: \"uniform\",\n        value: function uniform(size, _ref23) {\n            var limit = _ref23.limit;\n\n            return [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                return Math.random() * 2 * limit - limit;\n            });\n        }\n    }, {\n        key: \"gaussian\",\n        value: function gaussian(size, _ref24) {\n            var mean = _ref24.mean,\n                stdDeviation = _ref24.stdDeviation;\n\n            return [].concat(_toConsumableArray(new Array(size))).map(function () {\n                // Polar Box Muller\n                var x1 = void 0,\n                    x2 = void 0,\n                    r = void 0,\n                    y = void 0;\n\n                do {\n                    x1 = 2 * Math.random() - 1;\n                    x2 = 2 * Math.random() - 1;\n                    r = Math.pow(x1, 2) + Math.pow(x2, 2);\n                } while (r >= 1 || !r);\n\n                return mean + x1 * Math.sqrt(-2 * Math.log(r) / r) * stdDeviation;\n            });\n        }\n    }, {\n        key: \"xaviernormal\",\n        value: function xaviernormal(size, _ref25) {\n            var fanIn = _ref25.fanIn,\n                fanOut = _ref25.fanOut;\n\n            return fanOut || fanOut == 0 ? NetMath.gaussian(size, { mean: 0, stdDeviation: Math.sqrt(2 / (fanIn + fanOut)) }) : NetMath.lecunnormal(size, { fanIn: fanIn });\n        }\n    }, {\n        key: \"xavieruniform\",\n        value: function xavieruniform(size, _ref26) {\n            var fanIn = _ref26.fanIn,\n                fanOut = _ref26.fanOut;\n\n            return fanOut || fanOut == 0 ? NetMath.uniform(size, { limit: Math.sqrt(6 / (fanIn + fanOut)) }) : NetMath.lecununiform(size, { fanIn: fanIn });\n        }\n    }, {\n        key: \"lecunnormal\",\n        value: function lecunnormal(size, _ref27) {\n            var fanIn = _ref27.fanIn;\n\n            return NetMath.gaussian(size, { mean: 0, stdDeviation: Math.sqrt(1 / fanIn) });\n        }\n    }, {\n        key: \"lecununiform\",\n        value: function lecununiform(size, _ref28) {\n            var fanIn = _ref28.fanIn;\n\n            return NetMath.uniform(size, { limit: Math.sqrt(3 / fanIn) });\n        }\n\n        // Other\n\n    }, {\n        key: \"softmax\",\n        value: function softmax(values) {\n            var total = values.reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0);\n            return values.map(function (value) {\n                return value / total;\n            });\n        }\n    }, {\n        key: \"sech\",\n        value: function sech(value) {\n            return 2 * Math.exp(-value) / (1 + Math.exp(-2 * value));\n        }\n    }, {\n        key: \"standardDeviation\",\n        value: function standardDeviation(arr) {\n            var avg = arr.reduce(function (p, c) {\n                return p + c;\n            }) / arr.length;\n            var diffs = arr.map(function (v) {\n                return v - avg;\n            }).map(function (v) {\n                return Math.pow(v, 2);\n            });\n            return Math.sqrt(diffs.reduce(function (p, c) {\n                return p + c;\n            }) / diffs.length);\n        }\n    }, {\n        key: \"maxNorm\",\n        value: function maxNorm() {\n\n            if (this.maxNormTotal > this.maxNorm) {\n\n                var multiplier = this.maxNorm / (1e-18 + this.maxNormTotal);\n\n                this.layers.forEach(function (layer, li) {\n                    li && layer.neurons.forEach(function (neuron) {\n                        neuron.weights.forEach(function (w, wi) {\n                            return neuron.setWeight(wi, neuron.getWeight(wi) * multiplier);\n                        });\n                    });\n                });\n            }\n\n            this.maxNormTotal = 0;\n        }\n    }]);\n\n    return NetMath;\n}();\n\ntypeof window == \"undefined\" && (exports.NetMath = NetMath);\n\"use strict\";\n\nvar NetUtil = function () {\n    function NetUtil() {\n        _classCallCheck(this, NetUtil);\n    }\n\n    _createClass(NetUtil, null, [{\n        key: \"format\",\n        value: function format(value) {\n            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"string\";\n\n            switch (true) {\n\n                case type == \"string\" && typeof value == \"string\":\n                    value = value.replace(/(_|\\s)/g, \"\").toLowerCase();\n                    break;\n\n                case type == \"time\" && typeof value == \"number\":\n                    var date = new Date(value);\n                    var formatted = [];\n\n                    if (value < 1000) {\n                        formatted.push(date.getMilliseconds() + \"ms\");\n                    } else {\n\n                        if (value >= 3600000) formatted.push(date.getHours() + \"h\");\n                        if (value >= 60000) formatted.push(date.getMinutes() + \"m\");\n\n                        formatted.push(date.getSeconds() + \"s\");\n                    }\n\n                    value = formatted.join(\" \");\n                    break;\n            }\n\n            return value;\n        }\n    }, {\n        key: \"shuffle\",\n        value: function shuffle(arr) {\n            for (var i = arr.length; i; i--) {\n                var j = Math.floor(Math.random() * i);\n                var x = arr[i - 1];\n                arr[i - 1] = arr[j];\n                arr[j] = x;\n            }\n        }\n    }, {\n        key: \"addZeroPadding\",\n        value: function addZeroPadding(map, zP) {\n            var extraColumns = [].concat(_toConsumableArray(new Array(zP))).map(function (v) {\n                return 0;\n            });\n            map = map.map(function (row) {\n                return [].concat(_toConsumableArray(extraColumns), _toConsumableArray(row), _toConsumableArray(extraColumns));\n            });\n\n            var extraRows = [].concat(_toConsumableArray(new Array(zP))).map(function (r) {\n                return [].concat(_toConsumableArray(new Array(map.length + zP * 2))).map(function (x) {\n                    return 0;\n                });\n            });\n            return [].concat(_toConsumableArray(extraRows.slice(0)), _toConsumableArray(map), _toConsumableArray(extraRows.slice(0)));\n        }\n    }, {\n        key: \"arrayToMap\",\n        value: function arrayToMap(arr, size) {\n            var map = [];\n\n            for (var i = 0; i < size; i++) {\n                map[i] = [];\n\n                for (var j = 0; j < size; j++) {\n                    map[i][j] = arr[i * size + j];\n                }\n            }\n\n            return map;\n        }\n    }, {\n        key: \"arrayToVolume\",\n        value: function arrayToVolume(arr, channels) {\n\n            var vol = [];\n            var size = Math.sqrt(arr.length / channels);\n            var mapValues = Math.pow(size, 2);\n\n            for (var d = 0; d < Math.floor(arr.length / mapValues); d++) {\n\n                var map = [];\n\n                for (var i = 0; i < size; i++) {\n                    map[i] = [];\n\n                    for (var j = 0; j < size; j++) {\n                        map[i][j] = arr[d * mapValues + i * size + j];\n                    }\n                }\n\n                vol[d] = map;\n            }\n\n            return vol;\n        }\n    }, {\n        key: \"convolve\",\n        value: function convolve(_ref29) {\n            var input = _ref29.input,\n                zeroPadding = _ref29.zeroPadding,\n                weights = _ref29.weights,\n                channels = _ref29.channels,\n                stride = _ref29.stride,\n                bias = _ref29.bias;\n\n\n            var inputVol = NetUtil.arrayToVolume(input, channels);\n            var outputMap = [];\n\n            var paddedLength = inputVol[0].length + zeroPadding * 2;\n            var fSSpread = Math.floor(weights[0].length / 2\n\n            // For each input channels,\n            );for (var di = 0; di < channels; di++) {\n                inputVol[di] = NetUtil.addZeroPadding(inputVol[di], zeroPadding\n                // For each inputY without ZP\n                );for (var inputY = fSSpread; inputY < paddedLength - fSSpread; inputY += stride) {\n                    outputMap[(inputY - fSSpread) / stride] = outputMap[(inputY - fSSpread) / stride] || [];\n                    // For each inputX without zP\n                    for (var inputX = fSSpread; inputX < paddedLength - fSSpread; inputX += stride) {\n                        var sum = 0;\n                        // For each weightsY on input\n                        for (var weightsY = 0; weightsY < weights[0].length; weightsY++) {\n                            // For each weightsX on input\n                            for (var weightsX = 0; weightsX < weights[0].length; weightsX++) {\n                                sum += inputVol[di][inputY + (weightsY - fSSpread)][inputX + (weightsX - fSSpread)] * weights[di][weightsY][weightsX];\n                            }\n                        }\n\n                        outputMap[(inputY - fSSpread) / stride][(inputX - fSSpread) / stride] = (outputMap[(inputY - fSSpread) / stride][(inputX - fSSpread) / stride] || 0) + sum;\n                    }\n                }\n            }\n\n            // Then add bias\n            for (var outY = 0; outY < outputMap.length; outY++) {\n                for (var outX = 0; outX < outputMap.length; outX++) {\n                    outputMap[outY][outX] += bias;\n                }\n            }\n\n            return outputMap;\n        }\n    }, {\n        key: \"buildConvErrorMap\",\n        value: function buildConvErrorMap(layer, filter, filterI) {\n\n            // Clear the existing error values, first\n            for (var row = 0; row < filter.errorMap.length; row++) {\n                for (var col = 0; col < filter.errorMap[0].length; col++) {\n                    filter.errorMap[row][col] = 0;\n                }\n            }\n\n            // Cache / convenience\n            var zeroPadding = layer.nextLayer.zeroPadding;\n\n            var fSSpread = Math.floor(layer.nextLayer.filterSize / 2);\n            var paddedLength = filter.errorMap.length + zeroPadding * 2;\n\n            // Zero pad the error map, to allow easy convoling\n            // TODO, may be more performant to just use if statements when updating, instead\n            filter.errorMap = NetUtil.addZeroPadding(filter.errorMap, zeroPadding\n\n            // For each channel in filter in the next layer which corresponds to this filter\n            );for (var nlFilterI = 0; nlFilterI < layer.nextLayer.size; nlFilterI++) {\n\n                var weights = layer.nextLayer.filters[nlFilterI].weights[filterI];\n                var errorMap = layer.nextLayer.filters[nlFilterI].errorMap;\n\n                // Unconvolve their error map using the weights\n                for (var inputY = fSSpread; inputY < paddedLength - fSSpread; inputY += layer.nextLayer.stride) {\n                    for (var inputX = fSSpread; inputX < paddedLength - fSSpread; inputX += layer.nextLayer.stride) {\n\n                        for (var weightsY = 0; weightsY < layer.nextLayer.filterSize; weightsY++) {\n                            for (var weightsX = 0; weightsX < layer.nextLayer.filterSize; weightsX++) {\n\n                                filter.errorMap[inputY + (weightsY - fSSpread)][inputX + (weightsX - fSSpread)] += weights[weightsY][weightsX] * errorMap[(inputY - fSSpread) / layer.nextLayer.stride][(inputX - fSSpread) / layer.nextLayer.stride];\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Take out the zero padding. Rows:\n            filter.errorMap = filter.errorMap.splice(zeroPadding, filter.errorMap.length - zeroPadding * 2\n\n            // Columns:\n            );for (var emXI = 0; emXI < filter.errorMap.length; emXI++) {\n                filter.errorMap[emXI] = filter.errorMap[emXI].splice(zeroPadding, filter.errorMap[emXI].length - zeroPadding * 2);\n            }\n        }\n    }, {\n        key: \"buildConvDWeights\",\n        value: function buildConvDWeights(layer) {\n\n            var weightsCount = layer.filters[0].weights[0].length;\n            var fSSpread = Math.floor(weightsCount / 2);\n            var channelsCount = layer.filters[0].weights.length;\n\n            // Adding an intermediary step to allow regularization to work\n            var deltaDeltaWeights = [];\n\n            // Filling the deltaDeltaWeights with 0 values\n            for (var weightsY = 0; weightsY < weightsCount; weightsY++) {\n                deltaDeltaWeights[weightsY] = [];\n                for (var weightsX = 0; weightsX < weightsCount; weightsX++) {\n                    deltaDeltaWeights[weightsY][weightsX] = 0;\n                }\n            }\n\n            // For each filter\n            for (var filterI = 0; filterI < layer.filters.length; filterI++) {\n\n                var filter = layer.filters[filterI];\n\n                // Each channel will take the error map and the corresponding inputMap from the input...\n                for (var channelI = 0; channelI < channelsCount; channelI++) {\n\n                    var inputValues = NetUtil.getActivations(layer.prevLayer, channelI, layer.inMapValuesCount);\n                    var inputMap = NetUtil.addZeroPadding(NetUtil.arrayToMap(inputValues, Math.sqrt(layer.inMapValuesCount)), layer.zeroPadding\n\n                    // ...slide the filter with correct stride across the zero-padded inputMap...\n                    );for (var inputY = fSSpread; inputY < inputMap.length - fSSpread; inputY += layer.stride) {\n                        for (var inputX = fSSpread; inputX < inputMap.length - fSSpread; inputX += layer.stride) {\n\n                            // ...and at each location...\n                            for (var _weightsY = 0; _weightsY < weightsCount; _weightsY++) {\n                                for (var _weightsX = 0; _weightsX < weightsCount; _weightsX++) {\n\n                                    var activation = inputMap[inputY - fSSpread + _weightsY][inputX - fSSpread + _weightsX];\n\n                                    // Increment and regularize the delta delta weights by the input activation (later multiplied by the error)\n                                    deltaDeltaWeights[_weightsY][_weightsX] += activation * (1 + ((layer.net.l2 || 0) + (layer.net.l1 || 0)) / layer.net.miniBatchSize * filter.weights[channelI][_weightsY][_weightsX]);\n                                }\n                            }\n\n                            var error = filter.errorMap[(inputY - fSSpread) / layer.stride][(inputX - fSSpread) / layer.stride];\n\n                            // Applying and resetting the deltaDeltaWeights\n                            for (var _weightsY2 = 0; _weightsY2 < weightsCount; _weightsY2++) {\n                                for (var _weightsX2 = 0; _weightsX2 < weightsCount; _weightsX2++) {\n                                    filter.deltaWeights[channelI][_weightsY2][_weightsX2] += deltaDeltaWeights[_weightsY2][_weightsX2] * error;\n                                    deltaDeltaWeights[_weightsY2][_weightsX2] = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Increment the deltaBias by the sum of all errors in the filter\n                for (var eY = 0; eY < filter.errorMap.length; eY++) {\n                    for (var eX = 0; eX < filter.errorMap.length; eX++) {\n                        filter.deltaBias += filter.errorMap[eY][eX];\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getActivations\",\n        value: function getActivations(layer, mapStartI, mapSize) {\n\n            if (arguments.length == 1) {\n\n                var returnArr = [];\n\n                if (layer instanceof FCLayer) {\n\n                    for (var ni = 0; ni < layer.neurons.length; ni++) {\n                        returnArr.push(layer.neurons[ni].activation);\n                    }\n                } else {\n\n                    for (var fi = 0; fi < layer.filters.length; fi++) {\n                        for (var rowI = 0; rowI < layer.filters[fi].activationMap.length; rowI++) {\n                            for (var colI = 0; colI < layer.filters[fi].activationMap[rowI].length; colI++) {\n                                returnArr.push(layer.filters[fi].activationMap[rowI][colI]);\n                            }\n                        }\n                    }\n                }\n\n                return returnArr;\n            } else {\n\n                var _returnArr = [];\n\n                if (layer instanceof FCLayer) {\n\n                    for (var i = mapStartI * mapSize; i < (mapStartI + 1) * mapSize; i++) {\n                        _returnArr.push(layer.neurons[i].activation);\n                    }\n                } else {\n\n                    for (var row = 0; row < layer.filters[mapStartI].activationMap.length; row++) {\n                        for (var col = 0; col < layer.filters[mapStartI].activationMap[row].length; col++) {\n                            _returnArr.push(layer.filters[mapStartI].activationMap[row][col]);\n                        }\n                    }\n                }\n                return _returnArr;\n            }\n        }\n    }]);\n\n    return NetUtil;\n}();\n\ntypeof window == \"undefined\" && (exports.NetUtil = NetUtil);\n\"use strict\";\n\nvar Network = function () {\n    function Network() {\n        var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            learningRate = _ref30.learningRate,\n            _ref30$layers = _ref30.layers,\n            layers = _ref30$layers === undefined ? [] : _ref30$layers,\n            _ref30$updateFn = _ref30.updateFn,\n            updateFn = _ref30$updateFn === undefined ? \"vanillaupdatefn\" : _ref30$updateFn,\n            _ref30$activation = _ref30.activation,\n            activation = _ref30$activation === undefined ? \"sigmoid\" : _ref30$activation,\n            _ref30$cost = _ref30.cost,\n            cost = _ref30$cost === undefined ? \"meansquarederror\" : _ref30$cost,\n            rmsDecay = _ref30.rmsDecay,\n            rho = _ref30.rho,\n            lreluSlope = _ref30.lreluSlope,\n            eluAlpha = _ref30.eluAlpha,\n            _ref30$dropout = _ref30.dropout,\n            dropout = _ref30$dropout === undefined ? 1 : _ref30$dropout,\n            _ref30$l = _ref30.l2,\n            l2 = _ref30$l === undefined ? true : _ref30$l,\n            _ref30$l2 = _ref30.l1,\n            l1 = _ref30$l2 === undefined ? true : _ref30$l2,\n            maxNorm = _ref30.maxNorm,\n            weightsConfig = _ref30.weightsConfig,\n            filterSize = _ref30.filterSize,\n            zeroPadding = _ref30.zeroPadding,\n            stride = _ref30.stride,\n            channels = _ref30.channels,\n            filterCount = _ref30.filterCount;\n\n        _classCallCheck(this, Network);\n\n        this.state = \"not-defined\";\n        this.layers = [];\n        this.epochs = 0;\n        this.iterations = 0;\n        this.dropout = dropout == false ? 1 : dropout;\n        this.error = 0;\n        activation = NetUtil.format(activation);\n        updateFn = NetUtil.format(updateFn);\n        cost = NetUtil.format(cost);\n\n        if (l2) {\n            this.l2 = typeof l2 == \"boolean\" ? 0.001 : l2;\n            this.l2Error = 0;\n        }\n\n        if (l1) {\n            this.l1 = typeof l1 == \"boolean\" ? 0.005 : l1;\n            this.l1Error = 0;\n        }\n\n        if (maxNorm) {\n            this.maxNorm = typeof maxNorm == \"boolean\" && maxNorm ? 1000 : maxNorm;\n            this.maxNormTotal = 0;\n        }\n\n        if (learningRate) this.learningRate = learningRate;\n        if (filterSize) this.filterSize = filterSize;\n        if (zeroPadding) this.zeroPadding = zeroPadding;\n        if (stride) this.stride = stride;\n        if (channels) this.channels = channels;\n        if (filterCount) this.filterCount = filterCount;\n\n        // Activation function / Learning Rate\n        switch (updateFn) {\n\n            case \"rmsprop\":\n                this.learningRate = this.learningRate == undefined ? 0.001 : this.learningRate;\n                break;\n\n            case \"adam\":\n                this.learningRate = this.learningRate == undefined ? 0.01 : this.learningRate;\n                break;\n\n            case \"adadelta\":\n                this.rho = rho == null ? 0.95 : rho;\n                break;\n\n            default:\n\n                if (this.learningRate == undefined) {\n\n                    switch (activation) {\n\n                        case \"relu\":\n                        case \"lrelu\":\n                        case \"rrelu\":\n                        case \"elu\":\n                            this.learningRate = 0.01;\n                            break;\n\n                        case \"tanh\":\n                        case \"lecuntanh\":\n                            this.learningRate = 0.001;\n                            break;\n\n                        default:\n                            this.learningRate = 0.2;\n                    }\n                }\n        }\n\n        this.updateFn = [false, null, undefined].includes(updateFn) ? \"vanillaupdatefn\" : updateFn;\n        this.weightUpdateFn = NetMath[this.updateFn];\n        this.activation = typeof activation == \"function\" ? activation : NetMath[activation].bind(this);\n        this.activationConfig = activation;\n        this.cost = typeof cost == \"function\" ? cost : NetMath[cost];\n\n        if (this.updateFn == \"rmsprop\") {\n            this.rmsDecay = rmsDecay == undefined ? 0.99 : rmsDecay;\n        }\n\n        this.lreluSlope = lreluSlope == undefined ? -0.0005 : lreluSlope;\n        this.eluAlpha = eluAlpha == undefined ? 1 : eluAlpha;\n\n        // Weights distributiom\n        this.weightsConfig = { distribution: \"xavieruniform\" };\n\n        if (weightsConfig != undefined && weightsConfig.distribution) {\n            this.weightsConfig.distribution = NetUtil.format(weightsConfig.distribution);\n        }\n\n        if (this.weightsConfig.distribution == \"uniform\") {\n            this.weightsConfig.limit = weightsConfig && weightsConfig.limit != undefined ? weightsConfig.limit : 0.1;\n        } else if (this.weightsConfig.distribution == \"gaussian\") {\n            this.weightsConfig.mean = weightsConfig.mean || 0;\n            this.weightsConfig.stdDeviation = weightsConfig.stdDeviation || 0.05;\n        }\n\n        if (typeof this.weightsConfig.distribution == \"function\") {\n            this.weightsInitFn = this.weightsConfig.distribution;\n        } else {\n            this.weightsInitFn = NetMath[this.weightsConfig.distribution];\n        }\n\n        // Status\n        if (layers.length) {\n\n            switch (true) {\n\n                case layers.every(function (item) {\n                    return Number.isInteger(item);\n                }):\n                    this.layers = layers.map(function (size) {\n                        return new FCLayer(size);\n                    });\n                    this.state = \"constructed\";\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (item) {\n                    return item instanceof FCLayer || item instanceof ConvLayer;\n                }):\n                    this.state = \"constructed\";\n                    this.layers = layers;\n                    this.initLayers();\n                    break;\n\n                default:\n                    throw new Error(\"There was an error constructing from the layers given.\");\n            }\n        }\n    }\n\n    _createClass(Network, [{\n        key: \"initLayers\",\n        value: function initLayers(input, expected) {\n\n            switch (this.state) {\n\n                case \"initialised\":\n                    return;\n\n                case \"not-defined\":\n                    this.layers[0] = new FCLayer(input);\n                    this.layers[1] = new FCLayer(Math.ceil(input / expected > 5 ? expected + Math.abs(input - expected) / 4 : input + expected));\n                    this.layers[2] = new FCLayer(Math.ceil(expected));\n                    break;\n            }\n\n            this.layers.forEach(this.joinLayer.bind(this));\n            this.state = \"initialised\";\n        }\n    }, {\n        key: \"joinLayer\",\n        value: function joinLayer(layer, layerIndex) {\n\n            layer.net = this;\n            layer.activation = layer.activation || this.activation;\n\n            layer.weightsConfig = {};\n            Object.assign(layer.weightsConfig, this.weightsConfig);\n\n            if (layerIndex) {\n                this.layers[layerIndex - 1].assignNext(layer);\n                layer.assignPrev(this.layers[layerIndex - 1]);\n\n                layer.weightsConfig.fanIn = layer.prevLayer.size;\n                layer.prevLayer.weightsConfig.fanOut = layer.size;\n\n                layer.init();\n                layer.state = \"initialised\";\n            }\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n\n            if (this.state != \"initialised\") {\n                throw new Error(\"The network layers have not been initialised.\");\n            }\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No data passed to Network.forward()\");\n            }\n\n            if (data.length != this.layers[0].neurons.length) {\n                console.warn(\"Input data length did not match input layer neurons count.\");\n            }\n\n            this.layers[0].neurons.forEach(function (neuron, ni) {\n                return neuron.activation = data[ni];\n            });\n            this.layers.forEach(function (layer, li) {\n                return li && layer.forward(data);\n            });\n            return this.layers[this.layers.length - 1].neurons.map(function (n) {\n                return n.activation;\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n\n            if (expected === undefined) {\n                throw new Error(\"No data passed to Network.backward()\");\n            }\n\n            if (expected.length != this.layers[this.layers.length - 1].neurons.length) {\n                console.warn(\"Expected data length did not match output layer neurons count.\", expected);\n            }\n\n            this.layers[this.layers.length - 1].backward(expected);\n\n            for (var layerIndex = this.layers.length - 2; layerIndex > 0; layerIndex--) {\n                this.layers[layerIndex].backward();\n            }\n        }\n    }, {\n        key: \"train\",\n        value: function train(dataSet) {\n            var _this7 = this;\n\n            var _ref31 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref31$epochs = _ref31.epochs,\n                epochs = _ref31$epochs === undefined ? 1 : _ref31$epochs,\n                callback = _ref31.callback,\n                _ref31$log = _ref31.log,\n                log = _ref31$log === undefined ? true : _ref31$log,\n                _ref31$miniBatchSize = _ref31.miniBatchSize,\n                miniBatchSize = _ref31$miniBatchSize === undefined ? 1 : _ref31$miniBatchSize,\n                _ref31$shuffle = _ref31.shuffle,\n                shuffle = _ref31$shuffle === undefined ? false : _ref31$shuffle;\n\n            this.miniBatchSize = typeof miniBatchSize == \"boolean\" && miniBatchSize ? dataSet[0].expected.length : miniBatchSize;\n\n            if (shuffle) {\n                NetUtil.shuffle(dataSet);\n            }\n\n            if (log) {\n                console.log(\"Training started. Epochs: \" + epochs + \" Batch Size: \" + this.miniBatchSize);\n            }\n\n            return new Promise(function (resolve, reject) {\n\n                if (dataSet === undefined || dataSet === null) {\n                    return void reject(\"No data provided\");\n                }\n\n                if (_this7.state != \"initialised\") {\n                    _this7.initLayers(dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length);\n                }\n\n                _this7.layers.forEach(function (layer) {\n                    return layer.state = \"training\";\n                });\n\n                var iterationIndex = 0;\n                var epochsCounter = 0;\n                var startTime = Date.now();\n\n                var doEpoch = function doEpoch() {\n                    _this7.epochs++;\n                    _this7.error = 0;\n                    iterationIndex = 0;\n\n                    if (_this7.l2Error != undefined) _this7.l2Error = 0;\n                    if (_this7.l1Error != undefined) _this7.l1Error = 0;\n\n                    doIteration();\n                };\n\n                var doIteration = function doIteration() {\n\n                    if (!dataSet[iterationIndex].hasOwnProperty(\"input\") || !dataSet[iterationIndex].hasOwnProperty(\"expected\") && !dataSet[iterationIndex].hasOwnProperty(\"output\")) {\n                        return void reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\");\n                    }\n\n                    var input = dataSet[iterationIndex].input;\n                    var output = _this7.forward(input);\n                    var target = dataSet[iterationIndex].expected || dataSet[iterationIndex].output;\n\n                    _this7.backward(target);\n\n                    if (++iterationIndex % _this7.miniBatchSize == 0) {\n                        _this7.applyDeltaWeights();\n                        _this7.resetDeltaWeights();\n                    } else if (iterationIndex >= dataSet.length) {\n                        _this7.applyDeltaWeights();\n                    }\n\n                    var iterationError = _this7.cost(target, output);\n                    var elapsed = Date.now() - startTime;\n                    _this7.error += iterationError;\n                    _this7.iterations++;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: _this7.iterations,\n                            error: iterationError,\n                            elapsed: elapsed, input: input\n                        });\n                    }\n\n                    if (iterationIndex < dataSet.length) {\n                        setTimeout(doIteration.bind(_this7), 0);\n                    } else {\n                        epochsCounter++;\n\n                        if (log) {\n                            console.log(\"Epoch: \" + _this7.epochs + \" Error: \" + _this7.error / iterationIndex + (_this7.l2 == undefined ? \"\" : \" L2 Error: \" + _this7.l2Error / iterationIndex), \"\\nElapsed: \" + NetUtil.format(elapsed, \"time\") + \" Average Duration: \" + NetUtil.format(elapsed / epochsCounter, \"time\"));\n                        }\n\n                        if (epochsCounter < epochs) {\n                            doEpoch();\n                        } else {\n                            _this7.layers.forEach(function (layer) {\n                                return layer.state = \"initialised\";\n                            });\n\n                            if (log) {\n                                console.log(\"Training finished. Total time: \" + NetUtil.format(elapsed, \"time\") + \"  Average iteration time: \" + NetUtil.format(elapsed / iterationIndex, \"time\"));\n                            }\n                            resolve();\n                        }\n                    }\n                };\n\n                _this7.resetDeltaWeights();\n                doEpoch();\n            });\n        }\n    }, {\n        key: \"test\",\n        value: function test(testSet) {\n            var _this8 = this;\n\n            var _ref32 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref32$log = _ref32.log,\n                log = _ref32$log === undefined ? true : _ref32$log,\n                callback = _ref32.callback;\n\n            return new Promise(function (resolve, reject) {\n\n                if (testSet === undefined || testSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                if (log) {\n                    console.log(\"Testing started\");\n                }\n\n                var totalError = 0;\n                var iterationIndex = 0;\n                var startTime = Date.now();\n\n                var testInput = function testInput() {\n\n                    var input = testSet[iterationIndex].input;\n                    var output = _this8.forward(input);\n                    var target = testSet[iterationIndex].expected || testSet[iterationIndex].output;\n                    var elapsed = Date.now() - startTime;\n\n                    var iterationError = _this8.cost(target, output);\n                    totalError += iterationError;\n                    iterationIndex++;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: iterationIndex,\n                            error: iterationError,\n                            elapsed: elapsed, input: input\n                        });\n                    }\n\n                    if (iterationIndex < testSet.length) {\n                        setTimeout(testInput.bind(_this8), 0);\n                    } else {\n\n                        if (log) {\n                            console.log(\"Testing finished. Total time: \" + NetUtil.format(elapsed, \"time\") + \"  Average iteration time: \" + NetUtil.format(elapsed / iterationIndex, \"time\"));\n                        }\n\n                        resolve(totalError / testSet.length);\n                    }\n                };\n                testInput();\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            this.layers.forEach(function (layer, li) {\n                return li && layer.resetDeltaWeights();\n            });\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n\n            this.layers.forEach(function (layer, li) {\n                return li && layer.applyDeltaWeights();\n            });\n\n            if (this.maxNorm != undefined) {\n                this.maxNormTotal = Math.sqrt(this.maxNormTotal);\n                NetMath.maxNorm.bind(this)();\n            }\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                layers: this.layers.map(function (layer) {\n                    return layer.toJSON();\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data) {\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No JSON data given to import.\");\n            }\n\n            if (data.layers.length != this.layers.length) {\n                throw new Error(\"Mismatched layers (\" + data.layers.length + \" layers in import data, but \" + this.layers.length + \" configured)\");\n            }\n\n            this.resetDeltaWeights();\n            this.layers.forEach(function (layer, li) {\n                return li && layer.fromJSON(data.layers[li], li);\n            });\n        }\n    }], [{\n        key: \"version\",\n        get: function get() {\n            return \"2.0.0\";\n        }\n    }]);\n\n    return Network;\n}();\n\ntypeof window == \"undefined\" && (exports.Network = Network);\n\"use strict\";\n\nvar Neuron = function () {\n    function Neuron() {\n        _classCallCheck(this, Neuron);\n    }\n\n    _createClass(Neuron, [{\n        key: \"init\",\n        value: function init() {\n            var _this9 = this;\n\n            var _ref33 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                updateFn = _ref33.updateFn,\n                activation = _ref33.activation,\n                eluAlpha = _ref33.eluAlpha;\n\n            var size = this.weights.length;\n            this.deltaWeights = this.weights.map(function (v) {\n                return 0;\n            });\n\n            switch (updateFn) {\n\n                case \"gain\":\n                    this.biasGain = 1;\n                    this.weightGains = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 1;\n                    });\n                    this.getWeightGain = function (i) {\n                        return _this9.weightGains[i];\n                    };\n                    this.setWeightGain = function (i, v) {\n                        return _this9.weightGains[i] = v;\n                    };\n                    break;\n\n                case \"adagrad\":\n                case \"rmsprop\":\n                case \"adadelta\":\n                    this.biasCache = 0;\n                    this.weightsCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                        return 0;\n                    });\n                    this.getWeightsCache = function (i) {\n                        return _this9.weightsCache[i];\n                    };\n                    this.setWeightsCache = function (i, v) {\n                        return _this9.weightsCache[i] = v;\n                    };\n\n                    if (updateFn == \"adadelta\") {\n                        this.adadeltaBiasCache = 0;\n                        this.adadeltaCache = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                            return 0;\n                        });\n                        this.getAdadeltaCache = function (i) {\n                            return _this9.adadeltaCache[i];\n                        };\n                        this.setAdadeltaCache = function (i, v) {\n                            return _this9.adadeltaCache[i] = v;\n                        };\n                    }\n                    break;\n\n                case \"adam\":\n                    this.m = 0;\n                    this.v = 0;\n                    break;\n            }\n\n            if (activation == \"rrelu\") {\n                this.rreluSlope = Math.random() * 0.001;\n            } else if (activation == \"elu\") {\n                this.eluAlpha = eluAlpha;\n            }\n        }\n    }, {\n        key: \"getWeight\",\n        value: function getWeight(i) {\n            return this.weights[i];\n        }\n    }, {\n        key: \"setWeight\",\n        value: function setWeight(i, v) {\n            this.weights[i] = v;\n        }\n    }, {\n        key: \"getDeltaWeight\",\n        value: function getDeltaWeight(i) {\n            return this.deltaWeights[i];\n        }\n    }, {\n        key: \"setDeltaWeight\",\n        value: function setDeltaWeight(i, v) {\n            this.deltaWeights[i] = v;\n        }\n    }]);\n\n    return Neuron;\n}();\n\ntypeof window == \"undefined\" && (exports.Neuron = Neuron);\n//# sourceMappingURL=Network.concat.js.map\n//# sourceMappingURL=Network.min.js.map\n"]}