{"version":3,"sources":["Network.min.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Layer","size","importedData","this","neurons","concat","map","n","ni","Neuron","undefined","value","layer","nextLayer","prevLayer","forEach","neuron","init","data","_this","sum","bias","pNeuron","pni","activation","weights","expected","_this2","error","derivative","reduce","p","c","weight","wi","deltaWeights","deltaBias","window","global","NetMath","prime","sigmoid","Math","exp","output","vi","log","calculated","desired","index","pow","prev","curr","deltaValue","learningRate","_gain","weightI","newVal","weightGains","max","biasGain","min","values","total","Network","_ref","arguments","_ref$learningRate","_ref$layers","layers","adaptiveLR","_ref$activation","_ref$cost","cost","state","epochs","iterations","weightUpdateFn","every","item","Number","isInteger","initLayers","definedLayers","Error","input","_this3","li","hidden","abs","round","ceil","joinLayer","bind","layerIndex","assignNext","assignPrev","console","warn","forward","backward","dataSet","_this4","_ref2","_ref2$epochs","callback","Promise","resolve","reject","iterationIndex","epochsCounter","doEpoch","doIteration","hasOwnProperty","resetDeltaWeights","applyDeltaWeights","iterationError","setTimeout","testSet","_this5","totalError","testIteration","testInput","dw","_this6","dwi","imported","v","random"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Layer = function () {\n    function Layer(size, importedData) {\n        _classCallCheck(this, Layer);\n\n        this.size = size;\n        this.neurons = [].concat(_toConsumableArray(new Array(size))).map(function (n, ni) {\n            return new Neuron(importedData ? importedData[ni] : undefined);\n        });\n    }\n\n    _createClass(Layer, [{\n        key: \"assignNext\",\n        value: function assignNext(layer) {\n            this.nextLayer = layer;\n        }\n    }, {\n        key: \"assignPrev\",\n        value: function assignPrev(layer) {\n            this.prevLayer = layer;\n            this.neurons.forEach(function (neuron) {\n                return neuron.init(layer.size);\n            });\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n            var _this = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                neuron.sum = neuron.bias;\n                _this.prevLayer.neurons.forEach(function (pNeuron, pni) {\n                    return neuron.sum += pNeuron.activation * neuron.weights[pni];\n                });\n                neuron.activation = _this.activation(neuron.sum);\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            var _this2 = this;\n\n            this.neurons.forEach(function (neuron, ni) {\n\n                if (typeof expected !== \"undefined\") {\n                    neuron.error = expected[ni] - neuron.activation;\n                } else {\n                    neuron.derivative = _this2.activation(neuron.sum, true);\n                    neuron.error = neuron.derivative * _this2.nextLayer.neurons.map(function (n) {\n                        return n.error * n.weights[ni];\n                    }).reduce(function (p, c) {\n                        return p + c;\n                    }, 0);\n                }\n\n                neuron.weights.forEach(function (weight, wi) {\n                    neuron.deltaWeights[wi] += neuron.error * _this2.prevLayer.neurons[wi].activation;\n                });\n\n                neuron.deltaBias = neuron.error;\n            });\n        }\n    }]);\n\n    return Layer;\n}();\n\ntypeof window == \"undefined\" && (global.Layer = Layer);\n\"use strict\";\n\nvar NetMath = function () {\n    function NetMath() {\n        _classCallCheck(this, NetMath);\n    }\n\n    _createClass(NetMath, null, [{\n        key: \"sigmoid\",\n\n\n        // Activation functions\n        value: function sigmoid(value, prime) {\n            return prime ? NetMath.sigmoid(value) * (1 - NetMath.sigmoid(value)) : 1 / (1 + Math.exp(-value));\n        }\n\n        // Cost functions\n\n    }, {\n        key: \"crossEntropy\",\n        value: function crossEntropy(target, output) {\n            return output.map(function (value, vi) {\n                return target[vi] * Math.log(value + 1e-15) + (1 - target[vi]) * Math.log(1 + 1e-15 - value);\n            }).reduce(function (p, c) {\n                return p - c;\n            }, 0);\n        }\n    }, {\n        key: \"meanSquaredError\",\n        value: function meanSquaredError(calculated, desired) {\n            return calculated.map(function (output, index) {\n                return Math.pow(output - desired[index], 2);\n            }).reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0) / calculated.length;\n        }\n\n        // Weight updating functions\n\n    }, {\n        key: \"noAdaptiveLR\",\n        value: function noAdaptiveLR(value, deltaValue) {\n            return value + this.learningRate * deltaValue;\n        }\n    }, {\n        key: \"gain\",\n        value: function gain(value, deltaValue, _gain, neuron, weightI) {\n\n            var newVal = value + this.learningRate * deltaValue * _gain;\n\n            if (newVal <= 0 && value > 0 || newVal >= 0 && value < 0) {\n                if (weightI != null) {\n                    neuron.weightGains[weightI] = Math.max(neuron.weightGains[weightI] * 0.95, 0.5);\n                } else {\n                    neuron.biasGain = Math.max(neuron.biasGain * 0.95, 0.5);\n                }\n            } else {\n                if (weightI != null) {\n                    neuron.weightGains[weightI] = Math.min(neuron.weightGains[weightI] + 0.05, 5);\n                } else {\n                    neuron.biasGain = Math.min(neuron.biasGain + 0.05, 5);\n                }\n            }\n\n            return newVal;\n        }\n\n        // Other\n\n    }, {\n        key: \"softmax\",\n        value: function softmax(values) {\n            var total = values.reduce(function (prev, curr) {\n                return prev + curr;\n            }, 0);\n            return values.map(function (value) {\n                return value / total;\n            });\n        }\n    }]);\n\n    return NetMath;\n}();\n\ntypeof window == \"undefined\" && (global.NetMath = NetMath);\n\"use strict\";\n\nvar Network = function () {\n    function Network() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$learningRate = _ref.learningRate,\n            learningRate = _ref$learningRate === undefined ? 0.2 : _ref$learningRate,\n            _ref$layers = _ref.layers,\n            layers = _ref$layers === undefined ? [] : _ref$layers,\n            adaptiveLR = _ref.adaptiveLR,\n            _ref$activation = _ref.activation,\n            activation = _ref$activation === undefined ? \"sigmoid\" : _ref$activation,\n            _ref$cost = _ref.cost,\n            cost = _ref$cost === undefined ? \"crossEntropy\" : _ref$cost;\n\n        _classCallCheck(this, Network);\n\n        this.state = \"not-defined\";\n        this.layers = [];\n        this.epochs = 0;\n        this.iterations = 0;\n\n        this.learningRate = learningRate;\n        this.weightUpdateFn = NetMath[adaptiveLR ? adaptiveLR : \"noAdaptiveLR\"];\n        this.activation = NetMath[activation];\n        this.cost = NetMath[cost];\n\n        if (layers.length) {\n\n            switch (true) {\n\n                case layers.every(function (item) {\n                    return Number.isInteger(item);\n                }):\n                    this.layers = layers.map(function (size) {\n                        return new Layer(size);\n                    });\n                    this.state = \"constructed\";\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (item) {\n                    return item instanceof Layer;\n                }):\n                    this.state = \"constructed\";\n                    this.layers = layers;\n                    this.initLayers();\n                    break;\n\n                case layers.every(function (item) {\n                    return item === Layer;\n                }):\n                    this.state = \"defined\";\n                    this.definedLayers = layers;\n                    break;\n\n                default:\n                    throw new Error(\"There was an error constructing from the layers given.\");\n            }\n        }\n    }\n\n    _createClass(Network, [{\n        key: \"initLayers\",\n        value: function initLayers(input, expected) {\n            var _this3 = this;\n\n            switch (this.state) {\n\n                case \"initialised\":\n                    return;\n\n                case \"defined\":\n                    this.layers = this.definedLayers.map(function (layer, li) {\n                        if (!li) return new layer(input);\n\n                        if (li == _this3.definedLayers.length - 1) return new layer(expected);\n\n                        var hidden = _this3.definedLayers.length - 2;\n                        var size = input / expected > 5 ? expected + (expected + Math.abs(input - expected) / 4) * (hidden - li + 1) / (hidden / 2) : input >= expected ? input + expected * (hidden - li) / (hidden / 2) : expected + input * (hidden - li) / (hidden / 2);\n\n                        return new layer(Math.max(Math.round(size), 0));\n                    });\n                    break;\n\n                case \"not-defined\":\n                    this.layers[0] = new Layer(input);\n                    this.layers[1] = new Layer(Math.ceil(input / expected > 5 ? expected + Math.abs(input - expected) / 4 : input + expected));\n                    this.layers[2] = new Layer(Math.ceil(expected));\n                    break;\n            }\n\n            this.layers.forEach(this.joinLayer.bind(this));\n            this.state = \"initialised\";\n        }\n    }, {\n        key: \"joinLayer\",\n        value: function joinLayer(layer, layerIndex) {\n\n            layer.activation = this.activation;\n\n            if (layerIndex) {\n                this.layers[layerIndex - 1].assignNext(layer);\n                layer.assignPrev(this.layers[layerIndex - 1]);\n            }\n        }\n    }, {\n        key: \"forward\",\n        value: function forward(data) {\n\n            if (this.state != \"initialised\") {\n                throw new Error(\"The network layers have not been initialised.\");\n            }\n\n            if (data === undefined) {\n                throw new Error(\"No data passed to Network.forward()\");\n            }\n\n            if (data.length != this.layers[0].neurons.length) {\n                console.warn(\"Input data length did not match input layer neurons count.\");\n            }\n\n            this.layers[0].neurons.forEach(function (neuron, ni) {\n                return neuron.activation = data[ni];\n            });\n            this.layers.forEach(function (layer, li) {\n                return li && layer.forward(data);\n            });\n            return this.layers[this.layers.length - 1].neurons.map(function (n) {\n                return n.activation;\n            });\n        }\n    }, {\n        key: \"backward\",\n        value: function backward(expected) {\n            if (expected === undefined) {\n                throw new Error(\"No data passed to Network.backward()\");\n            }\n\n            if (expected.length != this.layers[this.layers.length - 1].neurons.length) {\n                console.warn(\"Expected data length did not match output layer neurons count.\");\n            }\n\n            this.layers[this.layers.length - 1].backward(expected);\n\n            for (var layerIndex = this.layers.length - 2; layerIndex > 0; layerIndex--) {\n                this.layers[layerIndex].backward();\n            }\n        }\n    }, {\n        key: \"train\",\n        value: function train(dataSet) {\n            var _this4 = this;\n\n            var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                _ref2$epochs = _ref2.epochs,\n                epochs = _ref2$epochs === undefined ? 1 : _ref2$epochs,\n                callback = _ref2.callback;\n\n            return new Promise(function (resolve, reject) {\n\n                if (dataSet === undefined || dataSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                if (_this4.state != \"initialised\") {\n                    _this4.initLayers(dataSet[0].input.length, (dataSet[0].expected || dataSet[0].output).length);\n                }\n\n                var iterationIndex = 0;\n                var epochsCounter = 0;\n                var error = 0;\n\n                var doEpoch = function doEpoch() {\n                    _this4.epochs++;\n                    iterationIndex = 0;\n\n                    doIteration();\n                };\n\n                var doIteration = function doIteration() {\n\n                    if (!dataSet[iterationIndex].hasOwnProperty(\"input\") || !dataSet[iterationIndex].hasOwnProperty(\"expected\") && !dataSet[iterationIndex].hasOwnProperty(\"output\")) {\n                        return reject(\"Data set must be a list of objects with keys: 'input' and 'expected' (or 'output')\");\n                    }\n\n                    _this4.resetDeltaWeights();\n\n                    var input = dataSet[iterationIndex].input;\n                    var output = _this4.forward(input);\n                    var target = dataSet[iterationIndex].expected || dataSet[iterationIndex].output;\n\n                    _this4.backward(target);\n                    _this4.applyDeltaWeights();\n\n                    var iterationError = _this4.cost(target, output);\n                    error += iterationError;\n\n                    if (typeof callback == \"function\") {\n                        callback({\n                            iterations: _this4.iterations,\n                            error: iterationError,\n                            input: input\n                        });\n                    }\n\n                    _this4.iterations++;\n                    iterationIndex++;\n\n                    if (iterationIndex < dataSet.length) {\n                        setTimeout(doIteration.bind(_this4), 0);\n                    } else {\n\n                        epochsCounter++;\n                        console.log(\"Epoch: \" + epochsCounter + \" Error: \" + error / 100);\n\n                        if (epochsCounter < epochs) {\n                            doEpoch();\n                        } else resolve();\n                    }\n                };\n\n                doEpoch();\n            });\n        }\n    }, {\n        key: \"test\",\n        value: function test(testSet) {\n            var _this5 = this;\n\n            return new Promise(function (resolve, reject) {\n\n                if (testSet === undefined || testSet === null) {\n                    reject(\"No data provided\");\n                }\n\n                var totalError = 0;\n                var testIteration = 0;\n\n                var testInput = function testInput() {\n\n                    console.log(\"Testing iteration\", testIteration + 1, totalError / (testIteration + 1) / 100);\n\n                    var output = _this5.forward(testSet[testIteration].input);\n                    var target = testSet[testIteration].expected || testSet[testIteration].output;\n\n                    totalError += _this5.cost(target, output);\n\n                    testIteration++;\n\n                    if (testIteration < testSet.length) setTimeout(testInput.bind(_this5), 0);else resolve(totalError / testSet.length / 100);\n                };\n                testInput();\n            });\n        }\n    }, {\n        key: \"resetDeltaWeights\",\n        value: function resetDeltaWeights() {\n            this.layers.forEach(function (layer, li) {\n                li && layer.neurons.forEach(function (neuron) {\n                    neuron.deltaWeights = neuron.weights.map(function (dw) {\n                        return 0;\n                    });\n                });\n            });\n        }\n    }, {\n        key: \"applyDeltaWeights\",\n        value: function applyDeltaWeights() {\n            var _this6 = this;\n\n            this.layers.forEach(function (layer, li) {\n                li && layer.neurons.forEach(function (neuron) {\n                    neuron.deltaWeights.forEach(function (dw, dwi) {\n                        neuron.weights[dwi] = _this6.weightUpdateFn.bind(_this6, neuron.weights[dwi], dw, neuron.weightGains[dwi], neuron, dwi)();\n                    });\n                    neuron.bias = _this6.weightUpdateFn.bind(_this6, neuron.bias, neuron.deltaBias, neuron.biasGain, neuron)();\n                });\n            });\n        }\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            return {\n                layers: this.layers.map(function (layer) {\n                    return {\n                        neurons: layer.neurons.map(function (neuron) {\n                            return {\n                                bias: neuron.bias,\n                                weights: neuron.weights\n                            };\n                        })\n                    };\n                })\n            };\n        }\n    }, {\n        key: \"fromJSON\",\n        value: function fromJSON(data) {\n\n            if (data === undefined || data === null) {\n                throw new Error(\"No JSON data given to import.\");\n            }\n\n            this.layers = data.layers.map(function (layer) {\n                return new Layer(layer.neurons.length, layer.neurons);\n            });\n            this.state = \"constructed\";\n            this.initLayers();\n        }\n    }]);\n\n    return Network;\n}();\n\ntypeof window == \"undefined\" && (global.Network = Network);\n\"use strict\";\n\nvar Neuron = function () {\n    function Neuron(importedData) {\n        _classCallCheck(this, Neuron);\n\n        if (importedData) {\n            this.imported = true;\n            this.weights = importedData.weights || [];\n            this.bias = importedData.bias;\n        }\n    }\n\n    _createClass(Neuron, [{\n        key: \"init\",\n        value: function init(size) {\n            if (!this.imported) {\n                this.weights = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                    return Math.random() * 0.2 - 0.1;\n                });\n                this.bias = Math.random() * 0.2 - 0.1;\n            }\n\n            this.deltaWeights = this.weights.map(function (v) {\n                return 0;\n            });\n            this.weightGains = [].concat(_toConsumableArray(new Array(size))).map(function (v) {\n                return 1;\n            });\n            this.biasGain = 1;\n        }\n    }]);\n\n    return Neuron;\n}();\n\ntypeof window == \"undefined\" && (global.Neuron = Neuron);\n//# sourceMappingURL=Network.concat.js.map\n//# sourceMappingURL=Network.min.js.map\n"]}